% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung 4.0 International (CC BY 4.0)"
% http://creativecommons.org/licenses/by/4.0/deed.de

\chapter{Fallunterscheidungen und Verzweigungen}
\label{cha:conditionals}

Computerprogramme müssen bei manchen Daten, die sie
verarbeiten, zwischen verschiedenen Möglichkeiten differenzieren: Ist
die Wassertemperatur warm genug zum Baden?  Welche von fünf
Tupperschüsseln ist für eine bestimmte Menge Kartoffelsalat groß
genug?  Welches ist die richtige Abzweigung nach Dortmund?  Solche
Entscheidungen sind daran festgemacht, dass ein Wert zu einer von mehreren
verschiedenen 
Kategorien gehören kann~-- es handelt sich dann um eine sogenannte
\textit{Fallunterscheidung\index{Fallunterscheidung}}; 
mathematische Funktionen und Programm-Funktionen operieren auf Daten mit
Fallunterscheidung durch \textit{Verzweigungen\index{Verzweigung}}.
Um diese geht es in diesem Kapitel.

\section{Rechnen mit booleschen Werten}

Für die Programme dieses Kapitels benötigen wir eine neue Art von
Daten.  Die ergeben sich, wenn wir zum Beispiel zwei Zahlen
vergleichen:
%
\begin{alltt}
(< 0 5)
\evalsto{} #t
\end{alltt}
%
\texttt{(< 0 5)} ist die Schreibweise für $0 < 5$.  Das
\verb|#t| steht für "`true\index{true}"' oder "`wahr\index{wahr}"',
denn die Aussage "`ist 0 kleiner als 5"' stimmt ja.
Umgekehrt kommt natürlich nicht \verb|#t| heraus:
%
\begin{alltt}
(< 5 0)
\evalsto{} #f
\end{alltt}
%
Das \verb|#f| steht für "`false\index{false}"' oder
"`falsch\index{falsch}"', denn diese Aussage stimmt nicht.

"`Wahr"' und "`falsch"' heißen zusammen \textit{boolesche
  Werte\index{boolescher Wert}} oder auch
\textit{Wahrheitswerte\index{Wahrheitswert}}.\footnote{Die booleschen
  Werte sind benannt nach \textit{George Boole} (1815--1864), der als
  erster einen algebraischen Ansatz für die Behandlung von Logik mit
  den Werten "`wahr"' und "`falsch"' formulierte.}  Ein Ausdruck, bei
dem ein boolescher Wert herauskommt, heißt dementsprechend auch
\textit{boolescher Ausdruck\index{boolescher Ausdruck}}.

Wir werden boolesche Ausdrücke oft
\textit{Bedingungen\index{Bedingung}} nennen.  Wenn eine Bedingung
\verb|#t| liefert, werden wir auch die Sprachregelung benutzen, dass
die Bedingung \textit{gilt}~-- beziehungsweise, dass, wenn sie
\verb|#f| liefert, sie \textit{nicht gilt}.

\texttt{<}\index{<@\texttt{<}} ist eine eingebaute Funktion, die
auf "`kleiner gleich"' testet, also dem mathematischen Operator $<$
entspricht.  Ebenso gibt es auch \texttt{>}\index{>@\texttt{>}} für
"`größer als"' (Mathematik: $>$), \texttt{=}\index{=@\texttt{=}} für
"`gleich"' (Mathematik: $=$), \texttt{<=}\index{<@\texttt{<=}} für "`kleiner oder
gleich"' (Mathematik: $\leq$) und \texttt{>=}\index{>=@\texttt{>=}}
für "`größer oder gleich"' (Mathematik: $\geq$).

Analog zu \texttt{=} für Zahlen können Zeichenketten mit
\texttt{string=?}\index{string=?@\texttt{string=?}} verglichen werden:
\begin{alltt}
(string=? "Mike" "Mike")
\evalsto{} #t
(string=? "Herbert" "Mike")
\evalsto{} #f
\end{alltt}
%
\verb|#t| und \verb|#f| sind wie Zahlen Literale, können also
auch in Programmen stehen:
%
\begin{alltt}
#t
\evalsto{} #t
#f
\evalsto{} #f
\end{alltt}
%
Programme können mit booleschen Werten auch rechnen.  Ein Ausdruck der
Form\index{and@\texttt{and}}
%
\begin{alltt}
(and \(e\sb{1}\) \(e\sb{2}\) \(\ldots\) \(e\sb{n}\))
\end{alltt}
%
ergibt immer dann \verb|#t|, wenn alle $e_i$ \verb|#t| ergeben, sonst
\verb|#f|.  Bei zwei Operanden $e_1$ und $e_2$ ergibt \texttt{(and
  $e_1$ $e_2$)} immer dann \verb|#t|, wenn $e_1$ \emph{und} $e_2$
\verb|#t| ergeben:\ref{page:and}
%
\begin{alltt}
(and #t #t)
\evalsto{} #t
(and #f #t)
\evalsto{} #f
(and #t #f)
\evalsto{} #f
(and #f #f)
\evalsto{} #f
\end{alltt}
%
Entsprechend gibt es Ausdrücke der Form\index{or@\texttt{or}}
%
\begin{alltt}
(or \(e\sb{1}\) \(e\sb{2}\) \(\ldots\) \(e\sb{n}\))
\end{alltt}
%
die immer dann \verb|#t| ergeben, wenn \emph{einer} der $e_i$ \verb|#t| ergibt, sonst
\verb|#f|.  Bei zwei Operanden $e_1$ und $e_2$ ergibt \texttt{(or
  $e_1$ $e_2$)} immer dann \verb|#t|, wenn $e_1$ \emph{oder} $e_2$
\verb|#t| ergeben:
%
\begin{alltt}
(or #t #t)
\evalsto{} #t
(or #f #t)
\evalsto{} #t
(or #t #f)
\evalsto{} #t
(or #f #f)
\evalsto{} #f
\end{alltt}
%
Des weiteren gibt es noch eine eingebaute Funktion
\texttt{not}\index{not@\texttt{not}}, die einen booleschen Wert
umdreht, sich also folgendermaßen verhält:
%
\begin{alltt}
(not #f)
\evalsto{} #t
(not #t)
\evalsto{} #f
\end{alltt}
%

\section{Verzweigungen}

Um Fallunterscheidungen zu demonstrieren, nehmen wir uns folgende
Beispielaufgabe vor: Wir schreiben eine Funktion, die eine Zahl (auf
Englisch) "`aufsagen"' soll.  Sie soll sich so verhalten:
%
\begin{alltt}
(say-number 0)
\evalsto{} "zero"
(say-number 0)
\evalsto{} "one"
\end{alltt}
%
Der Einfachheit halber beschränken wir uns vorläufig auf die Zahlen
von Null bis Drei.  Die Funktion hat folgende Kurzbeschreibung:
%
\begin{alltt}
; Zahl zu Text machen
\end{alltt}
%
Die Funktion macht aus einer natürlichen Zahl eine Zeichenkette und
hat folgende Signatur:\index{say-number@\texttt{say-number}}
%
\begin{alltt}
(: say-number (natural -> string))
\end{alltt}
%
Die Signatur sagt leider nichts darüber aus, dass die Funktion nur bis
Drei funktioniert~-- später werden wir noch beschreiben, wie die
Signatur präziser werden kann.  Hier wollten wir uns jedoch erst
einmal auf die Funktionsdefinition konzentrieren.  Vorher machen wir
aber die obigen Beispiele zu Testfällen und fügen noch zwei hinzu:
%
\begin{alltt}
(check-expect (say-number 0) "zero")
(check-expect (say-number 1) "one")
(check-expect (say-number 2) "two")
(check-expect (say-number 3) "three")
\end{alltt}
%
Das Gerüst ergibt sich direkt aus der Signatur:
%
\begin{alltt}
(define say-number
  (lambda (n)
    \ldots))
\end{alltt}
%
Aber wie kommen wir jetzt weiter?  Die Eingabe zerfällt ja in vier
Fälle~-- 0, 1, 2 und 3~-- sie bildet somit eine
\textit{Fallunterscheidung\index{Fallunterscheidung}}.  Um eine
Fallunterscheidung in der Eingabe einer Funktion verarbeiten zu können,
benötigen wir ein neues Programmelement, die
\textit{Verzeweigung\index{Verzweigung}}.  Verzweigungen beginnen mit
dem Wort \texttt{cond} und gehören zu den kompliziertesten
Programmelementen, die wir in diesem Buch benutzen.  Aber keine Sorge,
so schlimm wird es nicht.  Um eine Verzweigung zu schreiben, müssen
wir wissen, \emph{wie viele} Fälle es gibt.  In diesem Fall sind das
vier.  Die Verzewigung dafür hat folgende Form:
%

\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Jeder von den beiden \texttt{(\ldots \ldots)} ist ein sogenannter
\textit{Zweig\index{Zweig}}.  Der erste Teil eines Zweigs ist immer
eine Bedingung, der für den entsprechenden Fall \verb|#t| liefern
sollte und für die anderen Fälle \verb|#f|.  In diesem Fall muss die
Bedingung jedes Zweiges jeweils eine der Zahlen von Null bis Drei
identifizieren:
%
\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      ((= n 0) \ldots")
      ((= n 1) \ldots)
      ((= n 2) \ldots)
      ((= n 3) \ldots))))
\end{alltt}
%
Der jeweils zweite Teil des Zweiges ist das gewünschte Ergebnis für
den entsprechenden Fall.  Wenn wir das ausfüllen, sieht das Resultat
so aus:
%
\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      ((= n 0) "zero")
      ((= n 1) "one")
      ((= n 2) "two")
      ((= n 3) "three"))))
\end{alltt}
%
Fertig!
\begin{aufgabe}
  Finde heraus was passiert, wenn Du die Funktion mit einer Zahl
  aufrufst, für die sie nicht gemacht ist.
\end{aufgabe}

\section{Aufzählungen}

Nächste Beispielaufgabe: Wir wollen Haustiere einteilen in niedliche
und nicht so niedliche.  Es gibt in der Welt dieser Aufgabe nur drei
verschiedene Haustiere: Katzen, Hunde und Pythons.  Die Haustiere
bilden eine sogenannte \textit{Aufzählung\index{Aufzählung}}, die wir
in einem Kommentar im Programm so beschreiben könnten:
%
\begin{verbatim}
; Ein Haustier ist eins der folgenden:
; - Katze
; - Hund
; - Schlange
\end{verbatim}
%
Solch ein kurzen Kommentar, der die Daten beschreibt, die in unserer
Aufgabe vorkommen, heißt
\textit{Datendefinition\index{Datendefinition}} und ist das Resultat
eines Nachdenkprozesses, der \textit{Datenanalyse\index{Datenanalyse}}
heißt.  (Auch wenn er hier reichlich kurz ausgefallen ist.)

Dass es sich um eine Aufzählung handelt, erkennen wir an der
Datendefinition: Wir benötigen für unsere Aufgabe nur die Information,
um welche Alternative aus der Datendefinition es geht~-- hier: welches
Haustier.  Für die Elemente einer Aufzählung benutzen wir 
Zeichenketten mit dem entsprechenden Text, also \verb|"Katze"|,
\verb|"Hund"| und \verb|"Schlange"|.

Für die Aufzählung der Haustiere gibt es noch keine fertige Signatur,
die müssen wir deshalb erst noch definieren.  Die
\textit{Signatur-Definition\index{Signatur-Definition}} sieht so aus:
%
\begin{alltt}
(define pet
  (signature (one-of "Katze" "Hund" "Schlange")))
\end{alltt}
%
Da sind gleich zwei neue Programmelemente drin:
%
\begin{itemize}
\item \texttt{Signature\index{signature@\texttt{signature}}} müssen wir immer schreiben, wenn wir eine
  neue Signatur erzeugen.
\item \texttt{One-of\index{one-of@\texttt{one-of}}} (das funktioniert
  nur innerhalb eines \texttt{signature}-Ausdrucks) ist für
  Aufzählungen zuständig.  In einem \texttt{one-of}-Ausdruck stehen
  die Werte, die zur Aufzählung gehören.
\end{itemize}
%
\begin{aufgabe}
  Die Funktion \texttt{say-number} aus dem vorigen Abschnitt hat ja als
  Signatur-Deklaration die folgende:
\begin{alltt}
(: say-number (natural -> string))
\end{alltt}
  % 
  Mach die Signatur präziser mit Hilfe von Datendefinitionen und
  Signatur-Definitionen!
\end{aufgabe}
%
Zurück zu unserer Funktion zur Niedlichkeitsanalyse.  Die definierte
Signatur \texttt{pet} können wir nun in der Signatur-Deklaration
unserer Funktion benutzen.  Zusammen mit der Kurzbeschreibung sieht
das so aus:
%
\begin{alltt}
; Ist Haustier niedlich?
(: cute? (pet -> boolean))
\end{alltt}
%
Das Fragezeichen gehört zum Namen der Funktion und ist eine
Konvention, die wir für die Namen von Funktionen verwenden, die einen
booleschen Wert zurückgeben~-- also solche Funktionen, die eine
Ja-/Nein-Frage beantworten.

Da es nur drei Möglichkeiten für die Eingabe gibt, können wir für alle
drei jeweils einen Test schreiben:
%
\begin{alltt}
(check-expect (cute? "Katze") #t)
(check-expect (cute? "Hund") #t)
(check-expect (cute? "Schlange") #f)
\end{alltt}
%
Kommen wir zur Funktion selbst.  Zunächst einmal das Gerüst:
%
\begin{alltt}
(define cute?
  (lambda (p)
    \ldots))
\end{alltt}
%
Da es sich bei der Eingabe um eine Aufzählung, also eine
Fallunterscheidung handel, brauchen wir eine Verzweigung im Rumpf.  Da
es drei Fälle in der Aufzählung gibt, braucht die Verzweigung
ebenfalls drei Zweige:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Als nächstes müssen wir die Bedingungen schreiben, und die sollten
\texttt{p} jeweils mit \verb|"Katze"|, \verb|"Hund"| und
\verb|"Schlange"| vergleichen.  Dabei könnte man leicht auf die Idee
kommen, \verb|(= p "Katze")| etc.\ zu schreiben.  Dann kommt
allerdings eine Fehlermeldung etwa so:
%
\begin{verbatim}
=: Zahl als erstes Argument erwartet, "Katze" bekommen
\end{verbatim}
%
Die Funktion \texttt{=} fühlt sich also nur für Zahlen zuständig, für
Zeichenketten müssen wir die Funktion
\texttt{string=?\index{string=?@\texttt{string=?}}} verwenden:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      ((string=? p "Katze") \ldots)
      ((string=? p "Hund") \ldots)
      ((string=? p "Schlange") \ldots))))
\end{alltt}
%
Bisher ergibt sich alles rein aus der Definition von \texttt{pet}.
Schließlich müssen wir noch die Antworten ergänzen.  Katze und Hunde
sind niedlich, Schlangen nicht:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      ((string=? p "Katze") #t)
      ((string=? p "Hund") #t)
      ((string=? p "Schlange") #f))))
\end{alltt}
%
Fertig!

\section{Zahlenbereiche}
\label{sec:zahlenbereiche}

Eine weitere häufig vorkommende Art der Fallunterscheidung gibt es bei
Zahlenbereichen.

Um das zu demonstrieren, nehmen wir uns folgende Aufgabe vor: Wir
schreiben eine Funktion, die "`Wasser erhitzt"', das heißt aus einer
Wasser-Anfangstemperatur und der Temperatur, die wir an Hitze hinzufügen, die
resultierende Temperatur bestimmt.  Wir schreiben dazu drei Versionen der
Funktion:
%
\begin{itemize}
\item Die erste, naive Version addiert einfach auf die
  Anfangstemperatur die hinzugefügte Hitze.
\item Die zweite Version berücksichtigt, dass Wasser bei 100°C siedet
  und nicht heißer werden kann.
\item Die dritte Version berücksichtigt zusätzlich, dass gefrorenem
  Wasser von 0°C eine Hitze von 80°C hinzugefügt werden muss, damit es
  schmilzt und dann immer noch erst bei 0°C ist.
\end{itemize}
%
(Physikalisch ist das natürlich Umfug, aber es geht
um ein möglichst einfaches Programmier-Beispiel.)

\paragraph{Naive Version} Wir fangen mit der naiven Version an und gehen nach dem Ablauf der
Konstruktionsanleitungen vor.  Zuerst kommt also eine
Kurzbeschreibung:
%
\begin{alltt}
; Wassertemperatur nach Erhitzen berechnen, naiv
\end{alltt}
%
Als nächstes kommt die Signatur-Deklaration.  Die Anfangstemperatur
und die hinzugefügte Hitze sind die Eingaben; sie stellen wir als
reelle Zahlen dar.  Heraus kommt die Endtemperatur, auch eine reele
Zahl.  Da wir schon wissen, dass diese Version etwas einfach ist,
hängen wir eine \texttt{-0} an den Namen:
%
\begin{alltt}
(: heat-water-0 (real real -> real))
\end{alltt}                
%
Nun schreiben wir einige einfache Beispiele als Testfälle hin:
%
\begin{alltt}
(check-expect (heat-water-0 -10 20) 10)
(check-expect (heat-water-0 10 20) 30)
(check-expect (heat-water-0 90 20) 110)
\end{alltt}
%
Als nächstes kommt das Gerüst an die Reihe:
%
\begin{alltt}
(define heat-water-0
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Der Rumpf ist jetzt kein Hexenwerk, die beiden Eingaben werden
einfach addiert:
%
\begin{alltt}
(define heat-water-0
  (lambda (temp heat)
    (+ temp heat)))
\end{alltt}
%
Noch die Tests laufen lassen und fertig!

\paragraph{Siedendes Wasser} Als nächstes wollten wir berücksichtigen,
dass Wasser nicht über 100°C heiß werden kann.  Die Kurzbeschreibung
passen wir nur leicht an; die Signatur bleibt ebenfalls fast
unverändert~-- wir ändern nur den Namen und machen aus der 0 eine 1:
%
\begin{alltt}
; Wassertemperatur nach Erhitzen berechnen, Sieden berücksichtigen
(: heat-water-1 (real real -> real))
\end{alltt}
%
Bei den Tests können wir natürlich die Tests von \texttt{heat-water-0}
kopieren, aber den letzten müssen wir anpassen:
%
\begin{alltt}
(check-expect (heat-water-1 -10 20) 10)
(check-expect (heat-water-1 10 20) 30)
(check-expect (heat-water-1 90 20) 100)
\end{alltt}
%
Beim Testen ist es immer sinnvoll, auch Grenzfälle zu testen~--
schaltet die Funktion wirklich "`rum"', wenn die 100 erreicht sind.
Dazu dienen folgende zwei Testfälle:
%
\begin{alltt}
(check-expect (heat-water-1 99 1) 100)
(check-expect (heat-water-1 99 2) 100)
\end{alltt}
%
Da die Signatur die gleiche ist, ist auch das Gerüst identisch:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Ab 100°C muss die Funktion ihr Ergebnis also anders berechnen.  Oder,
anders gesagt, die Eingaben fallen in zwei verschiedene Klassen: die,
bei denen die Summe unter 100 liegt und die, bei denen sie darüber
liegt.
Wir benötigen also ein \texttt{cond} mit zwei
Zweigen:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      (\ldots \ldots)
      (\ldots \ldots))))
\end{alltt}
%
Wir brauchen nun eine Bedingung, die feststellt, ob die Summe aus
\texttt{temp} und \texttt{heat} unterhalb von 100 liegt (genauer:
kleiner \emph{oder gleich}, weil 100 gerade so erreichbar ist) und
eine dafür, dass die Summe darüber liegt.  Die könnten so aussehen:
%
\begin{alltt}
(<= (+ temp heat) 100)
(> (+ temp heat) 100)
\end{alltt}
%
Wenn wir diese beiden Bedingungen an die entsprechenden Stellen im
Rumpf setzen, sieht das so aus:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      ((<= (+ temp heat) 100) \ldots)
      ((> (+ temp heat) 100) \ldots))))
\end{alltt}
%
An die Stellen nach den Bedingungen müssen wir Ausdrücke setzen, die
das Ergebnis liefern, das im jeweiligen Fall richtig ist.  Das wäre dann:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      ((<= (+ temp heat) 100) (+ temp heat))
      ((> (+ temp heat) 100) 100))))
\end{alltt}
%
Fertig!
%
%

%
\begin{aufgabe}
  Müssen es bei den beiden Bedingungen unbedingt \verb|<=| und
  \verb|>| sein?  Was passiert, wenn Du \verb|<=| durch \verb|<|
  ersetzt und das Programm dann laufen lässt?  Was passiert, wenn Du
  dann auch das \verb|>| ersetzt~-- durch \verb|>=|?  Warum
  funktioniert das Programm dann immer noch?
\end{aufgabe}
%
\paragraph{Siendendes Wasser und Eis} Kommen wir zur "`Vollversion"'.
Zur Erinnerung: Da müssen wir noch berücksichtigen, dass gefrorenem
Wasser von 0°C eine Hitze von 80°C hinzugefügt werden muss, damit es
schmilzt und dann immer noch hat 0°C.  

Wir fangen wieder mit der Kurzbeschreibung an:
%
\begin{verbatim}
; Wassertemperatur nach Erhitzen berechnen, mit Eis & Sieden
\end{verbatim}
%
Da diese Version die letzte ist, hat sie keine Nummer mehr.  Ansonsten
ist die Signatur unverändert:
%
\begin{verbatim}
(: heat-water (real real -> real))
\end{verbatim}
%
Die Tests können wir nicht unverändert übernehmen.  Gleich der erste
funktioniert nicht mehr:
%
\begin{verbatim}
(check-expect (heat-water -10 20) 10)
\end{verbatim}
%
Das Aufwärmen des Wassers von -10°C auf 0°C erfordert nur 10°C
Wärmezufuhr, dann aber müssen erst einmal 80° weitere Wärme zugeführt
werden, damit es weiter geht.  Den Testfall müssen wir also ändern:
%
\begin{verbatim}
(check-expect (heat-water -10 20) 0)
\end{verbatim}
%
Die anderen Testfälle \texttt{heat-water-1} können so bleiben:
%
\begin{verbatim}
(check-expect (heat-water 10 20) 30)
(check-expect (heat-water 90 20) 100)
(check-expect (heat-water 99 1) 100)
(check-expect (heat-water 99 2) 100)
\end{verbatim}
%
Ein paar weitere Tests sollten aber noch genau klären, was um den
Nullpunkt herum so passiert und wo genau er überschritten wird:
%
\begin{verbatim}
(check-expect (heat-water -10 5) -5)
(check-expect (heat-water -5 60) 0)
(check-expect (heat-water -5 90) 5)
(check-expect (heat-water -1 81) 0)
(check-expect (heat-water -1 82) 1)
\end{verbatim}
%
Wieder sollten wir darüber nachdenken, in was für Fälle unsere
Eingaben zerfallen.  Da gibt es drei naheliegende Fälle:
%
\begin{enumerate}
\item Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
\item Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
\item Alles andere~-- das Wasser fängt flüssig an und bleibt durch die
  Erwärmung flüssig.
\end{enumerate}
%
Der erste Fall hat außerdem noch drei "`Unterfälle"':
%
\begin{itemize}
\item Die Erwärmumg bleibt unter 0°C.
\item Die Erwärmung bleibt bei  0°C "`stecken"'
\item Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
\end{itemize}
%
So komplizierte Fallunterscheidungen sind relativ selten. Wenn sie
doch einmal auftauchen, ist besondere Sorgfalt gefragt: Darum
exerzieren wir das hier als Beispiel durch.

Fangen wir wieder mit dem Gerüst für die Funktion an:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Wir wissen schon aus der Analyse der Fälle, dass es drei Fälle gibt.
Deshalb brauchen wir auch wieder ein \texttt{cond} mit drei Zweigen.
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Jetzt ergänzen wir Bedingungen, die den drei Fällen entsprechen.  Um
in diesem komplizierten Fall Leserinnen zu erleichtern, die
Bedingungen den Fällen zuzuordnen, stehen diese jeweils als Kommentar darüber:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0) \ldots)
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) \ldots)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100)) \ldots))))
\end{alltt}
%
Jetzt können wir uns daran machen, die Zweige auszufüllen.  Da der
erste Zweig (das Eis) komplizierter ist, schieben wir den erstmal vor
uns her, denn beim zweiten Zweig kommt einfach 100°C raus.  Ebenso
einfach ist der dritte Zweig, bei dem das Wasser flüssig bleibt~-- die
Antwort ist dort \texttt{(+ temp heat)}.  Der Zwischenstand sieht so
aus:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0) \ldots)
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Dass wir die leichten Fälle zuerst bearbeitet haben, mag wie Faulheit
aussehen.  Ist es auch~-- aber es ist auch sinnvolle Strategie.  Sie
könnte so beschrieben werden:
%
\begin{center}
  \emph{Schreibe auf, was Du weißt.}
\end{center}
%
Auch über den ersten Zweig wissen wir etwas, nämlich dass er selbst
eine Fallunterscheidung ist mit drei Fällen.  Wir können also das
\texttt{cond} (wieder einmal) schon hinschreiben:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         (\ldots{} \ldots)
         (\ldots{} \ldots)
         (\ldots{} \ldots)))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Auch hier ist es sinnvoll, die Beschreibungen der Fälle über die
Zweige zu schreiben.  Danach ergänzen wir die Bedingungen mit
folgendem Ergebnis:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) \ldots)
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          \ldots)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         ((and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
          \ldots)))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Die Bedingungen sind jetzt noch komplizierter, aber erschließen sich
hoffentlich durch genauere Betrachtungen:
%
\begin{itemize}
\item "`Die Erwärmumg bleibt unter 0°C."'\\
  Das heißt, die Summe von
  Anfangstemperatur und Erwärmung ist kleiner als 0°C.
\item "`Die Erwärmung bleibt bei  0°C stecken."'\\
  Das heißt, die Summe von Temperatur und Erwärmung muss zwischen 0°C
  und 80°C liegen.
\item "`Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus."'\\
  Das Summe von Temperatur und Erwärmung geht nicht nur über 0°C
  sondern auch über 80°C hinaus.
\end{itemize}
%
Die Antworten unter diesen Bedingungen sind vergleichweise einfach zu
ergänzen:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) (+ temp heat))
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          0)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         ((and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
          (- (+ temp heat) 80))))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Fertig!\footnote{Allerdings noch nicht ganz richtig: Vielleicht siehst Du,
  dass da noch etwas nicht ganz stimmt.  Wir kommen später darauf zurück.}

\medskip

Also \emph{fast} fertig.  Wenn wir das Programm näher betrachten,
fällt etwas Verbesserungspotenzial auf.  Fangen wir an mit der
Bedingung:
%
\begin{verbatim}
          (and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
\end{verbatim}
%
Das ist übertrieben: Eine Temperatur über 80°C liegt auch über 0°C.
Wir können das also vereinfachen auf:
%
\begin{verbatim}
          (>= (+ temp heat) 80)
\end{verbatim}
%
Das ist mathematisch einleuchtend, zur Sicherheit sollten wir aber die
Tests nochmals laufen lassen: Aber sie laufen alle noch erfolgreich
durch.

Bevor wir die Funktion noch weiter vereinfachen, ist es sinnvoll, die
Funktionsweis eder Auswertung von \texttt{cond}-Ausdrücken zu ergründen:
%
\begin{aufgabe}
  Lasse die \texttt{heat-water}-Funktion im Stepper laufen und
  beobachte, wie~-- vor allem in welche Reihenfolge~-- die Bedindungen
  in einem \texttt{cond}-Ausdruck ausgewertet werden.
\end{aufgabe}
%
Wenn Du diese Aufgabe erledigt hast, wirst Du beobachtet haben, dass Racket
die Bedingungen in einem \texttt{cond}-Ausdruck nacheinander
auswertet.  Sobald eine davon \verb|#t| ergibt, macht Racket mit dem
Ausdruck des Zweiges weiter.  Die restlichen Zweige werden gar nicht
mehr berücksichtigt, unabhängig davon, ob sie \verb|#t| ergeben
könnten oder nicht.
Das können wir ausnutzen, um die Funktion weiter zu vereinfachen.
Dazu betrachten wir die beiden ersten Bedingungen im "`inneren"'
\texttt{cond}:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          0)
         \ldots)
\end{alltt}
%
Wenn die erste Bedingung \verb|#f| ergeben hat, also nicht stimmt,
dann ist \texttt{(+ temp heat)} größer oder gleich 0.  Das heißt, der
Teilausdruck \texttt{(>= (+ temp heat) 0)} in der \emph{nächsten}
Bedingung liefert \emph{immer} \verb|#t|.  Wir können also
vereinfachen:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((and #t
               (< (+ temp heat) 80))
          0)
         \ldots)
\end{alltt}
%
Ein Ausdruck \texttt{(and \#t \(e\))} liefert immer das gleiche Ergebnis
wie \(e\)~-- schau nochmal auf Seite~\pageref{page:and}, um Dich davon
zu überzeugen!  Wir können also das innere \texttt{cond} weiter
vereinfachen zu:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((< (+ temp heat) 80) 0)
         \ldots)
\end{alltt}
%
Wir benutzen also Mathematik (genauer gesagt
\textit{Algebra\index{Algebra}}, also die Lehre der Gleichungen), um
unser Programm zu vereinfachen.  Algebra ist ein sehr mächtiges
Werkzeug in der Programmierung, und wir werden es noch oft nutzen.
Das fällt oft einfacher, wenn wir gar nicht über die konkrete
Bedeutung der Ausdrücke nachdenken sondern nur Gleichungen benutzen,
wie oft in der Mathematik.

Wir sind aber mit dem Vereinfachen noch nicht fertig. Betrachten wir
nun die drei "`äußeren"' Bedingungen:
%
\begin{alltt}
    (cond
      ((< temp 0) \ldots)
      ((>= (+ temp heat) 100) \ldots)
      ((and (>= temp 0) (< (+ temp heat) 100)) \ldots))
\end{alltt}
%
Wenn die erste Bedingungen \verb|#f| ergibt, gilt automatisch
\texttt{(>= temp 0)}.  Wir können die letzte Bedingung also
vereinfachen zu:
%
\begin{alltt}
(and #t (< (+ temp heat) 100))
\end{alltt}
%
Wenn auch die zweite Bedingung \verb|#f| ergibt, gilt auch \texttt{(<
  (+ temp heat) 100)}.  Wir können also vereinfachen zu \texttt{(and
  \#t \#t)} und von da zu \verb|#t|.

Wir können die Funktion mit dieser Einsicht vereinfachen und \verb|#t|
als Bedingung hinschreiben.  (Probier es aus!)  Allerdings finden
manche das hässlich: Darum ist es auch möglich, statt \verb|#t| das
besondere Wort \texttt{else\index{else@\texttt{else}}}
("`andernfalls"' auf Englisch) hinzuschreiben.
Der \texttt{else}-Zweig kommt also zum Zug, wenn alle anderen
"`durchgefallen"' sind.  Das Ergebnis sieht
dann so aus:
%
\begin{verbatim}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) (+ temp heat))
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((< (+ temp heat) 80) 0)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         (else (- (+ temp heat) 80))))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      (else
       (+ temp heat)))))
\end{verbatim}
%
\begin{feature}{Verzweigung}{scheme:cond}
In den Lehrsprachen werden Verzweigungen\index{Verzweigung}\index{Verzweigung}
mit der Spezialform \texttt{cond}\index{cond@\texttt{cond}} dargestellt.
Ein \texttt{cond}"=Ausdruck hat die folgende Form:
%
\begin{alltt}
(cond
  (\(b\sb{1}\) \(a\sb{1}\))
  (\(b\sb{2}\) \(a\sb{2}\))
  \(\ldots\)
  (\(b\sb{n-1}\) \(a\sb{n-1}\))
  (else \(a\sb{n}\))))
\end{alltt}
%
Dabei sind die $b_i$ und die $a_i$ ihrerseits Ausdrücke.  Der
\texttt{cond}-Ausdruck wertet nacheinander alle Bedingungen $b_i$ aus;
sobald eine Bedingung $b_k$ \texttt{\#t} ergibt, wird der
\texttt{cond}-Ausdruck durch das entsprechende $a_k$ ersetzt.  Wenn
alle Bedingungen fehlschlagen, wird durch $a_n$ ersetzt.  Die Paarungen
\texttt{($b_i$ $a_i$)} heißen \textit{Zweige\index{Zweig}} des
\texttt{cond}-Ausdruckes, und der Zweig mit \texttt{else}  heißt
\textit{\texttt{else}-Zweig\index{else-Zweig@\texttt{else}-Zweig}}.
Der \texttt{else}-Zweig kann auch fehlen~-- dann sollte aber immer
eine der Bedingungen  \texttt{\#t} ergeben.  Wenn doch einmal bei allen
$b_i$ \verb|#f| herauskommen sollte, bricht \drscheme{} das Programm ab
und gibt eine Fehlermeldung aus.
\end{feature}
%
Damit haben wir die komplette Funktionsweise von \texttt{cond}
angewendet. Abbildung~\ref{scheme:cond} fasst sie noch einmal zusammen.

Dann kannst Du auch von vornherein \texttt{else} benutzen, wenn Du Dir
sicher bist, dass alle anderen Fälle schon in den vorigen Zweigen
abgedeckt sind.  Im Zweifelsfall empfehlen wir aber immer den Weg über
die Mathematik, damit die Funktion auch korrekt wird.

A propos korrekt: Ist \texttt{heat-water} korrekt?  Hier ist ein
weiterer Testfall:
%
\begin{verbatim}
(check-expect (heat-water -1 191) 100)
\end{verbatim}
%
Von den 191°C wird 1°C benötigt, um auf 0°C zu kommen, dann weitere
80°C, um über 0°C hinauszukommen, bleiben 110°C.  Aber über 100°C geht
es natürlich trotzdem nicht.  Leider sieht die Funktion das anders:
%
\begin{verbatim}
Check-Fehler:
	Der tatsächliche Wert 110 ist nicht der erwartete Wert 100.
\end{verbatim}
%
Woran liegt das?  Wenn wir die Verzweigungen im Kopf nachvollziehen,
sehen wir, dass zunächst der erste Zweig des äußeren \texttt{cond}
greift, weil die Bedingung \verb|(< temp 0)| als Wert \verb|#t| hat.
Im inneren \texttt{cond} schließlich ergeben die ersten beiden
Bedingungen jeweils \verb|#f|, es bleibt also der \texttt{else}-Zweig,
und addiert die Wärme "`blind"' auf die Anfangstemperatur.

Wir müssen also unser Programm korrigieren, weil dieser Fall noch
nicht berücksichtigt ist: Die Anfangstemperatur ist unter 0°C, die
Erwärmung würde die Temperatur aber über 100°C heben.  Es greift also
der \texttt{else}-Zweig des inneren \texttt{cond} des äußeren Zweigs
mit \texttt{(< temp 0)}, und das ist in diesem Fall falsch.  Die
ersten beiden Zweige sind für Endtemperaturen bis 0°C zuständig, wir
müssen also den neuen Zweig unmittelbar vor dem \texttt{else}-Zweig
einfügen.  Der sieht so aus:
%
\begin{verbatim}
         ; Die Erwärmung würde die Temperatur auf über 100°C bringen
         ((>= (- (+ temp heat) 80) 100) 100)
\end{verbatim}
%
Jetzt ist das Programm endlich fertig und korrekt! Eine Lektion bleibt:
%
\begin{center}
  \emph{Bei komplizierten Fallunterscheidungen, teste gründlich und
    gehe davon aus, dass Du Zweige vergessen hast.}
\end{center}

\section{Datenanalyse}
\label{sec:datenanalyse}

FIXME

\section{Schablonen}
\label{sec:schablonen}

FIXME

Vielleicht ist Dir aufgefallen, dass der erste Schritt nach dem
Gerüst noch gar nicht soviel mit der konkreten Aufgabe zu tun hatte,
sondern nur aus der Einsicht entstand, dass es die Eingaben
eine Fallunterscheidung mit \textit{zwei} Fällen bilden:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      (\ldots \ldots)
      (\ldots \ldots))))
\end{alltt}
%
So ein unfertiges Programm, in dem einige Elemente aus der Analyse der Daten

FIXME: \textit{Schablone}

\section{Aufzählungen}
\label{sec:flensburg}
\label{sec:aufzaehlungen}

Zu den "`Flensburg"'-Punkten, die es bei Verstößen gegen die
Straßenverkehrsordnung gibt, hat eine Seite im Internet folgendes zu
sagen:
%%%% Das ist leider nicht mehr die gültige Version der Punkte! HK
%
\begin{center}
  \begin{tabular}{rl}
    0 bis 3 Punkte& Keine Sanktionen\\
    4 bis 8 Punkte& Bei freiwilliger Teilnahme an Aufbauseminaren: 4 Punkte Abzug\\
    8 bis 13 Punkte& Verwarnung und Hinweis auf freiwilliges Aufbauseminar\\
    9 bis 13 Punkte& Bei freiwilliger Teilnahme an Aufbauseminaren: 2 Punkte Abzug\\
    14 bis 17 Punkte& Teilnahme an Aufbauseminar wird angeordnet\\
    14 bis 17 Punkte&
                      Bei freiwilliger Teilnahme an verkehrspsychologischer Beratung: 2 Punkte Abzug\\
    Ab 18 Punkte&
                  Führerschein wird entzogen
  \end{tabular}
\end{center}
%
Wir können zu dieser Aufstellung eine Reihe von Fragestellungen
bearbeiten, zum Beispiel welche Sanktionen durch eine bestimmte
Punktezahl verpflichtend werden oder wieviele Punkte ein Autofahrer
nach einer bestimmten Maßnahme noch auf dem Konto hat.  In jedem Fall
teilt die Aufstellung mögliche Punktezahlen in bestimmte Kategorien
ein, je nach Maßnahme.  Folgende Maßnahmen gibt es:
%
\begin{itemize}
\item nichts
\item Aufbauseminar
\item verkehrspsychologische Beratung
\item Führerscheinentzug
\end{itemize}
%
Dies ist eine \textit{Aufzählung}\index{Aufzählung}.

Wir fangen mit der Fragestellung an, welche Zwangsmaßnahme für eine
bestimmte Punktezahl angeordnet wird.  Zwangsmaßnahmen gibt es nur
drei: keine, Aufbauseminar und Führerscheinentzug, da die
verkehrspsychologische Beratung rein freiwillig ist.  Entsprechend
zerfällt die Punkteskala in drei Teile: $0-13$, $14-17$ und ab $18$.
Die Punktezahl gehört also zu einer von drei
\textit{Kategorien}\index{Kategorie}.

Wenn die Menge, aus der ein Wert kommt, in eine feste
Anzahl von Kategorien aufgeteilt wird und bei einem Wert nur die
Kategorie zählt, ist diese Menge durch eine \textit{Fallunterscheidung} definiert.
Aufzählungen sind damit auch Fallunterscheidungen.

Eine Funktion, die  aus einem Punktestand die Zwangsmaßnahme ermittelt,
sieht folgendermaßen aus:
%
\begin{displaymath}
  m(p) \deq
  \begin{cases}
    \textit{nichts} & \textrm{falls $p \leq 13$}
    \\
    \textit{Aufbauseminar} & \textrm{falls $p \geq 14, p \leq 17$}
    \\
    \textit{Führerscheinentzug } & \textrm{falls $p \geq 18$}
  \end{cases}
\end{displaymath}
%
Die Notation mit der großen geschweiften Klammer heißt
\textit{Verzweigung\index{Verzweigung}} (engl.\
\textit{conditional\index{conditional}}); ein Ausdruck wie $p\leq 13$,
der wahr oder falsch sein kann,
heißt \textit{Bedingung\index{Bedingung}}.


\section{Programmieren mit Fallunterscheidungen}

Zurück zu den Punkten in Flensburg: Zunächst schreiben wir eine
Funktion, die zu einem gegebenen Punktestand die entsprechende
Zwangsmaßnahme ausrechnet.  Fast alles, was zur Datenanalyse gehört,
haben wir schon am Anfang des Kapitels gemacht: der Punktestand ist
eine natürliche Zahl, eine Zwangsmaßnahme ist nichts, ein
Aufbauseminar oder der Führerscheinentzug.  Diese Informationen müssen
wir noch in Daten umwandeln~-- dazu benutzen wir einfach die
entsprechenden Zeichenketten \verb|"nichts"|, \verb|"Aufbauseminar"|
und \verb|"Führerscheinentzug"| und halten das Ergebnis in einem
Kommentar fest:
%
\begin{alltt}
; Eine Zwangsmaßnahme ist einer der folgenden Werte:
; - "nichts"
; - "Aufbauseminar"
; - "Führerscheinentzug"
\end{alltt}
%
FIXME: Signatur benamsen, nach Motivation
%
Die Kurzbeschreibung der Funktion könnte so aussehen:
%
\begin{alltt}
; Zwangsmaßnahme bei Flensburg-Punktestand errechnen
\end{alltt}
%
Eine passende Signatur ist diese
hier:\index{points-must-do@\texttt{points-must-do}}\label{page:points-must-do}
%
\begin{alltt}
(: points-must-do (natural -> (one-of "nichts"
                                      "Aufbauseminar"
                                      "Führerscheinentzug")))
\end{alltt}
%
Die Konstruktion \texttt{one-of}\index{one-of@\texttt{one-of}}
bei Signaturen ist neu: In der obigen
Signatur bedeutet es, dass der Aggregatzustand einer der in der
\texttt{one-of}-Signatur angegegebenen Werte ist, also eine der
Zeichenketten \verb|"nichts"|, \verb|"Aufbauseminar"| und \verb|"Führerscheinentzug"|.

Hier sind zwei mögliche Testfälle:
%
\begin{alltt}
(check-expect (points-must-do 14) "Aufbauseminar")
(check-expect (points-must-do 18) "Führerscheinentzug")
\end{alltt}   
%
Es folgt das Gerüst der Funktion:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    ...))
\end{alltt}
%
Auf jeden Fall muß das \texttt{p} irgendwo im Rumpf vorkommen:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    ... p ...))
\end{alltt}
%
%
Jetzt brauchen wir, wie bei der mathematischen Funktion $m$ aus
Abschnitt~\ref{sec:fallunterscheidungen}, eine Verzweigung, nur eben
in den Lehrsprachen.  Abbildung~\ref{scheme:cond} beschreibt das dafür
zuständige \texttt{cond}.   Es ist also von vorneherein klar, dass eine
\texttt{cond}-Form im Rumpf von \texttt{points-must-do} auftauchen muss:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond ... p ...)))
\end{alltt}
%
Bei der Konstruktion der \texttt{cond}-Formen ist entscheidend,
wieviele Zweige sie hat.  Dabei gibt es eine einfache Faustregel~-- da
die Eingabe von \texttt{points-must-do}~-- die Punktzahl~-- in
\emph{drei} Kategorien zerfällt, braucht die \texttt{cond}-Form auch
\emph{drei} Zweige:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond
      (... ...)
      (... ...)
      (... ...))))
\end{alltt}
%
Wir benötigen jetzt für jeden \texttt{cond}-Zweig eine Bedingung, der die
entsprechende Kategorie bei den Punkten identifiziert.  Dazu müssen
wir nur die entsprechenden Bedingungen aus der mathematischen Fassung
in einen Funktionsrumpf übersetzen.  Heraus kommt folgendes:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond
      ((<= p 13) ...)
      ((and (>= p 14) (<= p 17)) ...)
      ((>= p 18) ...))))
\end{alltt}
%
Der letzte Schritt ist einfach~-- wir fügen für jeden Zweig die zur
Bedingung passende Maßnahme ein:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond
      ((<= p 13) "nichts")
      ((and (>= p 14) (<= p 17)) "Aufbauseminar")
      ((>= p 18) "Führerscheinentzug"))))
\end{alltt}
%
Fertig~-- könnte man meinen.  Wenn Du das Programm in der REPL laufen lässt,
meldet DrRacket zwei bestandene Tests.  Allerdings fällt Ihnen
vielleicht auf, dass das Programm im Definitionsfenster nach dem Lauf
so aussieht:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond
      ((<= p 13) \colorbox{featuregray}{"nichts"})
      ((and (>= p 14) (<= p 17)) "Aufbauseminar")
      ((>= p 18) "Führerscheinentzug"))))
\end{alltt}
%
Das \verb|"nichts"| ist farbig unterlegt, weil DrRacket diesen
Ausdruck noch nie ausgewertet hat.  Das ist nicht gut, weil es heißt,
dass der entsprechende Zweig durch die Bedingungen noch nicht strapaziert
wurde~-- er ist also möglicherweise fehlerhaft.  Anders gesagt: Die
\textit{Abdeckung}\index{Abdeckung} des Programms durch die Bedingungen ist
unvollständig.  Wenn wir einen Testfall für den ersten Zweig ergänzen,
verschwindet die farbige Unterlegung:
%
\begin{alltt}
(check-expect (points-must-do 0) "nichts")
\end{alltt}
%
Trotzdem sind die bestehenden Tests noch suboptimal~-- wer sagt
schließlich, dass das Programm zum Beispiel bei 13 Punkten, also genau
an der Grenze zwischen dem ersten und zweiten Zweig, das richtige tut.
Wir sollten für diese Eckfälle\index{Eckfall} auch Testfälle
bereitstellen sowie einen Testfall, der sicherstellt, dass auch bei
Punktzahlen oberhalb von 18 immer noch der Führerschein entzogen wird:
%
\begin{alltt}
(check-expect (points-must-do 13) "nichts")
(check-expect (points-must-do 17) "Aufbauseminar")
(check-expect (points-must-do 100) "Führerscheinentzug")
\end{alltt}

\begin{mantra}[Abdeckung und Eckfälle]\label{mantra:coverage}
  \input{mantra:coverage}
\end{mantra}

\section{Konstruktionsanleitung für Fallunterscheidungen}

Bei der Konstruktion der Funktion \texttt{points-must-do} haben wir
ein bestimmtes Schema angewendet.  Dieses Schema geht zunächst von folgender
Frage aus:
%
\begin{quote}
  \emph{Wieviele} Kategorien gibt es bei der Fallunterscheidung?
\end{quote}
%
Ist die Frage beantwortet~-- durch eine Zahl $n$~-- können wir bereits
etwas Code in den Rumpf schreiben, nämlich eine Verzweigung mit $n$
Zweigen:
%
\begin{alltt}
(define \(p\)
  (lambda (\ldots)
    (cond
      (... ...)
      \ldots{}\hspace{1in}\textrm{(\(n\) Zweige)}
      (... ...))))
\end{alltt}
%
Solch ein "`Rumpf mit Lücken"' (die Ellipsen\index{Ellipse}
\texttt{\ldots} stehen für noch zu ergänzende Programmteile) ist eine
\textit{Schablone\index{Schablone}}.  Wir, die Autoren, empfehlen
Ihnen, die Schablone bereits hinzuschreiben, wenn Du die Anzahl der
Kategorien bereits kennst, noch bevor Du weiter über die
Problemstellung nachdenkst.  Das hilft oft, etwaige Denkblockaden zu
lösen.

Die Schablone folgt in diesem Fall aus der Struktur der Daten, also
dem Ergebnis der Datenanalyse.  Es gibt noch andere Arten von Daten,
jede mit ihrer eigenen Schablone.  Diese werden wir im Rest des Buchs
entwickeln.
Für alle folgenden Konstruktionsanleitungen gilt deshalb folgendes Mantra:

\begin{mantra}[Schablone]\label{mantra:data-analysis}
  \input{mantra:data-analysis}
\end{mantra}

Was die Fallunterscheidung betrifft, können wir die Schablone aber
noch weiterentwickeln, indem wir Tests für die einzelnen Fälle der
Fallunterscheidung ergänzen.

Die Schablone für Fallunterscheidungen ist noch einmal
als Konstruktionsanleitung~\ref{ka:fallunterscheidung} in
Anhang~\ref{app:konstruktionsanleitungen} zusammengefasst.
(Konstruktionsanleitung~\ref{ka:allgemein} beschreibt die Konstruktion
von Funktionen im allgemeinen.)

\section{Verkürzte Bedingungen}

Natürlich könnten wir die Funktion auch leicht abkürzen:
%
\begin{alltt}
(define points-must-do
  (lambda (p)
    (cond
      ((<= p 13) "nichts")
      ((<= p 17) "Aufbauseminar")
      (else "Führerscheinentzug"))))
\end{alltt}
%
Wenn die Auswertung den Bedingungen im zweiten Zweig erreicht, steht schon
fest, dass die Punktezahl $\geq 14$ ist, da die Bedingung \verb|(<= p 13)|
fehlgeschlagen ist.  Diese Bedingung könnten wir also weglassen.
Ebenso die letzte Bedingung, die dadurch, dass \verb|(<= p 17)| \verb|#f|
ergeben hat, immer \verb|#t| ergibt.  Allerdings sind die Zweige damit
von ihrer Reihenfolge abhängig: Wenn wir zum Beispiel die ersten
beiden Zweige vertauschten, funktioniert die Funktion nicht mehr
richtig.  In Fällen wie diesen, wo "`vollständige"' Bedingungen einfach zu
formulieren sind, empfiehlt es sich, dies auch zu tun.

\begin{mantra}[Vollständige Bedingungen]\label{mantra:comprehensive-tests}
  \input{mantra:comprehensive-tests}
\end{mantra}

\section{Binäre Verzweigungen und syntaktischer Zucker}
\label{sec:binaere-verzweigungen}

Bei manchen Fallunterscheidungen definiert sich die letzte Kategorie
dadurch, dass ein Wert in keine der anderen Kategorien gehört.  Dann
ist die Benutzung eines \texttt{else}-Zweigs im \texttt{cond}
sinnvoll.
FIXME: Beispiel wäre schön, dann vielleicht früher.  
Manchmal gibt es dabei nur zwei Kategorien, wie
zum Beispiel beim Absolutbetrag.  Hier die Definition dazu in mathematischer
Schreibweise:
%
\begin{displaymath}
  |x| \deq{} \left\{\begin{array}{rl}
      x & \textrm{falls } x \geq 0\\
      -x & \textrm{andernfalls}
    \end{array}
    \right.
\end{displaymath}
%
Die dazu passende Programm-Funktion unter Verwendung von \texttt{cond}
sieht so aus:\index{abs@\texttt{abs}}
%
\begin{alltt}
; Absolutbetrag einer Zahl berechnen
(: absolute (number -> number))
(define absolute
  (lambda (x)
    (cond
     ((>= x 0) x)
     (else (- x)))))
\end{alltt}
FIXME: besseres Beispiel

%
Dieser Spezialfall mit nur zwei Kategorien, genannt \textit{binäre
  Verzweigung\index{binäre Verzweigung}\index{Verzweigung!binär}} kommt in der Praxis
häufig vor.  In den Lehrsprachen gibt es dafür eine eigene Spezialform,
genannt \texttt{if\index{if@\texttt{if}}}, die hier kürzer ausfällt
als \texttt{cond}:
%
\begin{alltt}
(define absolute
  (lambda (x)
    (if (>= x 0)
        x
        (- x))))
\end{alltt}
%
Eine \texttt{if}-Form hat folgende Form:
%
\begin{alltt}
(if \(t\) \(k\) \(a\))
\end{alltt}
Dabei ist $t$ die Bedingung und $k$ und $a$ sind die
beiden Zweige: die \textit{Konsequente\index{Konsequente}} $k$ und die
\textit{Alternative\index{Alternative}} $a$.  Abhängig vom Ausgang der
Bedingung ist der Wert der Verzweigung entweder der Wert der Konsequente
oder der Wert der Alternative.

Tatsächlich ist \texttt{if} die "`primitivere"' Form als
\texttt{cond}: jede \texttt{cond}-Form kann in eine äquivalente
\texttt{if}-Form übersetzt werden, und zwar nach
folgendem Schema:
%
\begin{alltt}
(cond (\(t\sb{1}\) \(a\sb{1}\)) (\(t\sb{2}\) \(a\sb{2}\)) \(\ldots\) (\(t\sb{n-1}\) \(a\sb{n-1}\)) (else \(a\sb{n}\)))
  \(\mapsto\) (if \(t\sb{1}\) \(a\sb{1}\) (if \(t\sb{2}\) \(a\sb{2}\) \ldots (if \(t\sb{n-1}\) \(a\sb{n-1}\) \(a\sb{n}\))\ldots))
\end{alltt}
%
Die geschachtelte \texttt{if}-Form auf der rechten Seite der
Übersetzung wertet, genau wie die \texttt{cond}-Form, nacheinander
alle Bedingungen aus, bis eine \verb|#t| liefert.  Die rechte Seite des
\texttt{cond}-Zweigs ist dann gerade die Konsequente des \texttt{if}s.
Erst wenn alle Bedingungen fehlschlagen ist die Alternative des letzten
\texttt{if}-Ausdrucks dran, nämlich $a_n$ aus dem \texttt{else}-Zweig.

Da sich mit Hilfe dieser Übersetzung jede \texttt{cond}-Form durch
geschachtelte \texttt{if}-Formen ersetzen lässt, ist \texttt{cond}
streng genommen gar nicht notwendig.  \texttt{Cond} ist deswegen eine
sogenannte \textit{abgeleitete Form\index{abgeleitete
    Form}}\index{Form!abgeleitet}.  Da \texttt{cond} und andere
abgeleitete Formen trotzdem praktisch und angenehm zu verwenden sind
und damit dem Programmierer die Arbeit versüßen,
heißen abgeleitete Formen auch \textit{syntaktischer
  Zucker\index{syntaktischer Zucker}\index{Zucker, syntaktischer}}.

Um die Funktionsweise von Verzweigungen genau zu beschreiben, dient
folgende zusätzliche Regel für das Substitutionsmodell aus
Abschnitt~\ref{sec:substitution-model}:
%
\begin{description}
\item[binäre Verzweigungen] Bei der Auswertung einer Verzweigung wird
  zunächst der Wert der Bedingung festgestellt.  Ist dieser Wert \verb|#t|,
  so ist der Wert der Verzweigung der Wert der Konsequente.  Ist er
  \verb|#f|, so ist der Wert der Verzweigung der Wert der
  Alternative.  Ist der Wert der Bedingung  kein boolescher Wert ist, ist das Programm fehlerhaft.
\end{description}
%
Auch \texttt{and} und \texttt{or} sind eigentlich syntaktischer Zucker:
Es ist immer möglich, einen \texttt{and}-Ausdruck in \texttt{if}s
zu übersetzen.  Es gelten folgende Übersetzungsregeln:
%
\begin{alltt}
(and) \(\mapsto\) #t
(and \(e\sb{1}\) \(e\sb{2}\) \(\ldots\)) \(\mapsto\) (if \(e\sb{1}\) (and \(e\sb{2}\) \(\ldots\)) #f)
\end{alltt}
%
Ein \texttt{and}-Ausdruck mit mehreren Operanden wird so schrittweise
in eine Kaskade von \texttt{if}-Ausdrücken übersetzt:
%
\begin{alltt}
(and a b c)
\(\mapsto{}\) (if a (and b c) #f)
\(\mapsto{}\) (if a (if b (and c) #f) #f)
\(\mapsto{}\) (if a (if b (if c (and) #f) #f) #f)
\(\mapsto{}\) (if a (if b (if c #t #f) #f) #f)
\end{alltt}
%
Ebenso lassen sich \texttt{or}-Ausdrücke immer in
\texttt{if}-Ausdrücke übersetzen, und zwar mit folgender Übersetzung:
%
\begin{alltt}
(or) \(\mapsto\) #f
(or \(e\sb{1}\) \(e\sb{2}\) \(\ldots\)) \(\mapsto\) (if \(e\sb{1}\) #t (or \(e\sb{2}\) \(\ldots\)))
\end{alltt}
%
Beispiel:
%
\begin{alltt}
(or a b c)
\(\mapsto{}\) (if a #t (or b c))
\(\mapsto{}\) (if a #t (if b #t (or c)))
\(\mapsto{}\) (if a #t (if b #t (if c #t (or))))
\(\mapsto{}\) (if a #t (if b #t (if c #t #f)))
\end{alltt}

\section{Signaturdefinitionen}

Nehmen wir uns zu Übungszwecken noch eine weitere Aufgabe vor: Nehmen
wir an, jemand nimmt bei einem bestimmten Punktestand in Flensburg an
einer freiwilligen Maßnahme teil~-- was ist der Punktestand nach der
Maßnahme?  Die bekannten Größen sind:
%
\begin{itemize}
\item Punktestand vor der Maßnahme (natürliche Zahl)
\item freiwillige Maßnahme (siehe Abschnitt~\ref{sec:flensburg})
\end{itemize}
%
Die unbekannte Größe ist der Punktestand nach der Maßnahme.

Die Kurzbeschreibung könnte so lauten:
%
\begin{verbatim}
; Punktestand in Flensburg senken
\end{verbatim}
%
Die Signatur folgt aus der Datenanalyse:\index{improve-points@\texttt{improve-points}}
%
\begin{verbatim}
(: improve-points (natural (one-of "nichts"
                                   "Aufbauseminar"
                                   "verkehrspsychologische Beratung"
                                   "Führerscheinentzug")
                    -> natural))
\end{verbatim}
%
Der \texttt{one-of}-Teil der Signatur macht sich da ganz schön breit,
zumal er sich weitgehend deckt mit dem entsprechenden Teil der
Signatur von \texttt{points-must-do} auf
Seite~\pageref{page:points-must-do}.  Entsprechend sollten wir genauso
wie bei anderen Werten der Signatur für "`Flensburg"=Maßnahmen"' einen
Namen geben.  Das geht mit einer fast ganz normalen Definition:\index{Signaturdefinition}
%
\begin{verbatim}
(define action
  (signature
   (one-of "nichts"
           "Aufbauseminar"
           "verkehrspsychologische Beratung"
           "Führerscheinentzug")))
\end{verbatim}
%
Das Wörtchen \texttt{signature}\index{signature@texttt{signature}}\label{page:signature} ist aus technischen Gründen
nötig.\footnote{Es sorgt unter anderem dafür, dass Signaturdefinitionen
  in beliebiger Reihenfolge geschrieben werden und die Links in den
  Fehlermeldungen von DrRacket auf die richtige Stelle zeigen.}
Faustregel: Signaturen außerhalb von Formen \texttt{(: \ldots)} müssen immer in ein \texttt{(signature
  \ldots)} eingeschachtelt werden..

Mit dieser Definition gewappnet können wir die Signatur abkürzen:
%
\begin{verbatim}
(: improve-points (natural action -> natural)) 
\end{verbatim}
%
Entsprechend Mantra~\ref{mantra:coverage} versuchen wir, durch mehr
Tests als noch bei \texttt{points-must-do} bessere Abdeckung zu
erzielen:\label{page:improve-points-tests}
%
\begin{verbatim}
(check-expect (improve-points 3 "Aufbauseminar") 3)
(check-expect (improve-points 4 "nichts") 4)
(check-expect (improve-points 4 "Aufbauseminar") 0)
(check-expect (improve-points 8 "Aufbauseminar") 4)
(check-expect (improve-points 9 "Aufbauseminar") 7)
(check-expect (improve-points 13 "Aufbauseminar") 11)
(check-expect (improve-points 14 "verkehrspsychologische Beratung") 12)
(check-expect (improve-points 17 "verkehrspsychologische Beratung") 15)
(check-expect (improve-points 18 "Aufbauseminar") 18)
(check-expect (improve-points 18 "verkehrspsychologische Beratung") 18)
\end{verbatim}
%
Hier das Gerüst:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    ...))
\end{verbatim}
%
Bei der Konstruktion der Schablone müssen wir uns entscheiden, an
welchem Parameter wir uns orientieren, \texttt{p} oder \texttt{a}.
Die Entscheidung ist willkürlich~-- wir entscheiden uns erst einmal
für \texttt{p}.  (Ausgehend von \texttt{a} kommt eine andere aber
genauso gute Lösung heraus~-- das sei Ihnen in
Aufgabe~\ref{aufgabe:improve-points-a} als Fingerübung empfohlen.)
Bei \texttt{p} gibt es in Bezug auf diese Aufgabe fünf Kategorien:
%
\begin{description}
\item[0--3 Punkte] Da bringt keine Maßnahme etwas.
\item[4--8 Punkte] Da bringt ein Aufbauseminar 4 Punkte Abzug.
\item[9--13 Punkte] Da bringt ein Aufbauseminar 2 Punkte Abzug.
\item[14--17 Punkte] Da bringt eine verkehrspsychologische Beratung 2
  Punkte Abzug.
\item[über 18 Punkte] Auch hier hilft keine Maßnahme.
\end{description}
%
Wir brauchen also ein \texttt{cond} mit fünf Zweigen:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    (cond
      (... ...)
      (... ...)
      (... ...)
      (... ...)
      (... ...))))
\end{verbatim}
%
Jetzt müssen wir Bedingungen erfinden, die den Kategorien entsprechen:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    (cond
      ((<= p 3) ...)
      ((and (>= p 4) (<= p 8)) ...)
      ((and (>= p 9) (<= p 13)) ...)
      ((and (>= p 14) (<= p 17)) ...)
      ((>= p 18) ...))))
\end{verbatim}
%
Wir fangen mal mit den einfachsten Fällen an~-- unten und oben in der
Punkteskala, wo sich nichts bewegt:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    (cond
      ((<= p 3) p)
      ((and (>= p 4) (<= p 8)) ...)
      ((and (>= p 9) (<= p 13)) ...)
      ((and (>= p 14) (<= p 17)) ...)
      ((>= p 18) p))))
\end{verbatim}
%
Im zweiten Zweig~-- zwischen vier und acht Punkten~-- zählt nur ein
Aufbauseminar, alle anderen Maßnahmen bringen nichts.  Darum ist hier
eine binäre Verzweigung angemessen:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    (cond
      ...
      ((and (>= p 4) (<= p 8))
       (if (string=? a "Aufbauseminar")
           (- p 4)
           p))
      ...)))
\end{verbatim}
%
Entsprechend funktionieren auch der dritte und der vierte Zweig:
%
\begin{verbatim}
(define improve-points
  (lambda (p a)
    (cond
      ((<= p 3) p)
      ((and (>= p 4) (<= p 8))
       (if (string=? a "Aufbauseminar")
           (- p 4)
           p))
      ((and (>= p 9) (<= p 13))
       (if (string=? a "Aufbauseminar")
           (- p 2)
           p))
      ((and (>= p 14) (<= p 17))
       (if (string=? a "verkehrspsychologische Beratung")
           (- p 2)
           p))
      ((>= p 18) p))))
\end{verbatim}
%
Fertig!  Es gibt trotzdem noch einen Wermutstropfen: Die Abdeckung ist
trotz der vielen Tests immer noch nicht vollständig~-- siehe
Aufgabe~\ref{aufgabe:improve-points-coverage}

\section{Unsinnige Daten abfangen}
\label{sec:nonsensical-data}

Noch einmal zurück zum Parkplatzproblem, das wir auf
Seite~\ref{page:parking-lot-cars} programmiert hatten.  In
Abschnitt~\ref{sec:nonsensical-data-prequel} auf
Seite~\pageref{sec:nonsensical-data-prequel} hatten wir bereits
bemerkt, dass die Funktion
\texttt{parking-lot-cars}\index{parking-lot-cars@\texttt{parking-lot-cars}}
auch für unsinnige Daten fröhlich ebenso unsinnige Ergebnisse
ermittelt.

Auf Seite~\ref{page:parking-lot-problem} wurde bereits eine Bedingung
für sinnvolle Daten formuliert: Wenn $n$ die Anzahl der Fahrzeuge und
$m$ die Anzahl der Räder ist, dann muss $m$ gerade sein sowie $2n\leq
m\leq 4n$ gelten.  Wir können das in einer binären Verzweigung zum
Ausdruck bringen:
%
\begin{verbatim}
(define parking-lot-cars
  (lambda (vehicle-count wheel-count)
    (if (and (even? wheel-count)
             (<= (* 2 vehicle-count) wheel-count)
             (<= wheel-count (* 4 vehicle-count)))
        (/ (- wheel-count (* 2 vehicle-count))
           2)
        ...)))
\end{verbatim}
%
Die eingebaute Funktion \texttt{even?} akzeptiert eine ganze Zahl und
liefert \verb|#t|, falls die Zahl gerade ist und \verb|#f|, falls sie
ungerade ist~-- solche und viele andere nützliche Funktionen finden
Du in der Dokumentation im Hilfezentrum unter "`Sprachebenen und
Material zu \textit{Schreibe Dein Programm!}"' im Abschnitt
"`Primitive Operationen"'.

Nur~-- was tun im Fehlerfall?  Dazu gibt eine eingebaute Funktion
\texttt{violation}, die eine Fehlermeldung als Zeichenkette akzeptiert
und, wenn sie aufgerufen wird, das Programm abbricht und die
Fehlermeldung ausdruckt.  \texttt{Parking-lot-cars} sieht dann
vollständig so aus:
%
\begin{verbatim}
(define parking-lot-cars
  (lambda (vehicle-count wheel-count)
    (if (and (even? wheel-count)
             (<= (* 2 vehicle-count) wheel-count)
             (<= wheel-count (* 4 vehicle-count)))
        (/ (- wheel-count (* 2 vehicle-count))
           2)
        (violation "unsinnige Daten"))))
\end{verbatim}
%
Natürlich sollten wir auch den Fehlerfall testen~-- das geht nicht mit
\texttt{check-expect}, das ja erwartet, dass ein Testausdruck einen
ordnungsgemäßen Wert liefert.  Für Fehlerfälle gibt es
\texttt{check-error}, das Testfälle erzeugt, die dann bestanden sind,
wenn die Auswertung einen Fehler liefert:
%
\begin{verbatim}
(check-error (parking-lot-cars 10 10)) ; zu wenige Räder
(check-error (parking-lot-cars 3 9))   ; ungerade Räderzahl
(check-error (parking-lot-cars 2 10))  ; zu viele Räder
\end{verbatim}

\section*{Aufgaben}

\begin{aufgabe}
  Schreibe eine Funktion \texttt{card-type}, die den Umsatz einer
  Kreditkarte konsumiert und die eine entsprechende Kategorie als
  Zeichenkette zurückgibt.  Verwende die Konstruktionsanleitungen:
  Schreibe die Kurzbeschreibung auf, führe eine
  Datenanalyse durch und schreibe die Signatur auf. Erstelle
  dann die Testfälle und das Gerüst.  Vervollständige danach den
  Rumpf der Funktion und vergewissere Dich, dass die Tests
  erfolgreich laufen. \\

  \begin{tabular}{crlcrll}
    &        & Umsatz & $<$ & $15.000$   & $\Longrightarrow$ & Weiß \\
    $15.000$  & $\leq$ & Umsatz & $<$ & $50.000 $  & $\Longrightarrow$ & Gold \\
    $50.000$  & $\leq$ & Umsatz & $\leq$ & $150.000 $ 
    & $\Longrightarrow$ & Platin \\
    $150.000$ & $<$ & Umsatz &     &            &  $\Longrightarrow$ & Schwarz \\
  \end{tabular} \\
\end{aufgabe}

\begin{aufgabe}

  \begin{enumerate}

  \item Schreibe eine Funktion \texttt{min-2}, die als Argumente zwei
    Zahlen nimmt und die kleinere der beiden Zahlen zurückgibt.  Schreibe
    außerdem eine Funktion \texttt{min-3}, die als Argumente drei
    Zahlen nimmt und die kleinste der drei Zahlen zurückgibt.  Verwende
    die Konstruktionsanleitung: Schreibe
    explizit Kurzbeschreibung und Signatur auf, erstelle dann das
    Gerüst und die Testfälle.  Vervollständige danach den Rumpf der
    Funktion und vergewissere Dich, dass die Tests erfolgreich laufen.
    
  \item Schreibe analog eine Funktion \texttt{max-2} und \texttt{max-3}.
    
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Schreibe die folgenden Funktionen:
  \begin{enumerate}
  \item \texttt{min-of-two}, welche die kleinste von zwei
    gegebenen Zahlen ausgibt
  \item \texttt{min-of-three}, welche die kleinste von drei
    gegebenen Zahlen ausgibt
  \item \texttt{is-min-of-three?}, die überprüft ob die erste
    von drei gegebenen Zahlen das Minimum ist
  \item \texttt{valid-value?}, die überprüft ob die erste von
    drei gegebenen Zahlen zwischen den beiden anderen liegt; gehe
    davon aus, dass der Aufruf immer \texttt{(valid-value? value min max)}
    lautet 
  \item \texttt{clamp}, die wie folgt definiert ist:
    
    \[\text{clamp}(x,\ min,\ max)=
    \begin{cases} 
      x & min \leq x \leq max\\ 
      min & x < min \\ 
      max & x > max 
    \end{cases}
    \]
    
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  FIXME Spielerin
  
  Beim Fußball lässt die Rückennummer eines Spielers
  häufig Rückschlüsse auf seine Position zu. Wir machen dabei folgende
  Annahmen:
  \begin{itemize}
  \item Ein \emph{Torwart} hat die Rückennummer 1.
  \item Ein \emph{Abwehrspieler} hat die Rückennummer 2, 3, 4 oder 5.
  \item Ein \emph{Mittelfeldspieler} hat die Rückennummer 6, 7, 8 oder 10.
  \item Ein \emph{Stürmer} hat die Rückennummer 9 oder 11.
  \item Ein \emph{Ersatzspieler} hat eine Rückennummer zwischen 12 und 99.
  \item Alle anderen Rückennummern sind ungültig.
  \end{itemize}
 
  Schreibe nun eine Funktion mit folgender Signatur:
  
  {\small
\begin{verbatim}
 (: nummer->position
    (number ->
      (one-of "Torwart" "Abwehr" "Mittelfeld" "Sturm" "Ersatz" "Ungültig")))
\end{verbatim}
  }

  Die Funktion soll dabei zu einer gegebenen Rückennummer die
  zugehörige Position berechnen.

  Verwende beim Schreiben der Funktion die
  Konstruktionsanleitungen für Funktionen und für
  Fallunterscheidungen.  Teste die Funktion
  \texttt{nummer->position} mit mindestens sechs Testfällen, so dass
  alle Fälle abgedeckt sind.
\end{aufgabe}


\begin{aufgabe}
  Schreibe ein Programm, mit dem Bußgelder
  automatisch bestimmt werden.
  
  \begin{enumerate}
  \item Programmiere eine Funktion \texttt{zu-langes-parken}
    für die Bewertung von zu langem Parken auf einem kostenpflichtigen
    Parkplatz. Diese bekommt eine Zeitspanne übergeben und gibt das 
    entsprechende Verwarngeld zurück.
    
    Diese Verwarnungen sind wie folgt festgelegt:
    \begin{itemize}
    \item Überschreitung der Höchstparkdauer bis 30 Minuten: \euro{5}
    \item bis zu einer Stunde: \euro{10}
    \item bis zu zwei Stunden: \euro{15}
    \item bis zu drei Stunden: \euro{20}
    \item länger als drei Stunden:  \euro{25}
    \end{itemize}
    
  \item Das Überfahren einer roten Ampel kostet je nach
    Gefährdungslage mehr, gibt Punkte und Fahrverbote. Schreibe
    zwei Funktionen, eine für das Bußgeld \texttt{rote-ampel-bußgeld}, 
    eine für die Punkte in Flensburg \texttt{rote-ampel-punkte} 
    und eine für das Fahrverbot \texttt{rote-ampel-fahrverbot}, 
    welche ausgibt, ob ein Fahrverbot erteilt wird. Übergib
    den Funktionen, wie lange die Ampel schon rot war und ob eine
    Gefährdung oder Sachbeschädigung vorlag.
    
    Die Bußgelder sind wie folgend definiert:
    \begin{itemize}
    \item Bei Rot über die Ampel innerhalb der ersten Sekunde			
      \euro{50} und 3 Punkte.
    \item Bei Rot über die Ampel innerhalb der ersten Sekunde mit
      Gefährdung oder Sachbeschädigung \euro{125}, 4 		
      Punkte und 1 Monat Fahrverbot.
    \item Bei Rot über die Ampel nach der ersten Sekunde \euro{125},
      4 Punkte und 1 Monat Fahrverbot.
    \item Bei Rot über die Ampel nach der ersten Sekunde mit
      Gefährdung oder Sachbeschädigung \euro{200}, 4
      Punkte und 1 Monat Fahrverbot.
    \end{itemize}
    
    
  \end{enumerate}
\end{aufgabe}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
