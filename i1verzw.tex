% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Fallunterscheidungen und Verzweigungen}
\label{cha:conditionals}

Computerprogramme müssen bei manchen Daten, die sie
verarbeiten, zwischen verschiedenen Möglichkeiten differenzieren: Ist
die Wassertemperatur warm genug zum Baden?  Welche von fünf
Tupperschüsseln ist für eine bestimmte Menge Kartoffelsalat groß
genug?  Welches ist die richtige Abzweigung nach Dortmund?  Solche
Entscheidungen sind daran festgemacht, dass ein Wert zu einer von mehreren
verschiedenen 
Kategorien gehören kann~-- es handelt sich dann um eine sogenannte
\textit{Fallunterscheidung\index{Fallunterscheidung}}; 
mathematische Funktionen und Programm-Funktionen operieren auf Daten mit
Fallunterscheidung durch \textit{Verzweigungen\index{Verzweigung}}.
Um diese geht es in diesem Kapitel.

In diesem Kapitel werden wir zunächst zwei besonders einfache Arten
von Fallunterscheidungen behandeln, nämlich \textit{Aufzählungen} und
\textit{Zahlenbereiche}.  In Kapitel~\ref{cha:gemischte-daten} werden
wir die Fallunterscheidungen noch einmal aufgreifen und mit
sogenannten \textit{gemischten Daten} programmieren.

\section{Rechnen mit booleschen Werten}

Für die Programme dieses Kapitels benötigen wir eine neue Art von
Daten.  Die ergeben sich, wenn wir zum Beispiel zwei Zahlen
vergleichen:
%
\begin{alltt}
(< 0 5)
\evalsto{} #t
\end{alltt}
%
\texttt{(< 0 5)} ist die Schreibweise für $0 < 5$.  Das
\verb|#t| steht für "<true\index{true}"> oder "<wahr\index{wahr}">,
denn die Aussage "<ist 0 kleiner als 5"> stimmt ja.
Umgekehrt kommt natürlich nicht \verb|#t| heraus:
%
\begin{alltt}
(< 5 0)
\evalsto{} #f
\end{alltt}
%
Das \verb|#f| steht für "<false\index{false}"> oder
"<falsch\index{falsch}">, denn diese Aussage stimmt nicht.

"<Wahr"> und "<falsch"> heißen zusammen \textit{boolesche
  Werte\index{boolescher Wert}} oder auch
\textit{Wahrheitswerte\index{Wahrheitswert}}.\footnote{Die booleschen
  Werte sind benannt nach \textit{George Boole} (1815--1864), der als
  erster einen algebraischen Ansatz für die Behandlung von Logik mit
  den Werten "<wahr"> und "<falsch"> formulierte.}  Ein Ausdruck, bei
dem ein boolescher Wert herauskommt, heißt dementsprechend auch
\textit{boolescher Ausdruck\index{boolescher Ausdruck}}.

Wir werden boolesche Ausdrücke oft
\textit{Bedingungen\index{Bedingung}} nennen.  Wenn eine Bedingung
\verb|#t| liefert, werden wir auch die Sprachregelung benutzen, dass
die Bedingung \textit{gilt}~-- beziehungsweise, dass, wenn sie
\verb|#f| liefert, sie \textit{nicht gilt}.

\texttt{<}\index{<@\texttt{<}} ist eine eingebaute Funktion, die
auf "<kleiner als"> testet, also dem mathematischen Operator $<$
entspricht.  Ebenso gibt es auch \texttt{>}\index{>@\texttt{>}} für
"<größer als"> (Mathematik: $>$), \texttt{=}\index{=@\texttt{=}} für
"<gleich"> (Mathematik: $=$), \texttt{<=}\index{<@\texttt{<=}} für "<kleiner oder
gleich"> (Mathematik: $\leq$) und \texttt{>=}\index{>=@\texttt{>=}}
für "<größer oder gleich"> (Mathematik: $\geq$).

Analog zu \texttt{=} für Zahlen können Zeichenketten mit
\texttt{string=?}\index{string=?@\texttt{string=?}} verglichen werden:
\begin{alltt}
(string=? "Mike" "Mike")
\evalsto{} #t
(string=? "Herbert" "Mike")
\evalsto{} #f
\end{alltt}
%
\verb|#t| und \verb|#f| sind wie Zahlen Literale, können also
auch in Programmen stehen:
%
\begin{alltt}
#t
\evalsto{} #t
#f
\evalsto{} #f
\end{alltt}
%
Programme können mit booleschen Werten auch rechnen.  Ein Ausdruck der
Form\index{and@\texttt{and}}
%
\begin{alltt}
(and \(e\sb{1}\) \(e\sb{2}\) \(\ldots\) \(e\sb{n}\))
\end{alltt}
%
ergibt immer dann \verb|#t|, wenn alle $e_i$ \verb|#t| ergeben, sonst
\verb|#f|.  Bei zwei Operanden $e_1$ und $e_2$ ergibt \texttt{(and
  $e_1$ $e_2$)} immer dann \verb|#t|, wenn $e_1$ \emph{und} $e_2$
\verb|#t| ergeben:\label{page:and}
%
\begin{alltt}
(and #t #t)
\evalsto{} #t
(and #f #t)
\evalsto{} #f
(and #t #f)
\evalsto{} #f
(and #f #f)
\evalsto{} #f
\end{alltt}
%
Entsprechend gibt es Ausdrücke der Form\index{or@\texttt{or}}
%
\begin{alltt}
(or \(e\sb{1}\) \(e\sb{2}\) \(\ldots\) \(e\sb{n}\))
\end{alltt}
%
die immer dann \verb|#t| ergeben, wenn \emph{einer} der $e_i$ \verb|#t| ergibt, sonst
\verb|#f|.  Bei zwei Operanden $e_1$ und $e_2$ ergibt \texttt{(or
  $e_1$ $e_2$)} immer dann \verb|#t|, wenn $e_1$ \emph{oder} $e_2$
\verb|#t| ergeben:
%
\begin{alltt}
(or #t #t)
\evalsto{} #t
(or #f #t)
\evalsto{} #t
(or #t #f)
\evalsto{} #t
(or #f #f)
\evalsto{} #f
\end{alltt}
%
Das \texttt{or} berechnet also ein \textit{inklusives}
Oder\index{inklusives Oder}: \texttt{(or $e_1$ $e_2$)} bedeutet "<$e_1$ oder
$e_2$ oder beides">, im Gegensatz zum \textit{exklusiven}
Oder\index{exklusives Oder} "<entweder $e_1$ oder
$e_2$">.\footnote{In der Informatik ist mit "<oder"> ohne Zusatz fast
  immer das inklusive Oder gemeint. Wer das exklusive Oder meint, sagt
  auch "<exklusives Oder">.}

Des weiteren gibt es noch eine eingebaute Funktion
\texttt{not}\index{not@\texttt{not}}, die einen booleschen Wert
umdreht beziehungsweise dessen \textit{Negation}\index{Negation}
berechnet, sich also folgendermaßen verhält:
%
\begin{alltt}
(not #f)
\evalsto{} #t
(not #t)
\evalsto{} #f
\end{alltt}
%
Für boolesche Werte gibt es die Signatur
\texttt{boolean}\index{boolean@\texttt{boolean}}.

\begin{aufgabeinline}
  Schreibe eine Funktion, die von zwei booleschen Werten das exklusive
  Oder berechnet. 
\end{aufgabeinline}

\section{Verzweigungen}

Um Fallunterscheidungen zu demonstrieren, nehmen wir uns folgende
Beispielaufgabe vor: Wir schreiben eine Funktion, die eine Zahl (auf
Englisch) "<aufsagen"> soll.  Sie soll sich so verhalten:
%
\begin{alltt}
(say-number 0)
\evalsto{} "zero"
(say-number 1)
\evalsto{} "one"
\end{alltt}
%
Der Einfachheit halber beschränken wir uns vorläufig auf die Zahlen
von Null bis Drei.  Die Funktion hat folgende Kurzbeschreibung:
%
\begin{alltt}
; Zahl zu Text machen
\end{alltt}
%
Die Funktion macht aus einer natürlichen Zahl eine Zeichenkette und
hat folgende Signatur:\index{say-number@\texttt{say-number}}
%
\begin{alltt}
(: say-number (natural -> string))
\end{alltt}
%
Die Signatur sagt leider nichts darüber aus, dass die Funktion nur bis
Drei funktioniert~-- später werden wir noch beschreiben, wie die
Signatur präziser werden kann.  Hier wollten wir uns jedoch erst
einmal auf die Funktionsdefinition konzentrieren.  Vorher machen wir
aber die obigen Beispiele zu Testfällen:
%
\begin{alltt}
(check-expect (say-number 0) "zero")
(check-expect (say-number 1) "one")
\end{alltt}
%
Das Gerüst ergibt sich direkt aus der Signatur:
%
\begin{alltt}
(define say-number
  (lambda (n)
    \ldots))
\end{alltt}
%
Aber wie kommen wir jetzt weiter?  Die Eingabe zerfällt ja in vier
Fälle~-- 0, 1, 2 und 3~-- sie bildet somit eine
\textit{Fallunterscheidung\index{Fallunterscheidung}}.  Um eine
Fallunterscheidung in der Eingabe einer Funktion verarbeiten zu können,
benötigen wir ein neues Programmelement, die
\textit{Verzweigung\index{Verzweigung}}.  Verzweigungen beginnen mit
dem Wort \texttt{cond} und gehören zu den kompliziertesten
Programmelementen, die wir in diesem Buch benutzen.  Aber keine Sorge,
so schlimm wird es nicht.  Um eine Verzweigung zu schreiben, müssen
wir wissen, \emph{wie viele} Fälle es gibt.  In diesem Fall sind das
vier.  Die Verzweigung dafür hat folgende Form:
%

\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Jedes der Programmstücke \texttt{(\ldots\ \ldots)} ist ein sogenannter
\textit{Zweig\index{Zweig}}.  Der erste Teil eines Zweigs ist immer
eine Bedingung, der für den entsprechenden Fall \verb|#t| liefern
sollte und für die anderen Fälle \verb|#f|.  In diesem Fall muss die
Bedingung jedes Zweiges jeweils eine der Zahlen von Null bis Drei
identifizieren:
%
\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      ((= n 0) \ldots)
      ((= n 1) \ldots)
      ((= n 2) \ldots)
      ((= n 3) \ldots))))
\end{alltt}
%
Der jeweils zweite Teil des Zweiges ist das gewünschte Ergebnis für
den entsprechenden Fall.  Wenn wir das ausfüllen, sieht das Resultat
so aus:
%
\begin{alltt}
(define say-number
  (lambda (n)
    (cond
      ((= n 0) "zero")
      ((= n 1) "one")
      ((= n 2) "two")
      ((= n 3) "three"))))
\end{alltt}
%
Fertig!
\begin{aufgabeinline}
  Finde heraus was passiert, wenn Du die Funktion mit einer Zahl
  aufrufst, für die sie nicht gemacht ist.
\end{aufgabeinline}

\section{Abdeckung}
\label{sec:testabdeckung}
\index{Abdeckung}

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.7\textwidth]{i1verzw/coverage}
  \caption{Anzeige von Abdeckung in DrRacket}
  \label{fig:coverage}
\end{figure}

Vielleicht ist Dir bei der \texttt{say-number}-Funktion aus dem
vorigen Abschnitt aufgefallen, dass bei dem Programm unmittelbar, nachdem
es gelaufen hat, zwei Zeilen farbig
hinterlegt sind, wie in Abbildung~\ref{fig:coverage} zu sehen.  Das liegt
daran, dass diese beiden Zeilen nie ausgewertet wurden, weil die
Tests nur die ersten beiden Fälle 0 und 1 überprüfen.  Theoretisch
könnte in den beiden letzten Zweigen für 2 und 3 noch ein Fehler
stecken, und die Tests würden es nicht bemerken.

Wenn Du folgende Testfälle hinzufügst, geht die farbige Hinterlegung weg:
%
\begin{verbatim}
(check-expect (say-number 2) "two")
(check-expect (say-number 3) "three")
\end{verbatim}
%
Probier es aus~-- am besten erst nur den einen, dann den anderen!

Die farbige Hinterlegung zeigt die \textit{Abdeckung} an, wie wir es
schon in Abschnitt~\ref{page:abdeckung0} auf
Seite~\pageref{page:abdeckung0} kurz diskutiert haben: Ein Ausdruck im
Programm, der durch die Tests ausgewertet wird, heißt
\textit{abgedeckt}.  Die farbig hinterlegten Ausdrücke sind also nicht
abgedeckt.  Der letzte Satz von Konstruktionsanleitung~\ref{ka:tests}
auf Seite~\pageref{ka:tests} zielt gerade darauf: Eine Funktion sollte
durch ihre Tests vollständig abgedeckt werden.  Die Abdeckung ist also
eine Minimalanforderung an unsere Tests.

\section{Aufzählungen}

Nächste Beispielaufgabe: Wir wollen Haustiere einteilen in niedliche
und nicht so niedliche.  Es gibt in der Welt dieser Aufgabe nur drei
verschiedene Haustiere: Katzen, Hunde und Pythons.  Haustiere
könnten wir in einem Kommentar im Programm so beschreiben:
%
\label{sec:datendefinition}
\begin{verbatim}
; Ein Haustier ist eins der folgenden:
; - Katze
; - Hund
; - Schlange
\end{verbatim}
%
Solch ein kurzer Kommentar, der die Daten beschreibt, die in unserer
Aufgabe vorkommen, heißt
\textit{Datendefinition\index{Datendefinition}}.  Mehr dazu in
Abschnitt~\ref{sec:datenanalyse}.  Die Formulierung der
Datendefinition "<eins der folgenden"> deutet daraufhin, dass auch
diese Sorte Daten in mehrere Fälle zerfällt~-- es handelt es sich also
wieder um eine Fallunterscheidung.

Bevor wir die eigentliche Aufgabe lösen (niedlich oder nicht), müssen
wir uns zunächst überlegen, wie wir Haustiere im Programm
repräsentieren: Für die Zwecke dieser Aufgabe reicht es zu wissen, mit
\emph{welcher} der drei Möglichkeiten wir es zu tun haben.  Wir
benutzen die einfachste Möglichkeit, Zeichenketten mit dem
entsprechenden Text, also \verb|"Katze"|, \verb|"Hund"| und
\verb|"Schlange"|.

Eine solche Auflistung von Werten bildet eine sogenannte
\textit{Aufzählung\index{Aufzählung}}~-- ein Spezialfall einer
Fallunterscheidung.

Für die Aufzählung der Haustiere gibt es noch keine fertige Signatur,
die müssen wir noch definieren.  Die
\textit{Signatur-Definition\index{Signatur-Definition}} sieht so
aus:\index{pet@\texttt{pet}}
\label{sec:pet}\label{page:signature}
%
\begin{alltt}
(define pet
  (signature (enum "Katze" "Hund" "Schlange")))
\end{alltt}
%
Da sind gleich zwei neue Programmelemente drin:
%
\begin{itemize}
\item \texttt{Signature\index{signature@\texttt{signature}}} müssen wir immer schreiben, wenn wir eine
  neue Signatur erzeugen.
\item \texttt{enum\index{enum@\texttt{enum}}} (das funktioniert
  nur innerhalb eines \texttt{signature}-Ausdrucks) ist für
  Aufzählungen zuständig.  In einem \texttt{enum}-Ausdruck stehen
  die Werte, die zur Aufzählung gehören.
\end{itemize}
%
\begin{aufgabeinline}
  Die Funktion \texttt{say-number} aus dem vorigen Abschnitt hat ja als
  Signatur-Deklaration die folgende:
\begin{alltt}
(: say-number (natural -> string))
\end{alltt}
  % 
  Mach die Signatur präziser mit Hilfe von Datendefinitionen und
  Signatur-Definitionen!  Ersetze dafür \texttt{natural} und
  \texttt{string} durch Aufzählungen.
\end{aufgabeinline}
%
Zurück zu unserer Funktion zur Niedlichkeitsanalyse.  Die definierte
Signatur \texttt{pet} können wir nun in der Signatur-Deklaration
unserer Funktion benutzen.  Zusammen mit der Kurzbeschreibung sieht
das so aus:
%
\begin{alltt}
; Ist Haustier niedlich?
(: cute? (pet -> boolean))
\end{alltt}
%
Das Fragezeichen gehört zum Namen der Funktion und ist eine
Konvention, die wir für die Namen von Funktionen verwenden, die einen
booleschen Wert zurückgeben~-- also solche Funktionen, die eine
Ja-/Nein-Frage beantworten.

Da es nur drei Möglichkeiten für die Eingabe gibt, können wir für alle
drei jeweils einen Test schreiben:
%
\begin{alltt}
(check-expect (cute? "Katze") #t)
(check-expect (cute? "Hund") #t)
(check-expect (cute? "Schlange") #f)
\end{alltt}
%
Kommen wir zur Funktion selbst.  Zunächst einmal das Gerüst:
%
\begin{alltt}
(define cute?
  (lambda (p)
    \ldots))
\end{alltt}
%
Da es sich bei der Eingabe um eine Aufzählung, also eine
Fallunterscheidung handel, brauchen wir eine Verzweigung im Rumpf.  Da
es drei Fälle in der Aufzählung gibt, braucht die Verzweigung
ebenfalls drei Zweige:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Als nächstes müssen wir die Bedingungen schreiben, und die sollten
\texttt{p} jeweils mit \verb|"Katze"|, \verb|"Hund"| und
\verb|"Schlange"| vergleichen.  Dabei könnte man leicht auf die Idee
kommen, \verb|(= p "Katze")| etc.\ zu schreiben.  Dann kommt
allerdings eine Fehlermeldung etwa so:
%
\begin{verbatim}
=: Zahl als erstes Argument erwartet, "Katze" bekommen
\end{verbatim}
%
Die Funktion \texttt{=} fühlt sich also nur für Zahlen zuständig, für
Zeichenketten müssen wir die Funktion
\texttt{string=?\index{string=?@\texttt{string=?}}} verwenden:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      ((string=? p "Katze") \ldots)
      ((string=? p "Hund") \ldots)
      ((string=? p "Schlange") \ldots))))
\end{alltt}
%
Bisher ergibt sich alles rein aus der Definition von \texttt{pet}.
Schließlich müssen wir noch die Antworten ergänzen.  Katze und Hunde
sind niedlich, Schlangen nicht:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      ((string=? p "Katze") #t)
      ((string=? p "Hund") #t)
      ((string=? p "Schlange") #f))))
\end{alltt}
%
Fertig!

\section{Zahlenbereiche}
\label{sec:zahlenbereiche}
\label{sec:heat-water}

Eine weitere häufig vorkommende Art der Fallunterscheidung gibt es bei
Zahlenbereichen.

Um das zu demonstrieren, nehmen wir uns folgende Aufgabe vor: Wir
schreiben eine Funktion, die "<Wasser erhitzt">, das heißt aus einer
Wasser-Anfangstemperatur und der Temperatur, die wir an Hitze hinzufügen, die
resultierende Temperatur bestimmt.  Wir schreiben dazu drei Versionen der
Funktion:
%
\begin{itemize}
\item Die erste, naive Version addiert einfach auf die
  Anfangstemperatur die hinzugefügte Hitze.
\item Die zweite Version berücksichtigt, dass Wasser bei 100°C siedet
  und nicht heißer werden kann.
\item Die dritte Version berücksichtigt zusätzlich, dass gefrorenem
  Wasser von 0°C eine Hitze von 80°C hinzugefügt werden muss, damit es
  schmilzt und dann immer noch erst bei 0°C ist.
\end{itemize}
%
(Physikalisch ist das natürlich Umfug, aber es geht
um ein möglichst einfaches Programmier-Beispiel.)

\paragraph{Naive Version} Wir fangen mit der naiven Version an und gehen nach dem Ablauf der
Konstruktionsanleitungen vor.  Zuerst kommt also eine
Kurzbeschreibung:
%
\begin{alltt}
; Wassertemperatur nach Erhitzen berechnen, naiv
\end{alltt}
%
Als nächstes kommt die Signatur-Deklaration.  Die Anfangstemperatur
und die hinzugefügte Hitze sind die Eingaben; sie stellen wir als
reelle Zahlen dar.  Heraus kommt die Endtemperatur, auch eine reelle
Zahl.  Da wir schon wissen, dass diese Version etwas einfach ist,
hängen wir eine \texttt{-0} an den Namen:
%
\begin{alltt}
(: heat-water-0 (real real -> real))
\end{alltt}                
%
Nun schreiben wir einige einfache Beispiele als Testfälle hin:
%
\begin{alltt}
(check-expect (heat-water-0 -10 20) 10)
(check-expect (heat-water-0 10 20) 30)
(check-expect (heat-water-0 90 20) 110)
\end{alltt}
%
Als nächstes kommt das Gerüst an die Reihe:
%
\begin{alltt}
(define heat-water-0
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Der Rumpf ist jetzt kein Hexenwerk, die beiden Eingaben werden
einfach addiert:
%
\begin{alltt}
(define heat-water-0
  (lambda (temp heat)
    (+ temp heat)))
\end{alltt}
%
Noch die Tests laufen lassen und fertig!

\paragraph{Siedendes Wasser} Als nächstes wollten wir berücksichtigen,
dass Wasser nicht über 100°C heiß werden kann.  Die Kurzbeschreibung
passen wir nur leicht an; die Signatur bleibt ebenfalls fast
unverändert~-- wir ändern nur den Namen und machen aus der 0 eine 1:
%
\begin{alltt}
; Wassertemperatur nach Erhitzen berechnen, Sieden berücksichtigen
(: heat-water-1 (real real -> real))
\end{alltt}
%
Bei den Tests können wir natürlich die Tests von \texttt{heat-water-0}
kopieren, aber den letzten müssen wir anpassen:
%
\begin{alltt}
(check-expect (heat-water-1 -10 20) 10)
(check-expect (heat-water-1 10 20) 30)
(check-expect (heat-water-1 90 20) 100)
\end{alltt}
%
Beim Testen ist es immer sinnvoll, auch Grenzfälle zu testen~--
schaltet die Funktion wirklich um, wenn die 100 erreicht sind. %%Nicht rum!
                              
Dazu dienen folgende zwei Testfälle:
%
\begin{alltt}
(check-expect (heat-water-1 99 1) 100)
(check-expect (heat-water-1 99 2) 100)
\end{alltt}
%
Da die Signatur die gleiche ist, ist auch das Gerüst identisch:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Ab 100°C muss die Funktion ihr Ergebnis also anders berechnen.  Oder,
anders gesagt, die Eingaben fallen in zwei verschiedene Klassen: die,
bei denen die Summe unter 100 liegt und die, bei denen sie darüber
liegt.
Wir benötigen also ein \texttt{cond} mit zwei
Zweigen:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      (\ldots \ldots)
      (\ldots \ldots))))
\end{alltt}
%
Wir brauchen nun eine Bedingung, die feststellt, ob die Summe aus
\texttt{temp} und \texttt{heat} unterhalb von 100 liegt (genauer:
kleiner \emph{oder gleich}, weil 100 gerade so erreichbar ist) und
eine dafür, dass die Summe darüber liegt.  Die könnten so aussehen:
%
\begin{alltt}
(<= (+ temp heat) 100)
(> (+ temp heat) 100)
\end{alltt}
%
Wenn wir diese beiden Bedingungen an die entsprechenden Stellen im
Rumpf setzen, sieht das so aus:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      ((<= (+ temp heat) 100) \ldots)
      ((> (+ temp heat) 100) \ldots))))
\end{alltt}
%
An die Stellen nach den Bedingungen müssen wir Ausdrücke setzen, die
das Ergebnis liefern, das im jeweiligen Fall richtig ist.  Das wäre dann:
%
\begin{alltt}
(define heat-water-1
  (lambda (temp heat)
    (cond
      ((<= (+ temp heat) 100) (+ temp heat))
      ((> (+ temp heat) 100) 100))))
\end{alltt}
%
Fertig!
%
%

%
\begin{aufgabeinline}
  Müssen es bei den beiden Bedingungen unbedingt \verb|<=| und
  \verb|>| sein?  Was passiert, wenn Du \verb|<=| durch \verb|<|
  ersetzt und das Programm dann laufen lässt?  Was passiert, wenn Du
  dann auch das \verb|>| ersetzt~-- durch \verb|>=|?  Warum
  funktioniert das Programm dann immer noch?
\end{aufgabeinline}
%
\paragraph{Siendendes Wasser und Eis} Kommen wir zur "<Vollversion">.
Zur Erinnerung: Da müssen wir noch berücksichtigen, dass gefrorenem
Wasser von 0°C eine Hitze von 80°C hinzugefügt werden muss, damit es
schmilzt und dann immer noch 0°C hat.  

Wir fangen wieder mit der Kurzbeschreibung an:
%
\begin{verbatim}
; Wassertemperatur nach Erhitzen berechnen, mit Eis & Sieden
\end{verbatim}
%
Da diese Version die letzte ist, hat sie keine Nummer mehr.  Ansonsten
ist die Signatur unverändert:
%
\begin{verbatim}
(: heat-water (real real -> real))
\end{verbatim}
%
Die Tests können wir nicht unverändert übernehmen.  Gleich der erste
funktioniert nicht mehr:
%
\begin{verbatim}
(check-expect (heat-water -10 20) 10)
\end{verbatim}
%
Das Aufwärmen des Wassers von -10°C auf 0°C erfordert nur 10°C
Wärmezufuhr, dann aber müssen erst einmal 80° weitere Wärme zugeführt
werden, damit es weiter geht.  Den Testfall müssen wir also ändern:
%
\begin{verbatim}
(check-expect (heat-water -10 20) 0)
\end{verbatim}
%
Die anderen Testfälle \texttt{heat-water-1} können so bleiben:
%
\begin{verbatim}
(check-expect (heat-water 10 20) 30)
(check-expect (heat-water 90 20) 100)
(check-expect (heat-water 99 1) 100)
(check-expect (heat-water 99 2) 100)
\end{verbatim}
%
Ein paar weitere Tests sollten aber noch genau klären, was um den
Nullpunkt herum so passiert und wo genau er überschritten wird:
%
\begin{verbatim}
(check-expect (heat-water -10 5) -5)
(check-expect (heat-water -5 60) 0)
(check-expect (heat-water -5 90) 5)
(check-expect (heat-water -1 81) 0)
(check-expect (heat-water -1 82) 1)
\end{verbatim}
%
Wieder sollten wir darüber nachdenken, in welche Fälle unsere
Eingaben zerfallen.  Da gibt es drei naheliegende Fälle:
%
\begin{enumerate}
\item Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
\item Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
\item Alles andere~-- das Wasser fängt flüssig an und bleibt durch die
  Erwärmung flüssig.
\end{enumerate}
%
Der erste Fall hat außerdem noch drei "<Unterfälle">:
%
\begin{itemize}
\item Die Erwärmumg bleibt unter 0°C.
\item Die Erwärmung bleibt bei  0°C "<stecken">
\item Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
\end{itemize}
%
So komplizierte Fallunterscheidungen sind relativ selten. Wenn sie
doch einmal auftauchen, ist besondere Sorgfalt gefragt: Darum
exerzieren wir das hier als Beispiel durch.

Fangen wir wieder mit dem Gerüst für die Funktion an:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    \ldots))
\end{alltt}
%
Wir wissen schon aus der Analyse der Fälle, dass es drei Fälle gibt.
Deshalb brauchen wir auch wieder ein \texttt{cond} mit drei Zweigen.
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Jetzt ergänzen wir Bedingungen, die den drei Fällen entsprechen.  Um
in diesem komplizierten Fall Leserinnen zu erleichtern, die
Bedingungen den Fällen zuzuordnen, stehen diese jeweils als Kommentar darüber:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0) \ldots)
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) \ldots)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100)) \ldots))))
\end{alltt}
%
Jetzt können wir uns daran machen, die Zweige auszufüllen.  Da der
erste Zweig (das Eis) komplizierter ist, schieben wir den erstmal vor
uns her, denn beim zweiten Zweig kommt einfach 100°C raus.  Ebenso
einfach ist der dritte Zweig, bei dem das Wasser flüssig bleibt~-- die
Antwort ist dort \texttt{(+ temp heat)}.  Der Zwischenstand sieht so
aus:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0) \ldots)
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Dass wir die leichten Fälle zuerst bearbeitet haben, mag wie Faulheit
aussehen.  Ist es auch~-- aber es ist auch sinnvolle Strategie, die
sich aus Mantra~\ref{mantra:schreib} ergibt:

\mantraschreib*
%
\noindent Auch über den ersten Zweig wissen wir etwas, nämlich dass er selbst
eine Fallunterscheidung ist mit drei Fällen.  Wir können also das
\texttt{cond} (wieder einmal) schon hinschreiben:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         (\ldots{} \ldots)
         (\ldots{} \ldots)
         (\ldots{} \ldots)))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Auch hier ist es sinnvoll, die Beschreibungen der Fälle über die
Zweige zu schreiben.  Danach ergänzen wir die Bedingungen mit
folgendem Ergebnis:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) \ldots)
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          \ldots)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         ((and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
          \ldots)))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Die Bedingungen sind jetzt noch komplizierter, aber erschließen sich
hoffentlich durch genauere Betrachtungen:
%
\begin{itemize}
\item "<Die Erwärmumg bleibt unter 0°C.">\\
  Das heißt, die Summe von
  Anfangstemperatur und Erwärmung ist kleiner als 0°C.
\item "<Die Erwärmung bleibt bei  0°C stecken.">\\
  Das heißt, die Summe von Temperatur und Erwärmung muss zwischen 0°C
  und 80°C liegen.
\item "<Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.">\\
  Das Summe von Temperatur und Erwärmung geht nicht nur über 0°C
  sondern auch über 80°C hinaus.
\end{itemize}
%
Die Antworten unter diesen Bedingungen sind vergleichweise einfach zu
ergänzen:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) (+ temp heat))
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          0)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         ((and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
          (- (+ temp heat) 80))))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      ((and (>= temp 0) (< (+ temp heat) 100))
       (+ temp heat)))))
\end{alltt}
%
Fertig!\footnote{Allerdings noch nicht ganz richtig: Vielleicht siehst Du,
  dass da noch etwas nicht ganz stimmt.  Wir kommen später darauf zurück.}

\medskip

Also \emph{fast} fertig.  Wenn wir das Programm näher betrachten,
fällt etwas Verbesserungspotenzial auf.  Fangen wir an mit der
Bedingung:
%
\begin{verbatim}
          (and (>= (+ temp heat) 0)
               (>= (+ temp heat) 80))
\end{verbatim}
%
Das ist übertrieben: Eine Temperatur über 80°C liegt auch über 0°C.
Wir können das also vereinfachen auf:
%
\begin{verbatim}
          (>= (+ temp heat) 80)
\end{verbatim}
%
Das ist mathematisch einleuchtend, zur Sicherheit sollten wir aber die
Tests nochmals laufen lassen: Aber sie laufen alle noch erfolgreich
durch.

Bevor wir die Funktion noch weiter vereinfachen, ist es sinnvoll, die
Funktionsweise der Auswertung von \texttt{cond}-Ausdrücken zu ergründen:
%
\begin{aufgabeinline}
  Lasse die \texttt{heat-water}-Funktion im Stepper laufen und
  beobachte, wie~-- vor allem in welcher Reihenfolge~-- die Bedindungen
  in einem \texttt{cond}-Ausdruck ausgewertet werden.
\end{aufgabeinline}
%
Wenn Du diese Aufgabe erledigt hast, wirst Du beobachtet haben, dass Racket
die Bedingungen in einem \texttt{cond}-Ausdruck nacheinander
auswertet.  Sobald eine davon \verb|#t| ergibt, macht Racket mit dem
Ausdruck des Zweiges weiter.  Die restlichen Zweige werden gar nicht
mehr berücksichtigt, unabhängig davon, ob sie \verb|#t| ergeben
könnten oder nicht.
Das können wir ausnutzen, um die Funktion weiter zu vereinfachen.
Dazu betrachten wir die beiden ersten Bedingungen im "<inneren">
\texttt{cond}:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((and (>= (+ temp heat) 0)
               (< (+ temp heat) 80))
          0)
         \ldots)
\end{alltt}
%
Wenn die erste Bedingung \verb|#f| ergeben hat, also nicht stimmt,
dann ist \texttt{(+ temp heat)} größer oder gleich 0.  Das heißt, der
Teilausdruck \texttt{(>= (+ temp heat) 0)} in der \emph{nächsten}
Bedingung liefert \emph{immer} \verb|#t|.  Wir können also
vereinfachen:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((and #t
               (< (+ temp heat) 80))
          0)
         \ldots)
\end{alltt}
%
Ein Ausdruck \texttt{(and \#t \(e\))} liefert immer das gleiche Ergebnis
wie \(e\)~-- schau nochmal auf Seite~\pageref{page:and}, um Dich davon
zu überzeugen!  Wir können also das innere \texttt{cond} weiter
vereinfachen zu:
%
\begin{alltt}
       (cond
         ((< (+ temp heat) 0) (+ temp heat))
         ((< (+ temp heat) 80) 0)
         \ldots)
\end{alltt}
%
\label{page:bedingungen-vereinfachen}
Wir benutzen also Mathematik (genauer gesagt
\textit{Algebra\index{Algebra}}, also die Lehre der Gleichungen), um
unser Programm zu vereinfachen.  Algebra ist ein sehr mächtiges
Werkzeug in der Programmierung, und wir werden es noch oft nutzen.
Das fällt oft einfacher, wenn wir gar nicht über die konkrete
Bedeutung der Ausdrücke nachdenken sondern nur Gleichungen benutzen,
wie oft in der Mathematik und entsprechend
Mantra~\ref{mantra:gleichungen} auf Seite~\pageref{mantra:gleichungen}.

Wir sind aber mit dem Vereinfachen noch nicht fertig. Betrachten wir
nun die drei "<äußeren"> Bedingungen:
%
\begin{alltt}
    (cond
      ((< temp 0) \ldots)
      ((>= (+ temp heat) 100) \ldots)
      ((and (>= temp 0) (< (+ temp heat) 100)) \ldots))
\end{alltt}
%
Wenn die erste Bedingungen \verb|#f| ergibt, gilt automatisch
\texttt{(>= temp 0)}.  Wir können die letzte Bedingung also
vereinfachen zu:
%
\begin{alltt}
(and #t (< (+ temp heat) 100))
\end{alltt}
%
Wenn auch die zweite Bedingung \verb|#f| ergibt, gilt auch \texttt{(<
  (+ temp heat) 100)}.  Wir können also vereinfachen zu \texttt{(and
  \#t \#t)} und von da zu \verb|#t|.

Wir können die Funktion mit dieser Einsicht vereinfachen und \verb|#t|
als Bedingung hinschreiben.  (Probier es aus!)  Allerdings finden
manche das hässlich: Darum ist es auch möglich, statt \verb|#t| das
besondere Wort \texttt{else\index{else@\texttt{else}}}
("<andernfalls"> auf Englisch) hinzuschreiben.
Der \texttt{else}-Zweig kommt also zum Zug, wenn alle anderen
"<durchgefallen"> sind.  Das Ergebnis sieht
dann so aus:
%
\begin{verbatim}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) (+ temp heat))
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((< (+ temp heat) 80) 0)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         (else (- (+ temp heat) 80))))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      (else
       (+ temp heat)))))
\end{verbatim}
%
\begin{feature}{Verzweigung}{scheme:cond}
In den Lehrsprachen werden Verzweigungen\index{Verzweigung}\index{Verzweigung}
mit der Spezialform \texttt{cond}\index{cond@\texttt{cond}} dargestellt.
Ein \texttt{cond}"=Ausdruck hat die folgende Form:
%
\begin{alltt}
(cond
  (\(b\sb{1}\) \(a\sb{1}\))
  (\(b\sb{2}\) \(a\sb{2}\))
  \(\ldots\)
  (\(b\sb{n-1}\) \(a\sb{n-1}\))
  (else \(a\sb{n}\))))
\end{alltt}
%
Dabei sind die $b_i$ und die $a_i$ ihrerseits Ausdrücke.  Der
\texttt{cond}-Ausdruck wertet nacheinander alle Bedingungen $b_i$ aus;
sobald eine Bedingung $b_k$ \texttt{\#t} ergibt, wird der
\texttt{cond}-Ausdruck durch das entsprechende $a_k$ ersetzt.  Wenn
alle Bedingungen fehlschlagen, wird durch $a_n$ ersetzt.  Die Paarungen
\texttt{($b_i$ $a_i$)} heißen \textit{Zweige\index{Zweig}} des
\texttt{cond}-Ausdruckes, und der Zweig mit \texttt{else}  heißt
\textit{\texttt{else}-Zweig\index{else-Zweig@\texttt{else}-Zweig}}.
Der \texttt{else}-Zweig kann auch fehlen~-- dann sollte aber immer
eine der Bedingungen  \texttt{\#t} ergeben.  Wenn doch einmal bei allen
$b_i$ \verb|#f| herauskommen sollte, bricht \drscheme{} das Programm ab
und gibt eine Fehlermeldung aus.
\end{feature}
%
Damit haben wir die komplette Funktionsweise von \texttt{cond}
angewendet. Abbildung~\ref{scheme:cond} fasst sie noch einmal zusammen.

Dann kannst Du auch von vornherein \texttt{else} benutzen, wenn Du Dir
sicher bist, dass alle anderen Fälle schon in den vorigen Zweigen
abgedeckt sind.  Im Zweifelsfall empfehlen wir aber immer den Weg über
die Mathematik, damit die Funktion auch korrekt wird.

A propos korrekt: Ist \texttt{heat-water} korrekt?  Hier ist ein
weiterer Testfall:
%
\begin{verbatim}
(check-expect (heat-water -1 191) 100)
\end{verbatim}
%
Von den 191°C wird 1°C benötigt, um auf 0°C zu kommen, dann weitere
80°C, um über 0°C hinauszukommen, bleiben 110°C.  Aber über 100°C geht
es natürlich trotzdem nicht.  Leider sieht die Funktion das anders:
%
\begin{verbatim}
Check-Fehler:
	Der tatsächliche Wert 110 ist nicht der erwartete Wert 100.
\end{verbatim}
%
Woran liegt das?  Wenn wir die Verzweigungen im Kopf nachvollziehen,
sehen wir, dass zunächst der erste Zweig des äußeren \texttt{cond}
greift, weil die Bedingung \verb|(< temp 0)| als Wert \verb|#t| hat.
Im inneren \texttt{cond} schließlich ergeben die ersten beiden
Bedingungen jeweils \verb|#f|, es bleibt also der \texttt{else}-Zweig,
und addiert die Wärme "<blind"> auf die Anfangstemperatur.

Wir müssen also unser Programm korrigieren, weil dieser Fall noch
nicht berücksichtigt ist: Die Anfangstemperatur ist unter 0°C, die
Erwärmung würde die Temperatur aber über 100°C heben.  Es greift also
der \texttt{else}-Zweig des inneren \texttt{cond} des äußeren Zweigs
mit \texttt{(< temp 0)}, und das ist in diesem Fall falsch.  Die
ersten beiden Zweige sind für Endtemperaturen bis 0°C zuständig, wir
müssen also den neuen Zweig unmittelbar vor dem \texttt{else}-Zweig
einfügen.  Der sieht so aus:
%
\begin{verbatim}
         ; Die Erwärmung würde die Temperatur auf über 100°C bringen
         ((>= (- (+ temp heat) 80) 100) 100)
\end{verbatim}
%
Jetzt ist das Programm endlich fertig und korrekt!

Doch wie konnte dieser Fehler unbemerkt bleiben, zumindest zunächst
von uns?  Das liegt daran, dass die Fallunterscheidung, die der
Aufgabe zugrundliegt, ziemlich komplex ist.  Bei komplexen Programmen
ist das Risiko \emph{immer} groß, dass sie Fehler enthalten.  Bei
komplexen Fallunterscheidungen bedeutet dies, dass fast immer ein Fall
im Programm fehlt, zumindest beim ersten Anlauf.  Wir sollten uns bei
der Gelegenheit an Mantra~\ref{mantra:komplexitaet} auf
Seite~\pageref{mantra:komplexitaet} erinnern:

\mantrakomplexitaet*

\noindent Bei komplizierten Fallunterscheidungen, teste deshalb gründlich und
gehe davon aus, dass Du Zweige vergessen hast.

\section{Datenanalyse und Schablonen}
\label{sec:datenanalyse}

In Abschnitt~\ref{sec:datendefinition} auf
Seite~\pageref{sec:datendefinition} ist zum ersten Mal eine
\textit{Datendefinition\index{Datendefinition}} aufgetaucht:
%
\begin{verbatim}
; Ein Haustier ist eins der folgenden:
; - Katze
; - Hund
; - Schlange
\end{verbatim}
%
Diese Datendefinition ist das Ergebnis eines Nachdenkprozesses, der
sogenannten \textit{Datenanalyse\index{Datenanalyse}}.  Dieser Begriff
ist schon in Abschnitt~\ref{sec:konstruktionsanleitungen} auf
Seite~\pageref{sec:konstruktionsanleitungen} aufgetaucht, als zweiter
Schritt der Konstruktionsanleitung: Ab sofort werden wir diesen
Schritt immer durchführen, weil er zentral ist für die systematische
Konstruktion von Programmen.

Die Vorgehensweise bei einer Datenanalyse sieht im allgemeinen so aus:
%
\begin{konstruktionsanleitung}{Datenanalyse}
  Suche in der Aufgabenstellung nach problemrelevanten Größen;
  Kandidaten sind immer die Substantive. Schreibe für jede dieser
  Größen eine Datendefinition, es sei denn, diese ist aus dem Kontext
  offensichtlich.

  Wenn es für die Datendefinition noch keine Signatur gibt, schreibe
  eine Signaturdefinition dazu.  Schreibe außerdem Beispiele auf und
  schreibe jeweils einen Kommentar, der die Beziehung zwischen Daten
  und Information beschreibt.
\end{konstruktionsanleitung}
%
\emph{Wie} Du die Signaturdefinition schreibst, dafür gibt es in
diesem Buch eine Reihe spezialisierter Konstruktionsanleitungen.  Die
Beziehung zwischen Daten und Information geht auf
Abschnitt~\ref{sec:information-daten} auf
Seite~\pageref{sec:information-daten} zurück.

In diesem Fall ist "<Haustier"> eine problemrelevante Größe, zu der
wir eine Datendefinition geschrieben haben.  Bei der Erwärmung von
Wasser haben wir allerdings nicht extra hingeschrieben, dass die
Wassertemperatur eine reelle Zahl ist, weil dies allgemein bekannt
ist.

Für die Formulierung der Datendefinition gibt es eine Reihe von
typischen Mustern, die sich immer wiederfinden.  Eins ist bei der
Definition von "<Haustier"> ersichtlich, nämlich "<eins der
folgenden">, das darauf hinweist, dass es sich bei "<Haustier"> um
eine Fallunterscheidung handelt.  

\begin{konstruktionsanleitung}{Fallunterscheidung: Datenanalyse}
  \label{ka:fallunterscheidung}
  Versuche, für die Datendefinition eine Formulierung "<\ldots{}
    ist eins der folgenden"> zu finden. Wenn das möglich ist, beschreibt
  Deine Datendefinition eine
  \textit{Fallunterscheidung\index{Fallunterscheidung}}.  Schreibe
  dann eine Auflistung aller Fälle, jeder Fall auf eine separate
  Zeile:
  
\begin{alltt}
; Ein X ist eins der folgenden:
; - Fall 1
; - Fall 2
; - ...
; - Fall n
\end{alltt}
\end{konstruktionsanleitung}
%
Für den Sonderfall der Aufzählung haben wir folgende Konstruktionsanleitung:
%
\begin{konstruktionsanleitung}{Aufzählung: Datenanalyse}
  \label{ka:aufzaehlung}
  Falls Deine Datendefinition eine Fallunterscheidung beschriebt und
  jeder der Fälle nur aus einem einzelnen Wert besteht, handelt es
  sich um eine \textit{Aufzählung\index{Aufzählung}}.

  Schreibe für jede Aufzählung eine Signaturdefinition der Form:
  % 
\begin{alltt}
(define \(s\) (signature (enum \ldots)))
\end{alltt}
  %
  Achte darauf, dass die Anzahl der Fälle der Signaturdefinition der
  Anzahl der Fälle der Datendefinition entspricht.
\end{konstruktionsanleitung}
%
Die Datenanalyse ist die wichtigste Methode zur Umsetzung der
Mantras~\ref{mantra:schreib} und \ref{mantra:lies}:
%
\mantraschreib*
%
\mantralies*
%
\noindent Die Datenanalyse lenkt beim Lesen zunächst unseren Blick auf die
Daten, \emph{nicht} darauf, was später mit ihnen gemacht wird.  (Das
kommt später.)  Außerdem gibt sie uns Werkzeug an die Hand, wie wir
die Erkenntnisse aus dem Lesen strukturieren und aufschreiben können.
Insbesondere führt sie immer auch zu Elementen in unserem Programm.
Bei der Funktion \texttt{cute?} haben wir zum Beispiel aus der
Datendefinition zunächst eine Signaturdefinition abgeleitet:
%
\begin{verbatim}
(define pet
  (signature (enum "Katze" "Hund" "Schlange")))
\end{verbatim}
%
Bei Aufzählungen gibt es nur drei Beispiele, die schon in der
Signaturdefinition stehen: Wir müssen also keine weiteren
aufschreiben.

Da die Datendefinition für "<Haustier"> drei Fälle hat, muss auch die
Signaturdefinition drei Fälle haben.  Aus der Signaturdefinition
ergibt sich direkt eine Verzweigung im Rumpf, die sich nur aus der
Signatur \texttt{(pet -> boolean)} beziehungsweise der
Signaturdefinition von \texttt{pet} als Aufzählung mit drei Fällen
ergibt:
%
\begin{alltt}
(define cute?
  (lambda (p)
    (cond
      (\ldots{} \ldots)
      (\ldots{} \ldots)
      (\ldots{} \ldots))))
\end{alltt}
%
Da \texttt{cute?} eine Eingabe zur Signatur \texttt{pet} erwartet und
\texttt{pet} eine Aufzählungssignatur mit \emph{drei} Fällen ist, \emph{muss}
im Rumpf eine Verzweigung mit ihrerseits \emph{drei} Zweigen
auftauchen, ganz egal, was die konkrete Aufgabenstellung ist.  Wir
betonen das Wort \emph{drei} deshalb so, weil viele Fehler dadurch
passieren, dass die Anzahl der Zweige im \texttt{cond} einer solchen
Funktion nicht der Anzahl der Fälle entspricht.

So ein unfertiges Programm, in dem sich einige Elemente aus der
Analyse der Daten ergeben haben ohne besondere Berücksichtigung der
konkreten Aufgabenstellung heißt \textit{Schablone}.  Zu bestimmten
Arten von Datendefinitionen gehören bestimmte Schablonen.

\begin{konstruktionsanleitung}{Schablone}
  \index{Schablone}
  Wenn Du das Gerüst fertiggestellt hast, benutze die Signatur und die
  dazugehörigen Datendefinitionen, um Konstruktionsanleitungen mit ein
  oder mehreren Schablonen auszuwählen und übertrage die Elemente der
  Schablonen in den Rumpf der Funktion.
\end{konstruktionsanleitung}
%
Die Schablone ist das nächste Werkzeug für die Umsetzung von
Mantra~\ref{mantra:schreib}:
%
\mantraschreib*
%
\noindent Für jede Sorte von Datendefinition schreiben wir neben der
Konstruktionsanleitung für die Datenanalyse auch eine für die
Schablone.  Die Schablone für Fallunterscheidungen sieht
folgendermaßen aus:
%
\begin{konstruktionsanleitung}{Fallunterscheidung: Schablone}
  \label{ka:fallunterscheidung-schablone}
  Wenn Du eine Funktion schreibst, die eine Fallunterscheidung als
  Eingabe verarbeitet, schreibe als Schablone in den Rumpf eine
  Verzweigung mit sovielen Zweigen, wie es in der Fallunterscheidung
  Fälle gibt, nach folgendem Muster:
  %
\begin{alltt}
(define \(f\)
  (lambda (\(a\))
    (cond
      (\ldots{} \ldots)
      \ldots
      (\ldots{} \ldots))))
\end{alltt}
  Schreibe danach Bedingungen in die Zweige, welche die einzelnen
  Fälle voneinander unterscheiden.
\end{konstruktionsanleitung}
%
Diese Konstruktionsanleitung mag Dir ziemlich bürokratisch vorkommen,
und das ist sie auch.  Es mag Dir langweilig vorkommen, sie stur zu
befolgen, und das ist bestimmt ab und zu der Fall.  Dafür nehmen die
Konstruktionsanleitungen Dir viel Denkarbeit ab, und Du kannst Dein
Gehirn dann für die Lösung der eigentlichen Problemstellung verwenden,
wenn erst einmal die Schablone steht.  Spätestens also wenn Du vor
einer vermeintlich schweren Aufgabe stehst, wende erst einmal die
Konstruktionsanleitungen an, bevor Du Dir Sorgen machst, ob am Ende
alles aufgeht.  Was am Ende übrigbleibt, ist oft erstaunlich einfach.

\section{Exkurs: Verzweigungen in der Mathematik}

In der Mathematik gibt es auch Verzweigungen.  Diese werden in der
Regel mit einer großen geschweiften Klammer geschrieben.  In der
Mathematik ist es allerdings üblich, alle Bedingungen
"<auszuschreiben">, also ihre Bedeutung nicht von der Reihenfolge der
Auswertung abhängig zu machen, wie wir es bei \texttt{heat-water}
getan haben.  Die Funktion schreiben wir den mathematischen
Gepflogenheiten entsprechend als einbuchstabige Funktion $h$ mit
Parametern $t$ für \texttt{temp} und $h$ für \texttt{heat}:
%
\begin{displaymath}
  h(t, h) \deq
  \begin{cases}
    \begin{cases}
      t + h & \text{falls } t + h < 0\\
      0 & \text{falls } t + h \geq 0 \text{ und } t + h < 80 \\
      100 & t + h - 80 \geq 100\\
      t + h - 80 & \text{falls }  t +h \geq
      80
    \end{cases}
    & \text{falls } t < 0
    \\
    100 & \text{falls } t + h \geq 100
    \\
    t + h & \text{falls } t \geq 0 \text{ und } t + h < 100
  \end{cases}
\end{displaymath}

\section{Boolesche Fallunterscheidungen und binäre Verzweigungen}
\label{sec:binaere-verzweigungen}

\index{boolesche Fallunterscheidung}\index{binäre Verzweigung}
Bei manchen Fallunterscheidungen definiert sich die letzte Kategorie
dadurch, dass ein Wert in keine der anderen Kategorien gehört.  Dann
ist die Benutzung eines \texttt{else}-Zweigs im \texttt{cond}
sinnvoll.

Nehmen wir einmal an, dass Du ein Haustier (wie in
Abschnitt~\ref{sec:pet} auf Seite~\pageref{sec:pet}) zum Geburtstag
geschenkt bekommen hast. Mit dem Geschenk kam das Angebot, das
Haustier gegen ein anderes auszutauschen, falls es Dir nicht gefällt.
Nehmen wir weiter an, dass Du nur an niedlichen Haustieren
interessiert bist.  Wir schreiben also eine Funktion, die ein Haustier
gegen ein niedliches austauscht, wenn es nicht niedlich ist~-- und
sonst halt nicht austauscht.

Die Funktion könnte folgende Kurzbeschreibung und Signatur
haben:\index{exchange-for-cute@\texttt{exchange-for-cute}}
%
\begin{verbatim}
(: exchange-for-cute (pet -> pet))
\end{verbatim}
%
Es geht also das Haustier vor dem Umtausch als Eingabe in die Funktion
hinein, und das nach dem Umtausch kommt heraus.  Als Testfälle bieten
sich folgende an:
%
\begin{verbatim}
(check-expect (exchange-for-cute "Katze") "Katze")
(check-expect (exchange-for-cute "Hund") "Hund")
(check-expect (exchange-for-cute "Schlange") "Katze")
\end{verbatim}
%
Das Gerüst sieht folgendermaßen aus:
%
\begin{alltt}
(define exchange-for-cute
  (lambda (p)
    \ldots))
\end{alltt}
%
Als nächstes ist die Konstruktion der Schablone dran.  Wir könnten uns
an der Definition von \texttt{pet} orientieren und eine
Fallunterscheidung mit drei Fällen als Grundlage nehmen.  Allerdings
ist recht offensichtlich, dass sich das Ergebnis von
\texttt{exchange-for-cute} danach richtet, ob \texttt{cute?} \verb|#t|
oder \verb|#f| liefert.   \verb|#t| und \verb|#f| bilden hier eine
Aufzählung mit nur zwei Fällen.  Wir könnten also eine Schablone mir
nur zwei Fällen konstruieren:
%
\begin{alltt}
(define exchange-for-cute
  (lambda (p)
    (cond
      ((cute? p) \ldots)
      (else \ldots"))))
\end{alltt}
%
Die Lücken sind einfach zu füllen:
%
\begin{alltt}
(define exchange-for-cute
  (lambda (p)
    (cond
      ((cute? p) p)
      (else "Katze"))))
\end{alltt}
%
Diese boolesche Fallunterscheidungen bildet einen häufig auftretenden
Spezialfall: Der zweite Fall ist gerade dadurch definiert, dass er
nicht der erste ist, der entsprechende \texttt{cond}-Ausdruck hat also
immer einen Zweig mit Bedingung und einen mit \texttt{else}-Zweig.
Weil solche binären Verzweigungen so häufg vorkommen, gibt es eine
etwas kürzere Spezialform für das "<binäre \texttt{cond} mit
\texttt{else}"> namens \texttt{if}\index{if@\texttt{if}}.  Damit
können wir \texttt{exchange-for-cute} etwas kürzer schreiben:
%
\begin{verbatim}
(define exchange-for-cute
  (lambda (p)
    (if (cute? p)
        p
        "Katze")))
\end{verbatim}
%
Das \texttt{if} spart also ein Paar Klammern und das \texttt{else},
aber dafür kann es eben nur binäre Verzweigungen.
Abbildung~\ref{scheme:if} zeigt die allgemeine Form von
\texttt{if}-Ausdrücken.
\begin{feature}{Binäre Verzweigung}{scheme:if}
  %
  Eine binäre Verzweigung hat die folgende Form:
\begin{alltt}
(if \(b\)
    \(k\)
    \(a\))
\end{alltt}
  %
Dabei ist $b$ die Bedingung und $k$ und $a$ sind die
beiden Zweige: die \textit{Konsequente\index{Konsequente}} $k$ und die
\textit{Alternative\index{Alternative}} $a$.

Abhängig vom Ausgang der
Bedingung ist der Wert der Verzweigung entweder der Wert der Konsequente
oder der Wert der Alternative.
\end{feature}
%
\begin{aufgabeinline}
  In der Mathematik gibt den Begriff des "<Absolutbetrags"> einer
  Zahl: Für eine negative Zahl liefert es die entsprechende positive
  Zahl (aus $-5$ wird also $5$), alle anderen Zahlen bleiben
  unverändert.  Schreibe eine Funktion, die den Absolutbetrag einer
  Zahl berechnet!
\end{aufgabeinline}
%
Für boolesche Fallunterscheidungen gibt es eine separate
Konstruktionsanleitung:
%
\begin{konstruktionsanleitung}{boolesche Fallunterscheidung: Schablone}
  \label{ka:boolesche-fallunterscheidung}
  Wenn sich das Ergebnis einer Funktion nach einer booleschen Größe
  richtet, welche die Funktion mit Hilfe der Eingaben berechnen kann,
  benutze als Schablone im Rumpf eine binäre Verzweigung:
  %
\begin{alltt}
(define \(f\)
  (lambda (\(e\))
    (if \ldots ; \textrm{hier wird die boolesche Größe berechnet}
        \ldots
        \ldots)))
\end{alltt}
\end{konstruktionsanleitung}

\section{Syntaktischer Zucker}

Tatsächlich ist \texttt{if} die "<primitivere"> Form als
\texttt{cond}: jede \texttt{cond}-Form kann in eine äquivalente
\texttt{if}-Form übersetzt werden, und zwar nach
folgendem Schema:
%
\begin{alltt}
(cond (\(t\sb{1}\) \(a\sb{1}\)) (\(t\sb{2}\) \(a\sb{2}\)) \(\ldots\) (\(t\sb{n-1}\) \(a\sb{n-1}\)) (else \(a\sb{n}\)))
  \(\mapsto\) (if \(t\sb{1}\) \(a\sb{1}\) (if \(t\sb{2}\) \(a\sb{2}\) \ldots (if \(t\sb{n-1}\) \(a\sb{n-1}\) \(a\sb{n}\))\ldots))
\end{alltt}
%
Die geschachtelte \texttt{if}-Form auf der rechten Seite der
Übersetzung wertet, genau wie die \texttt{cond}-Form, nacheinander
alle Bedingungen aus, bis eine \verb|#t| liefert.  Die rechte Seite des
\texttt{cond}-Zweigs ist dann gerade die Konsequente des \texttt{if}s.
Erst wenn alle Bedingungen fehlschlagen ist die Alternative des letzten
\texttt{if}-Ausdrucks dran, nämlich $a_n$ aus dem \texttt{else}-Zweig.

Da sich mit Hilfe dieser Übersetzung jede \texttt{cond}-Form durch
geschachtelte \texttt{if}-Formen ersetzen lässt, ist \texttt{cond}
streng genommen gar nicht notwendig.  \texttt{Cond} ist deswegen eine
sogenannte \textit{abgeleitete Form\index{abgeleitete
    Form}}\index{Form!abgeleitet}.  Da \texttt{cond} und andere
abgeleitete Formen trotzdem praktisch und angenehm zu verwenden sind
und damit dem Programmierer die Arbeit versüßen,
heißen abgeleitete Formen auch \textit{syntaktischer
  Zucker\index{syntaktischer Zucker}\index{Zucker, syntaktischer}}.

\begin{aufgabeinline}
  Schreibe die Funktion \texttt{cute?} aus Abschnitt~\ref{sec:pet} so
  um, dass sie \texttt{if} statt  \texttt{cond} verwendet.
\end{aufgabeinline}
%
Auch \texttt{and} und \texttt{or} sind eigentlich syntaktischer Zucker:
Es ist immer möglich, einen \texttt{and}-Ausdruck in \texttt{if}s
zu übersetzen.  Es gelten folgende Übersetzungsregeln:
%
\begin{alltt}
(and \(e\)) \(\mapsto\) \(e\)
(and \(e\sb{1}\) \(e\sb{2}\) \(\ldots\)) \(\mapsto\) (if \(e\sb{1}\) (and \(e\sb{2}\) \(\ldots\)) #f)
\end{alltt}
%
Ein \texttt{and}-Ausdruck mit mehreren Operanden wird so schrittweise
in eine Kaskade von \texttt{if}-Ausdrücken übersetzt:
%
\begin{alltt}
(and a b c)
\(\mapsto{}\) (if a (and b c) #f)
\(\mapsto{}\) (if a (if b (and c) #f))
\(\mapsto{}\) (if a (if b c #f))
\end{alltt}
%
Ebenso lassen sich \texttt{or}-Ausdrücke immer in
\texttt{if}-Ausdrücke übersetzen:
%
\begin{alltt}
(or \(e\)) \(\mapsto\) \(e\)
(or \(e\sb{1}\) \(e\sb{2}\) \(\ldots\)) \(\mapsto\) (if \(e\sb{1}\) #t (or \(e\sb{2}\) \(\ldots\)))
\end{alltt}
%
Beispiel:
%
\begin{alltt}
(or a b c)
\(\mapsto{}\) (if a #t (or b c))
\(\mapsto{}\) (if a #t (if b #t (or c)))
\(\mapsto{}\) (if a #t (if b #t c))
\end{alltt}
%
\begin{aufgabeinline}
  Beim syntaktischen Zucker für \texttt{and} und \texttt{or} könnten
  wir auch definieren, in was \texttt{(and)} und \texttt{(or)} (also
  jeweils ohne Operanden) übersetzt wird.  Was wäre jeweils die
  korrekte Übersetzung?  (Achtung: Die korrekte Übersetzung überrascht
  Dich vielleicht.)  Übersetze \texttt{(and a b c)} und \texttt{(or a
    b c)} jeweils mit Hilfe Deiner neuen Regeln so, als ob die Regeln
  \texttt{(and \(e\))} und \texttt{(or \(e\))} nicht da wären.
\end{aufgabeinline}

\section{Unsinnige Daten abfangen}
\label{sec:nonsensical-data}

Noch einmal zurück zur Funktion \texttt{heat-water} in
Abschnitt~\ref{sec:heat-water}: Die hat schon ziemlich viele Zweige.
Genau genommen decken die aber immer noch nicht alles ab.  %Zum
Bei Anfangstemperaturen über 100°C verhält sich die Funktion merkwürdig:
%
\begin{alltt}
(heat-water 150 0)
\evalsto{} 100
\end{alltt}
%
Das liegt daran, dass es gar kein vernünftiges Ergebnis gibt, wenn die
Anfangstemperatur über 100°C liegt.  Die Funktion berechnet aber
trotzdem munter eines.  Es wäre gut, wenn wir dem Benutzer sagen
könnten, dass die Funktion unsinnige Eingaben bekommen hat.

Dazu erweitern wir erst einmal die Verzweigung, gleich am Anfang:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist über 100°C, also unzulässig
      ((> temp 100) \ldots)
      \ldots)))
\end{alltt}
%
Nur~-- was tun im Fehlerfall?  Dazu gibt eine eingebaute Funktion
\texttt{violation},\label{sec:violation} die eine Fehlermeldung als Zeichenkette akzeptiert
und, wenn sie aufgerufen wird, das Programm abbricht und die
Fehlermeldung ausdruckt.  Die vollständige fertige Funktion sieht
dann so aus:
%
\begin{alltt}
(define heat-water
  (lambda (temp heat)
    (cond
      ; Die Anfangstemperatur ist über 100°C, also unzulässig
      ((> temp 100)
       (violation "Anfangstemperatür über 100°C"))
      ; Die Anfangstemperatur ist unter 0°C, es wird also Eis erwärmt.
      ((< temp 0)
       (cond
         ; Die Erwärmumg bleibt unter 0°C.
         ((< (+ temp heat) 0) (+ temp heat))
         ; Die Erwärmung bleibt bei  0°C "stecken"
         ((< (+ temp heat) 80) 0)
         ; Die Erwärmung würde die Temperatur auf über 100°C bringen
         ((>= (- (+ temp heat) 80) 100) 100)
         ; Die Erwärmung erhöht die Temperatur über den Nullpunkt hinaus.
         (else
          (- (+ temp heat) 80))))
      ; Die Erwärmung würde die Wassertemperatur auf über 100°C erhöhen.
      ((>= (+ temp heat) 100) 100)
      ; Das Wasser fängt flüssig an und bleibt durch die Erwärmung flüssig.
      (else
       (+ temp heat)))))
\end{alltt}
%
Natürlich sollten wir auch den Fehlerfall testen~-- das geht nicht mit
\texttt{check-expect}, das ja erwartet, dass ein Testausdruck einen
ordnungsgemäßen Wert liefert.  Für Fehlerfälle gibt es
\texttt{check-error}\index{check-error@\texttt{check-error}}, das Testfälle erzeugt, die dann bestanden sind,
wenn die Auswertung einen Fehler liefert:
%
\begin{verbatim}
(check-error (heat-water 150 0)) ; Anfangstemperatur über 100°C
\end{verbatim}

\section*{Aufgaben}

\begin{aufgabe}
Zu den "<Flensburg">-Punkten, die es bei Verstößen gegen die
Straßenverkehrsordnung gibt, hat eine Seite im Internet folgendes zu
sagen:
%
\begin{center}
  \begin{tabular}{rl}
    0 Punkte & Keine Sanktionen\\
    1 bis 3 Punkte & Vormerkung\\
    4 bis 5 Punkte & Ermahnung\\
    6 bis 7 Punkte & Verwarnung\\
    8 Punkte & Entzug
  \end{tabular}
\end{center}
%
Schreibe eine Funktion, die zu einer gegebenen Punktezahl die daraus
folgende Konsequenz berechnet!
\end{aufgabe}

\begin{aufgabe}
  Schreibe eine Funktion \texttt{card-type}, die den Umsatz einer
  Kreditkarte akzeptiert und die eine entsprechende Kategorie als
  Zeichenkette zurückgibt.  Verwende die Konstruktionsanleitungen:
  Schreibe die Kurzbeschreibung auf, führe eine
  Datenanalyse durch und schreibe die Signatur auf. Erstelle
  dann die Testfälle und das Gerüst.  Vervollständige danach den
  Rumpf der Funktion und vergewissere Dich, dass die Tests
  erfolgreich laufen. \\

  \begin{tabular}{crlcrll}
    &        & Umsatz & $<$ & $15.000$   & $\Longrightarrow$ & Weiß \\
    $15.000$  & $\leq$ & Umsatz & $<$ & $50.000 $  & $\Longrightarrow$ & Gold \\
    $50.000$  & $\leq$ & Umsatz & $\leq$ & $150.000 $ 
    & $\Longrightarrow$ & Platin \\
    $150.000$ & $<$ & Umsatz &     &            &  $\Longrightarrow$ & Schwarz \\
  \end{tabular} \\
\end{aufgabe}

\begin{aufgabe}

  \begin{enumerate}

  \item Schreibe eine Funktion \texttt{min-2}, die als Argumente zwei
    Zahlen nimmt und die kleinere der beiden Zahlen zurückgibt.  Schreibe
    außerdem eine Funktion \texttt{min-3}, die als Argumente drei
    Zahlen nimmt und die kleinste der drei Zahlen zurückgibt.  Verwende
    die Konstruktionsanleitung: Schreibe
    explizit Kurzbeschreibung und Signatur auf, erstelle dann das
    Gerüst und die Testfälle.  Vervollständige danach den Rumpf der
    Funktion und vergewissere Dich, dass die Tests erfolgreich laufen.
    
  \item Schreibe analog eine Funktion \texttt{max-2} und \texttt{max-3}.
    
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Schreibe die folgenden Funktionen:
  \begin{enumerate}
  \item \texttt{min-of-two}, welche die kleinere von zwei
    gegebenen Zahlen ausgibt
  \item \texttt{min-of-three}, welche die kleinste von drei
    gegebenen Zahlen ausgibt
  \item \texttt{is-min-of-three?}, die überprüft ob die erste
    von drei gegebenen Zahlen das Minimum ist
  \item \texttt{valid-value?}, die überprüft ob die erste von
    drei gegebenen Zahlen zwischen den beiden anderen liegt; gehe
    davon aus, dass der Aufruf immer \texttt{(valid-value? value min max)}
    lautet 
  \item \texttt{clamp}, die wie folgt definiert ist:
    
    \[\mathit{clamp}(x,\ \mathit{min},\ \mathit{max})=
    \begin{cases} 
      x & \mathit{min} \leq x \leq \mathit{max}\\ 
      \mathit{min} & x < \mathit{min} \\ 
      \mathit{max} & x > \mathit{max}
    \end{cases}
    \]
    
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Beim Fußball lässt die Rückennummer einer Spielerin
  häufig Rückschlüsse auf ihre Position zu. Wir machen dabei folgende
  Annahmen:
  \begin{itemize}
  \item Ein \emph{Torwärtin} hat die Rückennummer 1.
  \item Ein \emph{Abwehrspielerin} hat die Rückennummer 2, 3, 4 oder 5.
  \item Ein \emph{Mittelfeldspielerin} hat die Rückennummer 6, 7, 8 oder 10.
  \item Ein \emph{Stürmerin} hat die Rückennummer 9 oder 11.
  \item Ein \emph{Ersatzspielerin} hat eine Rückennummer zwischen 12 und 99.
  \item Alle anderen Rückennummern sind ungültig.
  \end{itemize}
  %
  Schreibe zunächst eine Datendefinition für Positionen und dann eine
  passende Signaturdefinition mit dem Namen \texttt{position}.
  
  Schreibe nun eine Funktion mit folgender Signatur:
  %
\begin{verbatim}
 (: nummer->position (natural -> position))
\end{verbatim}
  %
  Die Funktion soll dabei zu einer gegebenen Rückennummer die
  zugehörige Position berechnen.

  Verwende beim Schreiben der Funktion die
  Konstruktionsanleitungen für Funktionen und für
  Fallunterscheidungen.  Teste die Funktion
  \texttt{nummer->position} mit mindestens sechs Testfällen, so dass
  alle Fälle abgedeckt sind.
\end{aufgabe}


\begin{aufgabe}
  Schreibe ein Programm, mit dem Bußgelder
  automatisch bestimmt werden.
  
  \begin{enumerate}
  \item Programmiere eine Funktion \texttt{zu-langes-parken}
    für die Bewertung von zu langem Parken auf einem kostenpflichtigen
    Parkplatz. Diese bekommt eine Zeitspanne übergeben und gibt das 
    entsprechende Verwarngeld zurück.
    
    Diese Verwarnungen sind wie folgt festgelegt:
    \begin{flushleft}
      \begin{tabular}{rl}
    Überschreitung der Höchstparkdauer bis 30 Minuten & \euro{5}\\
%%% Ich denke, das führt zu normenungerechten Schreibweisen. In
%%% Deutschland schreiben wir, glaube ich, 5 € und nicht €5
    bis zu einer Stunde & \euro{10}\\
    bis zu zwei Stunden & \euro{15}\\
    bis zu drei Stunden & \euro{20}\\
    länger als drei Stunden &  \euro{25}
      \end{tabular}
    \end{flushleft}
    
  \item Das Überfahren einer roten Ampel kostet je nach
    Gefährdungslage mehr, gibt Punkte und Fahrverbote. Schreibe
    zwei Funktionen, eine für das Bußgeld \texttt{rote-ampel-bußgeld}, 
    eine für die Punkte in Flensburg \texttt{rote"=ampel"=punkte} 
    und eine für das Fahrverbot \texttt{rote"=ampel"=fahrverbot}, 
    welche ausgibt, ob ein Fahrverbot erteilt wird. Übergib
    den Funktionen, wie lange die Ampel schon rot war und ob eine
    Gefährdung oder Sachbeschädigung vorlag.
    
    Die Bußgelder sind wie folgend definiert:
    \begin{itemize}
    \item Bei Rot über die Ampel innerhalb der ersten Sekunde			
      \euro{50} und 3 Punkte.
    \item Bei Rot über die Ampel innerhalb der ersten Sekunde mit
      Gefährdung oder Sachbeschädigung \euro{125}, 4 		
      Punkte und 1 Monat Fahrverbot.
    \item Bei Rot über die Ampel nach der ersten Sekunde \euro{125},
      4 Punkte und 1 Monat Fahrverbot.
    \item Bei Rot über die Ampel nach der ersten Sekunde mit
      Gefährdung oder Sachbeschädigung \euro{200}, 4
      Punkte und 1 Monat Fahrverbot.
    \end{itemize}
    
    
  \end{enumerate}
\end{aufgabe}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
