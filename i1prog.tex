% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung 4.0 International (CC BY 4.0)"
% http://creativecommons.org/licenses/by/4.0/deed.de

\chapter{Elemente des Programmierens}
\label{cha:whats-programming}

Dieses Kapitel gibt einen Überblick über das wichtigste Handwerkszeug
des Programmierens: Welche Software Du dafür brauchst, wie Du diese
Software bedienst, wie kleine Programme aussehen und aus was für
Elementen sie bestehen.

\section{DrRacket}

Zunächst einmal benötigst Du die Software \textit{Racket}\index{Racket}, die es zum
kostenlosen Download auf der Seite \url{https://racket-lang.org/} für
alle gängingen Plattformen gibt.  Auf der Seite ist ein
\texttt{Download}-Knopf~-- folge den dortigen Instruktionen für die
Installation.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-start}
  \caption{DrRacket nach dem ersten Start}
  \label{fig:drracket-start}
\end{figure}

Zu Racket gehört ein Programm namens
\textit{DrRacket}\index{DrRacket}: starte es.  Es erscheint ein
Fenster, das ungefähr so aussehen sollte wie in
Abbildung~\ref{fig:drracket-start}.  Die Benutzeroberfläche kannst
Du auf Deutsch umstellen, indem Du im Hilfe-Menü auf \texttt{Deutsche
  Benutzeroberfläche für DrRacket} drückst.  Wenn Du die Auswahl
bestätigst, wird DrRacket danach beendet und Du musst es noch einmal
starten; dann sollten die Menüs auf Deutsch sein.

DrRacket ist eine \textit{Entwicklungsumgebung}, mit der Du Programme
schreiben und ausführen kannst.  DrRacket unterstützt nicht nur eine
Programmiersprache, darum musst Du die richtige Programmiersprache für
dieses Buch noch auswählen.  Dazu wählst Du den Menüpunkt
\texttt{Sprache $\rightarrow$ Sprache auswählen} (bzw.\
\texttt{Language $\rightarrow$ Choose language} in der englischen
Fassung), worauf ein Dialog erscheint.  In dem Dialog gibt es eine
Abteilung \texttt{Lehrsprachen\index{Lehrsprachen}}, und darunter eine
Überschrift namens \texttt{DeinProgramm}, unterhalb dessen mehrere
Einträge erscheinen, die speziell auf die Kapitel dieses Buchs
zugeschnitten sind.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-deinprogramm}
  \caption{DrRacket mit ausgewählter Lehrsprache}
  \label{fig:drracket-deinprogramm}
\end{figure}

Für den ersten Teil des Buches ist die Ebene \texttt{Schreibe Dein
  Programm! - Anfänger} zuständig:\index{Sprachebene!Anfänger} Wähle
diese aus und drücke dann einmal oben rechts auf den Knopf
\texttt{Start} (bzw.\ \texttt{Run}), damit die Auswahl aktiv wird.
Das Ergebnis sollte dann so aussehen wie in
Abbildung~\ref{fig:drracket-deinprogramm}.

Das DrRacket-Fenster besteht aus zwei Teilen:
%
\begin{enumerate}
\item In der oberen Hälfte des Fensters (dem
  \textit{Editor\index{Editor}} oder
  \textit{Definitionsfenster\index{Definitionsfenster}}) steht der
  Programmtext.  Der Editor funktioniert ähnlich wie ein reguläres
  Textverarbeitungsprogramm.  Was dort steht, kannst Du abspeichern.
\item In der unteren Hälfte des Fensters~-- dem
  \textit{Interaktionsfenster\index{Interaktionsfenster}} oder der
  sogenannten \textit{REPL\index{REPL}}\footnote{"`REPL"' steht für
    "`Read-Eval-Print-Loop"'~-- wir werden später zeigen, warum.}
  werden die Ausgaben des Programms angezeigt.  Außerdem kannst Du
  hier "`Fragen"' an das Programm stellen, um einzelne Programmteile
  gezielt auszuprobieren.
\end{enumerate}
%

\section{Ausdrücke und die REPL}

Fangen wir mit der REPL an: Wenn Du gerade \texttt{Start} gedrückt
hast, dann erscheint der Cursor rechts von dem \verb|>|-Zeichen: Du
kannst da etwas eingeben und Return drücken~-- DrRacket zeigt dann
das Ergebnis darunter an.

Wenn Du zum Beispiel \texttt{123} eintippst, zeigt DrRacket gleich
darunter 123 an.  DrRacket kann auch rechnen.  Dafür musst Du
allerdings die Rechenaufgaben etwas anders aufschreiben als sonst.
Zum Beispiel so:
%
\begin{verbatim}
(+ 123 42)
\end{verbatim}
%
Wenn Du das in die REPL tippst, zeigt DrRacket \texttt{165} an, die
\textit{Summe}\index{Summe} von 123 und 42.  Diese "`Rechenaufgabe"'
ist ein sogenannter \textit{Ausdruck\index{Ausdruck}}.  Ausdrücke, die
etwas ausrechnen sollten, haben in den Lehrsprachen immer die gleiche
Form, und die sieht so aus:
%
\begin{alltt}
(\textnormal{\textit{Operator}} \textnormal{\textit{Operand}} \ldots)
\end{alltt}
%
Das heißt, da stehen \emph{immer} Klammern\index{Klammer} drumherum
(und die können auch nirgendwo sonst stehen).  Dann steht da der
\textit{Operator\index{Operator}}, der bestimmt, \emph{was} gemacht
wird, also die \textit{Operation}.  Danach kommen die
\textit{Operanden\index{Operand}}, welche die Eingaben\index{Eingabe}
für die Operation bestimmen.

Zum Merken ist es hilfreich, Ausdrücke entsprechend vorzulesen: Also
nicht mehr "`Hundertdreiundzwanzig plus zweiundvierzig"', sondern
"`die \emph{Summe} von Hundertdreiundzwanzig und zweiundvierzig"'.

Wie schon gesagt, die Klammern sind wichtig.  Wenn Du sie vergisst,
können verwirrende Ergebnisse herauskommen.  Wenn Du zum Beispiel
\texttt{+ 123 42} in der REPL eintippst, sieht das so aus:
%
\begin{alltt}
> + {\color{green}123 42}
{\color{blue}#<function:+>
123
42}
\end{alltt}
%
Das liegt daran, dass ohne Klammern \texttt{+ 123 32} aus \emph{drei}
Ausdrücken besteht und die REPL darum auch drei Ergebnisse ausdruckt:
Die Funktion \texttt{+}, dann die \texttt{123}, dann \texttt{42}.
(Die Operation \texttt{+} ist eine sogenannte Funktion ist~-- das
erläutern wir später noch genauer.)  Ähnlich verhält es sich mit
\texttt{123 + 42}~-- probiere es aus!

Wenn Du versehentlich den Operator dazwischen schreibst, erscheint
in der REPL eine Fehlermeldung:
%
\begin{alltt}
> ({\color{green}123} + {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Etwas ähnliches passiert, wenn Du kein Leerzeichen zwischen den
Operator und die Operanden oder zwischen die Operanden setzt.  Das
sieht zum Beispiel so aus:
%
\begin{alltt}
> ({\color{green}+123} {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Das liegt daran, dass \texttt{+123} zusammen die Zahl "`plus
hundertdreiundzwanzig"' bildet und nicht etwa in das \texttt{+} und
\texttt{123} aufgeteilt wird.

Wenn ein Ausdruck wie \texttt{(+ 123 42)} ein Ergebnis wie 165 hat,
schreiben wir das im Buch zukünftig so, etwas anders als die
DrRacket-REPL:
%
\begin{alltt}
(+ 123 42)
\evalsto{} 165
\end{alltt}
%
Es gehen natürlich nicht nur Summen, sonderen auch Differenzen,
Produkte und Quotienten:
%
\begin{alltt}
(- 123 42)
\evalsto{} 81
(* 123 42)
\evalsto{} 5166
(/ 123 42)
2.9\(\overline{\mathtt{285714}}\)
\end{alltt}
%
Beim letzen Ausdruck ist zu sehen, dass Dezimalzahlen mit Punkt und
nicht mit Komma geschrieben werden.  Der Überstrich bei
\texttt{2.9\(\overline{\mathtt{285714}}\)} ist eine
\textit{Periode\index{Periode}}: die Zahl ist also eigentlich
%
\begin{alltt}
2.9285714285714285714285714285714\ldots
\end{alltt}
%
Die REPL funktioniert also folgendermaßen: Sie \emph{liest} einen
Ausdruck ein ("`read"'), berechnet deren Wert oder \emph{wertet}
diesen \emph{aus} (auf Englisch "`eval"') und zeigt das Ergebnis an
oder \emph{druckt} dieses \emph{aus} ("`print"')~-- und dann geht es
von vorn los, wie in einer Schleife ("`loop"').  Die Abfolge
\emph{Read-Eval-Print-Loop} gibt der REPL ihren Namen.

Ausdrücke können auch kombiniert werden, zum Beispiel so:
%
\begin{alltt}
(* 123 (+ 20 22))
\evalsto{} 5166
(* 123 (+ (* 2 10) 22))
\evalsto{} 5166
\end{alltt}
%
Bei der Kombination ist wichtig, dass um jeden Teilausdruck wieder ein
Klammernpaar kommt.  Ist das nicht der Fall, erscheinen gelegentlich
auch mal englischsprachige Fehlermeldungen wie diese hier:
%
\begin{alltt}
(* 123 (+ * 2 10 22))
{\color{red}+: expects a number as 1st argument, given #<function:*>}
\end{alltt}
%
Das liegt daran, dass das \texttt{*} hier an der Stelle eines
Operanden für die Summe dient.  Ein anderes Wort für Operand in diesem
Zusammenhang ist \textit{Operand}, darum steht da sinngemäß, dass
\texttt{+} eine Zahl als ersten Operanden erwartet, aber
stattdessen die Funktion \texttt{+} bekommen hat.

Ein hilfreicher Trick übrigens: Um einen Ausdruck zu korrigieren,
kannst Du ihn in der REPL "`zurückholen"', indem Du \texttt{Esc}, und
dann \texttt{P} drückst~-- probier es aus!

\begin{aufgabe}
  Schreibe folgende "`mathematischen"' Ausdrücke in der Notation der
  Lehrsprache in die REPL und lasse die REPL sie auswerten:
  %
  \begin{displaymath}
    \begin{array}{c}
      55 * 27\\
      23 * (44 + 27)\\
      \frac{23}{44} + \frac{44}{23}\\
      (23 + 42) * (12 + (14 * 2))
    \end{array}
  \end{displaymath}
\end{aufgabe}
%
Ein weiterer praktischer Trick ist, dass Du einen geklammerten
Ausdruck markieren (und dann ausschneiden) kannst, indem Du auf die
öffnende oder schließende Klammer doppelt klickst.

\section{Das Definitionsfenster}

Kommen wir zum Definitionsfenster oben.  Dort schreibst Du Dein
Programm, die REPL kannst Du dann benutzen, um es auszuprobieren.
Schreib in das Definitionsfenster folgende
\textit{Definition\index{Definition}}:
%
\begin{verbatim}
(define alles (+ 20 22))
\end{verbatim}
%
Diese Definition besagt, dass der Name \texttt{alles} für das Ergebnis
von \texttt{(+ 20 22)} steht.  Um das auszuprobieren, drück auf den
Knopf \texttt{Start} bzw.\ \texttt{Run} rechts oben.  Der Cursor
landet dann wieder in der REPL, wo Du das Programm ausprobieren
kannst:
%
\begin{alltt}
alles
\evalsto{} 42
\end{alltt}
%
Ein Name, der in einem Programm so definiert ist, heißt
\textit{Variable\index{Variable}}.

Hier sind ein paar weitere Beispiele für Definitionen:
%
\begin{alltt}
(define one 1)
(define temperature 23)
(define birgit-prinz 9)
(define michael-ballack 13)
\end{alltt}
%
Bei der Gestaltung eines Namens gibt es weitgehende
Freiheiten.\footnote{Anders als in anderen Programmiersprachen sind
  auch Bindestriche in Namen möglich.}  Nur Leerzeichen sind nicht
erlaubt.

In einem Programm kannst Du Zeilenumbrüche und Einrückung benutzen, um
Dein Programm übersichtlicher zu gestalten.  Zum Beispiel kannst Du
nach \texttt{alles} die Return-Taste drücken, das Ergebnis sieht so
aus:
%
\begin{alltt}
(define alles
  (+ 20 22))
\end{alltt}
%
DrRacket rückt die zweite Zeile ein bisschen ein, um auszudrücken,
dass sie noch in die Klammern vom \texttt{define} gehört.  Bei
komplizierteren Ausdrücken ist das hilfreich:
%
\begin{verbatim}
(define alles
  (+ 20
     (* 11 2)))
\end{verbatim}
%
Hier stellt DrRacket die Operanden der Summe genau untereinander.
DrRacket zwingt Dich nicht, die Einrückung genau so zu machen, und
durch Änderungen im Programm gerät sie auch manchmal aus dem Lot.  In
dem Fall kannst Du die Tab-Taste drücken (auf den meisten Tastaturen
steht $\longrightarrow\mid$ auf der Tab-Taste) und in der Zeile, in
welcher der Cursor steht, wird die Einrückung korrigiert.  Es gibt
einen Menüunkt \texttt{Racket $\rightarrow$ Alles einrücken} (bzw.\
\texttt{Racket $\rightarrow$ Reindent All}), der das für das gesamte
Programm macht: Probier es aus!

\begin{aufgabe}
  Bring bei einem mehrzahligen Programm die Einrückung richtig
  durcheinander, zum Beispiel so:
\begin{verbatim}
(define nr
  (+ 12
 (- (* 42
  13)
    500)))
\end{verbatim}
  %
  Benutze dann die Tab-Taste, um die Einrückung wieder zu korrigieren.
\end{aufgabe}
%
Den Inhalt des Definitionsfenster kannst Du abspeichern, indem Du auf
den Knopf mit der Diskette
\raisebox{-1ex}{\includegraphics[height=12pt]{i1prog/save}} drückst.

Abspeichern geht mit der REPL nicht, und der REPL-Inhalt verschwindet
auch jedesmal, wenn Du \texttt{Start} bzw.\ \texttt{Run} drückst.  Du
kannst aber frühere Eingaben zurückholen, indem Du \texttt{Esc~P}
drückst.

\section{Rechnen ohne Zahlen}

Computerprogramme können nicht nur mit Zahlen rechnen.  In diesem
Abschnitt geht es um das Rechnen mit Text und das Rechnen mit Bildern.

\subsection{Rechnen mit Zeichenketten}

Zum Beispiel gibt es auch Text, der in einem Programm immer von
doppelten Anführungszeichen umschlossen ist, zum Beispiel:
%
\begin{alltt}
"Mike Sperber"
"Herbert Klaeren"
"Schreibe Dein Programm!"
\end{alltt}
%
Diese Werte heißen \textit{Zeichenketten\index{Zeichenkette}}.

Die einfachste Art, eine Zeichenkette herzustellen, ist, die
Buchstaben hinzuschreiben, aus denen sie besteht.  Die
Anführungszeichen müssen drumherum, um die Zeichenketten von anderen
Ausdrücken zu unterscheiden.  Die Anführungszeichen gehören aber nicht
zu den Buchstaben dazu, aus denen die Zeichenkette besteht~--
\verb|"abc"| besteht aus den drei Buchstaben \texttt{abc}.

\begin{feature}{Zeichenketten}{scheme:strings}
\textit{Zeichenketten\index{Zeichenkette}} (auf Englisch
\textit{Strings}\index{String}) repräsentieren Text.
Literale für Zeichenketten haben folgende Form:
%
\begin{alltt}
"\(z\sb{1}\)\(z\sb{2}\) \(\ldots\) \(z\sb{n}\)"
\end{alltt}
%
Dabei sind die \(z\sb{i}\) beliebige einzelne Zeichen, außer \verb|"| selbst.
Beispiel:
%
\begin{alltt}
"Herbert was here!"
\end{alltt}
%
Das Anführungszeichen (\verb|"|) kann nicht "`ungeschützt"' vorkommen, da es das Ende der
Zeichenkette markiert. Es wird als Zeichen innerhalb einer Zeichenkette
durch \verb|\"| dargestellt:
%
\begin{alltt}
"Herbert sagt, Mike wäre \backwhack{}"doof\backwhack{}"!"
\end{alltt}
\end{feature}

Abbildung~\ref{scheme:strings} beschreibt die genaue Schreibweise für
solche "`festen"' Zeichenketten.  Feste Schreibweisen für Werte heißen
allgemein \textit{Literale\index{Literal}}.  Das kennen wir schon von
den Zahlen: die Zeichenfolge \texttt{123} steht für die Zahl
"`hundertdreiundzwanzig"'.  Kästen wie Abbildung~\ref{scheme:strings}
werden in diesem Buch noch oft dazu dienen, neue Sprachelemente
einzuführen.

Mit Text kann ein Programm auch rechnen, und zwar mit der eingebauten
Funktion
\texttt{string"=append}\index{string-append@\texttt{string-append}},
die zwei Zeichenketten aneinanderhängt:
%
\begin{alltt}
(string-append "Herbert" "Mike")
\evalsto{} "HerbertMike"
(string-append "Mike" " " "ist doof")
\evalsto{} "Mike ist doof"
\end{alltt}
%
Die eingebaute Funktion
\texttt{string-length}\index{string-length@\texttt{string-length}}
liefert die Anzahl der Buchstaben in einer Zeichenkette:
%
\begin{alltt}
(string-length "Herbert")
\evalsto{} 7
(string-length "Mike")
\evalsto{} 4
\end{alltt}
%
Die Namen \texttt{string-append} und \texttt{string-length} sehen auf
den ersten Blick "`anders"' aus als \texttt{+} und \texttt{*} zum
Beispiel, dieser Eindruck täuscht jedoch: Sie sind allesamt Namen von
vordefinierten Operationen, die Programme benutzen können, oder sie
selbst definieren zu müssen.

Die vordefinierten Funktionen
\texttt{string->number}\index{string->number@\texttt{string->number}}
und \texttt{number->string} konvertieren zwischen Zahlen und den
Zeichenketten, die diese darstellen:
%
\begin{alltt}
(string->number "23")
\evalsto{} 23
(number->string 23)
\evalsto{} "23"
\end{alltt}
%
\begin{aufgabe}
  Mache Dir den Unterschied zwischen der Zahl \texttt{23} und der
  Zeichenkette \verb|"23"|.  Probiere zum Beispiel aus:
\begin{alltt}
(+ "23" 42)
(string-append 23 "42")
(number->string "23")
\end{alltt}
\end{aufgabe}

\subsection{Rechnen mit Bildern}

Programme können auch mit Bildern rechnen.  Dazu wird eine Erweiterung
zu DrRacket benötigt, ein sogenanntes
\textit{Teachpack}\index{Teachpack}: Wähle dazu den Menüpunkt
\texttt{Sprache $\rightarrow$ Teachpack hinzufügen}.  (Beziehungsweise
\texttt{Language $\rightarrow$ Add Teachpack}.  In dem Dialog, der
dann erscheint, wähle \texttt{image.rkt} aus und drücke dann
\texttt{OK}.

Das Teachpack \texttt{image.rkt} enthält zusätzliche vordefinierte
Funktionen, mit denen wir Bilder herstellen können.  Zum Beispiel
\texttt{square}, \texttt{circle} und \texttt{star-polygon}:
%
\begin{alltt}
(square 40 "solid" "red")
\evalsto{} \includegraphics[height=24pt]{i1prog/square}
(circle 40 "solid" "green")
\evalsto{} \includegraphics[height=24pt]{i1prog/circle}
(star-polygon 20 10 3 "solid" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon}
\end{alltt}
%
Schauen wir uns das eingebaute \texttt{star-polygon} etwas näher an:
Es akzeptiert fünf Eingaben, die ersten drei davon sind Zahlen~-- die
Seitenlänge, die Seitenanzahl und die Anzahl der Ecken, die für jede
Seite übersprungen werden.  Danach kommen zwei Zeichenketten~--
\verb|"solid"| heißt, dass das Innere des Sterns ausgefüllt ist und
\verb|"blue"| ist die Farbe.  Statt \verb|"solid"| kannst Du auch
\verb|"outline"| schreiben, dann wird auch etwas klarer, was
"`überspringen"' heißt:
%
% filename can't contain hyphen because of alltt
\begin{alltt}
(star-polygon 20 10 3 "outline" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon_outline}
\end{alltt}
%
\begin{aufgabe}
  Wofür stehen die Zahleneingaben bei \texttt{square} und
  \texttt{circle}?  Probiere unterschiedliche Zahlen aus!  Es gibt
  auch eine eingebaute Funktion \texttt{rectangle}.  Kannst Du ein
  funktionierendes Beispiel für den Einsatz von \texttt{rectangle}
  konstruieren?  Außerdem gibt es eine eingebaute Funktion
  \texttt{ellipse}, die genauso benutzt wird wie \texttt{rectangle}~--
  probiere sie aus!
\end{aufgabe}
%
Bilder sind Werte wie Zahlen und Zeichenketten auch.  Du kannst
Definitionen auch Namen dafür vergeben:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))
\end{verbatim}
%
\begin{aufgabe}
  Du kannst auch Bilddateien oder Bilder in Webseiten in Dein Programm
  einfügen, wie in einem Textverarbeitsprogramm.  Probier es aus und
  gib dem Bild einen Namen!
\end{aufgabe}

%
Mit Bildern kann DrRacket auch rechnen:
%
\begin{alltt}
(beside s1 p1)
\evalsto{} \includegraphics[height=24pt]{i1prog/beside.png}
(above s1 c1)
\evalsto{} \includegraphics[width=24pt]{i1prog/above.png}
(above (beside s1 p1) (beside p1 c1))
\evalsto{} \includegraphics[width=48pt]{i1prog/abovebeside.png}
\end{alltt}              
%
Das heißt, \texttt{beside} akzeptiert als Eingabe zwei (oder mehr)
Bilder und macht daraus wieder ein Bild, in dem die Teilbilder
nebeneinander stehen.  Das gleiche gilt für \texttt{above}, nur dass
die Bilder übereinander angeordnet werden.  Selbstverständlich können
\texttt{above} und \texttt{beside} auch kombiniert werden.

\section{Die Macht der Abstraktion}

Hier sind zwei Ausdrücke, welche die Bilder aus dem vorigen Abschnitt
zu einem Muster kombinieren:
%
\begin{alltt}
(above
 (beside s1 p1)
 (beside p1 s1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(above
 (beside p1 c1)
 (beside c1 p1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Beide Ausdrücke folgen dem gleichen Muster, sie "`kacheln"' jeweils zwei
Bilder in einer quadratischen Anordnung.  Das Muster könnte man so
hinschreiben:
%
\begin{verbatim}
(above
 (beside a b)
 (beside b a))
\end{verbatim}
%
Das erste Beispiel entsteht dann, indem für \texttt{a} \texttt{s1}
eingesetzt wird und für \texttt{b} \texttt{p1}, im zweiten für \texttt{a}
\texttt{p1} und für \texttt{b} dann \texttt{c1}.

Dieses Muster kannst Du in ein Programm gießen.  Dann müssen wir nicht
jedesmal \texttt{above \ldots{} beside \ldots{} beside} eintippen.
Dazu schreibst Du es erst einmal genauso hin, also mit \texttt{a} und
\texttt{b}.  Wenn Du das Programm startet, erscheint folgende Meldung:
%
\begin{alltt}
\color{red}a: Ungebundene Variable
\end{alltt}
%
Na klar, es gibt ja auch keine Definition für \texttt{a}.  Du könntest
eine hinschreiben, zum Beispiel:
%
\begin{verbatim}
(define a s1)
\end{verbatim}
%
Aber dann wäre \texttt{a} auf \texttt{s1} festgelegt.  Wir wollen
stattdessen das Muster verallgemeinern, so dass Du es mehrmals mit
unterschiedlichen Werten für \texttt{a} und \texttt{b} verwenden
kannst.  Dieser Verallgemeinerungsprozess heißt beim Programmieren
\textit{Abstraktion\index{Abstraktion}}.  Dafür müssen wir dem Muster
noch etwas hinzufügen, um zu sagen, dass wir unterschiedliche Werte
für \texttt{a} und \texttt{b} einsetzen wollen:
%
\begin{verbatim}
(lambda (a b)
  (above
   (beside a b)
   (beside b a)))
\end{verbatim}
%
Die \texttt{lambda}\index{lambda@\texttt{lambda}} ist eine Art Zauberwort, es sagt soviel wie: "`Für
die Variablen \texttt{a} und \texttt{b} möchte ich später (und
vielleicht mehrmals) Werte einsetzen."'  Wenn Du das Programm jetzt
startest, geht die Fehlermeldung weg und in der REPL erscheint:
%
\begin{alltt}
#<function:\ldots>
\end{alltt}
%
(Der Text anstelle des \ldots{} variiert etwas von Fall zu Fall.)

Das deutet darauf hin, dass bei dem \texttt{lambda} eine Funktion
herauskommt.  Um etwas damit anfzufangen, gib ihr einen Namen mit
\texttt{define}:
%
\begin{verbatim}
(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))
\end{verbatim}
%
(Alles schön richtig einrücken! "`Tile"' heißt auf Deutsch
"`kacheln"'.)

Dadurch ist eine neue Operation entstanden.  Die kannst Du direkt
verwenden:
%
\begin{alltt}
(tile s1 p1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(tile p1 c1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Was ist da passiert?  Am einfachsten kann man das in einem speziellen
Werkzeug sehen, dem \textit{Stepper\index{Stepper}}.  Um ihn zum
Einsatz zu bringen, sorge dafür, dass im Definitionsfenster folgendes
Programm steht, also das, was weiter oben schon steht:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))

(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))

(tile s1 p1)
(tile p1 c1)
\end{verbatim}
%
Dann drück auf den \texttt{Stepper}-Knopf oben rechts im
DrRacket-Fenster.  Es erscheint ein neues Fenster, das so aussieht:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{i1prog/stepper-0}
  \caption{Der Stepper in Aktion}
  \label{fig:stepper-0}
\end{figure}
%
\noindent Du kannst jetzt mit den Knöpfen mit dem Vorwärts- beziehungsweise dem
Rückwärts-Pfeil zusehen, wie DrRacket Dein Programm ausführt.  Wenn Du
ein paar Schritte vorwärts gehst, sieht das so aus:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-1}
  \caption{Stepper: Variable ersetzen}
  \label{fig:stepper-1}
\end{figure}
%
\noindent Du kannst sehen, wie DrRacket jeweils einen Ausdruck einen Schritt auf
einmal auswertet~-- der ist auf der linken Seite grün~-- und dann
rechts durch das Resultat ersetzt.  Oben kannst Du sehen, wie der
Stepper die Variable \texttt{tile} durch den \texttt{lambda}-Ausdruck
aus der Definition von \texttt{tile} ersetzt. Das macht der Stepper
auch mit den Definitionen von \texttt{s1} und \texttt{p1}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-2}
  \caption{Stepper: Variable}
  \label{fig:stepper-2}
\end{figure}
%
\noindent Interessant wird es danach: Die Variablen aus den Definitionen sind
alle ersetzt.  Hinter dem \texttt{lambda}-Ausdruck stehen jetzt das
Quadrat und der Stern, und die werden jetzt für die Variablen aus dem
\texttt{lambda}-Ausdruck eingesetzt, also das Quadrat für \texttt{a}
und der Stern für \texttt{b}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-3}
  \caption{Der Stepper in Aktion}
  \label{fig:stepper-3}
\end{figure}
%
\noindent Dabei verschwindet auch das \texttt{lambda}.
%
\begin{aufgabe}
  Probiere das Beispiel im Stepper aus und klicke Dich bis zum Ende
  durch. Mache Dir dabei klar, wie jeweils die linke mit der rechten
  Seite zusammenhängt.
\end{aufgabe}
%

\begin{feature}{Abstraktion und Anwendung}{scheme:abstraction}
  Eine Abstraktion\index{Abstraktion} hat folgende Form:
\begin{alltt}
(lambda (\(p\sb{1} \ldots p\sb{n}\)) \(e\))
\end{alltt}
  %
  Die $p_i$ sind jeweils Namen, die \textit{Parameter}\index{Parameter}, und
  $e$ ist der \textit{Rumpf}\index{Rumpf}.  In $e$ dürfen die $p_i$
  vorkommen.  Der Wert einer Abstraktion ist eine \textit{Funktion}\index{Funktion},
  welche für jeden Parameter eine Eingabe erwartet.

  Eine \textit{Anwendung} einer Funktion hat folgende Form:
  %
\begin{alltt}
(\(p\) \(a\sb{1}\) \ldots \(a\sb{n}\))
\end{alltt}
  %
  $p$ ist ein Ausdruck, der eine Prozedur ergeben muß, die $a_i$ sind
  ebenfalls Ausdrücke, die \textit{Argumente}\index{Argument}.  Bei
  der Auswertung einer Anwendung werden zunächst $p$ und die $a_i$
  ausgewertet; danach geht es mit der Auswertung des Rumpfes der
  Prozedur weiter, wobei für die Parameter $p_i$ jeweils die Werte der
  Argumente $a_i$ eingesetzt werden.
\end{feature}


\section{Information und Daten}

Eine Definition wie
%
\begin{alltt}
(define mehrwertsteuer 19)
\end{alltt}
%
suggeriert, dass die Zahl 19 an dieser Stelle eine Bedeutung "`in der
realen Welt"' hat, zum Beispiel in einem Programm, das eine Registrierkasse
steuert oder das bei der Steuererklärung hilft.  Die Bedeutung könnte
folgende Aussage sein: "`Der Mehrwertsteuersatz beträgt 19\%."'
Dieser Satz repräsentiert \textit{Information}\index{Information},
also einen Fakt über die Welt oder zumindest den Ausschnitt der Welt, in
dem das Programm arbeiten soll.  In Computerprogrammen wird
Information in eine vereinfachte Form gebracht, mit der das Programm
rechnen kann~-- in diesem Fall die Zahl 19.  Diese vereinfachte Form
heißt \textit{Daten}\index{Daten}: Daten sind
\textit{Repräsentationen}\index{Repräsentation} für Information.
Beim Programmieren ist eine
unserer Hauptaufgaben entsprechend, die richtigen Form für die Daten
zu wählen, um die für das Programm relevanten Informationen
darzustellen die Informationen dann in Daten zu übersetzen.

Nicht immer ist offensichtlich, welche Information durch bestimmte
Daten repräsentiert werden.  Das Datum 23 zum Beispiel könnte eine Reihe
von Informationen darstellen:
%
\begin{itemize}
\item die Anzahl der Haare von Bruce Willis
\item die aktuelle Außentemperatur in °C in Tübingen
\item die Außentemperatur vom 1.7.2000 in °C in Tübingen
\item die Größe in m$^2$ des Schlafzimmers
\item die Rückennummer von Michael Jordan
\end{itemize}
%
Damit andere unsere Programme lesen können, werden wir also immer
wieder klarstellen müssen, wie Information in Daten zu übersetzen ist
und umgekehrt.

Manche Programme können auch Informationen direkt verarbeiten, meist
dadurch, dass sie diese erst in Daten übersetzen und dann die Daten
weiterverarbeiten.  Der Teil, der diese Übersetzung leistet, heißt
\textit{Benutzerschnittstelle}\index{Benutzerschnittstelle}.  Zunächst
werden wir uns allerdings primär mit rein datenverarbeitenden
Programmen beschäftigen; Benutzerschnittstellen kommen später.

\section{Domänenwissen}
\label{sec:domaenenwissen}

Hier ist eine einfache Denksportaufgabe:
%
\begin{quote}
  Auf einem Parkplatz stehen PKWs und Motorräder ohne Beiwagen.
  Zusammen seien es $n$ Fahrzeuge mit insgesamt $m$ Rädern.  Bestimmen
  Sie die Anzahl $P$ der PKWs.
\end{quote}
%
Die Anzahl $P$ der PKWs plus die Anzahl $M$ der Motorräder muß
offensichtlich die Gesamtzahl $n$ der Fahrzeuge ergeben.  Außerdem hat
jeder PKW vier Räder und jedes Motorrad zwei Räder. Die Radzahlen der
PKWs und Motorräder zusammen müssen $m$ ergeben.  Es ergibt sich
folgendes Gleichungsystem:
%
\begin{eqnarray*}
  P+M&=&n\\
  4P+2M&=&m
\end{eqnarray*}
%
Auflösen der ersten Gleichung nach $M$ ergibt
\begin{eqnarray*}
  M &=& n-P
\end{eqnarray*}
% 
und Einsetzen in die zweite Gleichung führt zu
\begin{eqnarray*}
  4P+2(n-P) &=& m\\
  4P+2n-2P &=& m\\
  2P &=& m-2n\\
  P &=& \frac{m-2n}{2}
\end{eqnarray*}
%
Am Ende steht also eine Formel, die wir für konkrete $m$ und $n$ auch
in einen Ausdruck verwandeln können:
%
\begin{alltt}
(/ (- 10 (* 2 4)) 2)
\evalsto{} 1
(/ (- 12 (* 2 3)) 2)
\evalsto{} 3
\end{alltt}
%
Um zu den Ausdrücken zu kommen, welche die Anzahl der PKWs ausrechnen,
haben wir sogenanntes \textit{Domänenwissen}\index{Domänenwissen}
benutzt: Die "`Domäne"' der Aufgabe sind PKWs und Motorräder, und wir
wissen, dass PKWs jeweils vier Räder und Motorräder zwei haben.
Schließlich haben wir noch Algebra benutzt, um aus dem Domänenwissen
eine Formel zu machen.

\section{Kommentare und Formatierung}

Der Ausdruck \texttt{(/ (- 10 (* 2 4)) 2)} ist für unbedarfte Leser
schwer zu verstehen.  Manchmal hilft ein erläuternder Text beim
Verständnis:
%
\begin{alltt}
(/ (- 10 (* 2 4)) 2) ; 10 Räder, 4 Fahrzeuge
\evalsto{} 1
(/ (- 12 (* 2 3)) 2) ; 12 Räder, 3 Fahrzeuge
\evalsto{} 3
\end{alltt}

\begin{feature}{Kommentare}{scheme:comment}
  Ein Semikolon \texttt{;} kennzeichnet einen 
  \textit{Kommentar\index{Kommentar}}.  Der Kommentar erstreckt sich
  vom Semikolon bis zum Ende der Zeile und wird vom Scheme-System
  ignoriert.
\end{feature}
%
Der Text nach dem Semikolon ist ein \textit{Kommentar}\index{Kommentar} (siehe
Abbildung~\ref{scheme:comment}), der von DrRacket ignoriert wird, aber
für menschliche Leser hilfreich ist.

Beim Verständnis kann außerdem die
\textit{Formatierung}\index{Formatierung} des Programms helfen.  Die
obigen Ausdrücke können auch folgendermaßen geschrieben werden:
%
\begin{alltt}
(/ (- 10 (* 2 4))
   2)
(/ (- 12 (* 2 3))
   2)
\end{alltt}
%
Daß die \texttt{2} jetzt jeweils in einer weiteren Zeile steht, läßt
die Ausdrücke so ähnlich aussehen wie der Bruch in der Formel.  Die
Einrückung vor der \texttt{2} macht klar, dass die \texttt{2} noch in
die Klammern vom \texttt{/} gehört.

Wir als Programmierer müssen uns selbst darum kümmern, an sinnvollen
Stellen eine neue Zeile anzufangen.  Um die Einrückung kann sich
allerdings DrRacket automatisch kümmern: Die Tab-Taste (links auf der
Tastatur, meist $\rightarrow$\verb/|/ o.ä.\ bedruckt) rückt die Zeile,
in der sich der Cursor befindet, ein.  Außerdem gibt es noch den
Menüpunkt \texttt{Racket} $\rightarrow$ \texttt{Alles einrücken}, der
das gesamte Programm einrückt.

\section{Abstraktion}

Beim Parkplatzproblem aus Abschnitt~\ref{sec:domaenenwissen} ist es
umständlich, für jede Kombination aus konkreten $m$ und $n$ die 
Formel neu hinzuschreiben und andere Werte für $m$ und $n$
einzusetzen.  Außerdem ist es fehleranfällig.  Es muß also besser
gehen.  Ein erster Schritt in die richtige Richtung ist, für $m$ und
$n$ auch im Programm Namen zu verwenden:
%
\begin{alltt}
(define n 4)
(define m 10)
(/ (- m (* 2 n)) 2)
\end{alltt}
%
Immerhin ist die ursprüngliche Formel jetzt wieder erkennbar.  Leider
kann sie nur einmal verwendet werden.  Schreiben wir in dasselbe
Programm die hier darunter:
%
\begin{alltt}
(define n 3)
(define m 12)
(/ (- m (* 2 n)) 2)
\end{alltt}
%
\ldots{} dann meckert DrRacket:
%
\begin{alltt}
m: Für diesen Namen gibt es schon eine Definition
\end{alltt}
%
Für jeden Namen kann es nur eine Definition geben.  Wir bräuchten
Formeln, die wir mehrfach verwenden können, bei denen wir sagen können
"`ich werde die Formeln mehrmals benutzen und möchte jedesmal andere
Werte für $n$ und $m$ einsetzen"'. Das geht beim Programmieren mit
\textit{Abstraktion}\index{Abstraktion} und sieht konkret so aus:
%
\begin{alltt}
(lambda (n m) (/ (- m (* 2 n)) 2))
\end{alltt}
%
Diese Abstraktion besteht aus folgenden Bestandteilen:
\begin{itemize}
\item das Schlüsselwort \texttt{lambda},
\item die Namen \texttt{n} und \texttt{m}, die \textit{Parameter},\index{Parameter}
\item der Ausdruck \texttt{(/ (- m (* 2 n)) 2)}, der \textit{Rumpf\index{Rumpf}}.
\end{itemize}
%
Die Abstraktion hat als Wert eine \textit{Funktion\index{Funktion}}.  Wenn der
$lambda$-Ausdruck so in einem Programm steht, druckt beim Auswerten
DrRacket auch aus:
%
\begin{alltt}
#<procedure>
\end{alltt}
%
Für sich genommen macht eine Prozedur noch nichts Interessantes.  Sie kann jedoch
\emph{angewendet} werden, was heißt, dass konkrete Werte für $m$ und
$n$ eingesetzt werden:
%
\begin{alltt}
((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
\evalsto{} 1
((lambda (n m) (/ (- m (* 2 n)) 2)) 3 12)
\evalsto{} 3
\end{alltt}

% 
Abbildung~\ref{scheme:abstraction} erklärt die beiden Konzepte
"`Abstraktion"' und "`Anwendung"' im allgemeinen.

Bisher ist jedoch noch nicht viel gewonnen, weil wir den
$lambda$-Ausdruck jedesmal wiederholen mußten.  Da er jedoch beide
Male genau gleich ist, können wir ihm mit \texttt{define} einen Namen
geben:
%
\begin{alltt}
(define parking-lot-cars
  (lambda (n m) (/ (- m (* 2 n)) 2)))
\end{alltt}
%
Am besten verteilen wir das Programm gleich noch auf etwas mehr Zeilen
und rücken es ein, um es lesbarer zu machen:
%
\begin{alltt}
(define parking-lot-cars
  (lambda (n m)
    (/ (- m (* 2 n))
       2)))
\end{alltt}
%
\texttt{Parking-lot-cars} können wir jetzt mehrfach verwenden:
%
\begin{alltt}
(parking-lot-cars 4 10)
\evalsto{} 1
(parking-lot-cars 3 12)
\evalsto{} 3
\end{alltt}
%
Das sieht doch schon besser aus: Der Name \texttt{parking-lot-cars}
ist außerdem sprechend und erlaubt uns, die eigentliche Formel auch
wieder zu vergessen.

% FIXME: Warum heißt es eigentlich $lambda$?

\section{Kurzbeschreibung und Signatur}
\label{sec:sorts-and-contracts}

Angenommen, die Funktiondefinition von \texttt{parking-lot-cars} wird
an jemanden weitergegeben, der dieses Buch nicht gelesen hat, aber die
Funktion trotzdem einsetzen soll.  Der potentielle Leser kann zwar
das Scheme-Programm prinzipiell verstehen, hat aber keinen weiteren
Hinweis darauf, wofür \texttt{parking-lot-cars} verwendet werden kann.

Das Problem ist, daß die Definition von \texttt{parking-lot-cars} 
das Endprodukt des Denkprozesses ist, der in Kapitel~\ref{cha:intro}
beschrieben wurde.  Der Denkprozeß selbst, der mit der Aufgabenstellung
anfängt, ist nicht Teil der Definition.  Darum ist es hilfreich, wenn
wichtige Aspekte des Denkprozesses als Kommentare  bei den Definitionen
stehen.  Ein stets sinnvoller Kommentar ist eine \textit{Kurzbeschreibung}\index{Kurzbeschreibung} der
Aufgabenstellung:
%
\begin{alltt}
; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
\end{alltt}
%
Für die Kurzbeschreibung reicht in der Regel \emph{eine Zeile}: Nehmen
Sie diese Einschränkung als Gelegenheit, sich knapp, prägnant und
präzise auszudrücken.

Als nächstes ist eine besondere Formulierung hilfreich, die
sogenannte \textit{Signatur\index{Signatur}}. Wer nur gelesen hat, dass die
Funktion \texttt{parking-lot-cars} zwei Argumente \texttt{n} und
\texttt{m} hat, könnte ja auf den Gedanken kommen, einen Aufruf der
Form

\begin{alltt}
(parking-lot-cars "zweiundzwanzig" "achtunddreissig")
\end{alltt}
zu notieren.  Das wird bei der Ausführung eine Fehlermeldung erzeugen, weil die
eingebauten Funktionen \texttt{/}, \texttt{-} und \texttt{*} nur mit Zahlen in
Form von Ziffernfolgen umgehen können, aber nicht mit Zeichenketten, die
vielleicht auch Zahlen bezeichnen könnten.  In der Tat akzeptieren fast alle
Funktionen nur Argumente einer ganz bestimmten \emph{Sorte}\index{Sorte}, in
diesem Fall Argumente der Sorte "`natürliche Zahl"'.

Hier eine Liste der wichtigsten "`eingebauten"' Sorten:
%
\begin{center}
  \begin{tabular}{l|l}
    natürliche Zahlen & \texttt{natural}\\\hline
    ganze Zahlen & \texttt{integer}\\\hline
    rationale Zahlen & \texttt{rational}\\\hline
    reelle Zahlen & \texttt{real}\\\hline
    Zahlen allgemein (inkl.\ komplexe) & \texttt{number}\\\hline
    Zeichenketten & \texttt{string}\\\hline
    Bilder & \texttt{image}
  \end{tabular}
\end{center}
%
Eine Signatur\index{Signatur}
ist eine Vorstufe für die zu entwickelnde Prozedur und faßt einige
wichtige Informationen zusammen:
%
\begin{enumerate}
\item den Namen der Funktion,
\item Anzahl und Sorten der Argumente und
\item die Sorte des Rückgabewerts der Prozedur.
\end{enumerate}
%
%Die \textit{Signaturen}\index{Signaturen} beschreiben die Sorten, aus
%denen die Argumente bzw.\ der Rückgabewert stammen.  
Die Funktion
\texttt{parking-lot-cars} akzeptiert zwei natürliche Zahlen und
liefert wieder eine natürliche Zahl.  Deshalb sieht die Signatur von
\texttt{parking-lot-cars} so aus:
%
\begin{alltt}
(: parking-lot-cars (natural natural -> natural))
\end{alltt}
%
%Damit wird die Signatur \verb|(natural natural -> natural)| der
%Funktion \texttt{parking-lot-cars} zugeordnet.  
Diese Signatur besagt:
%
\begin{itemize}
\item \texttt{Parking-lot-cars} ist eine Funktion (das sagt der Pfeil
  \verb|->| zusammen mit den Klammern);
\item \texttt{parking-lot-cars}
  \textit{akzeptiert}\index{akzeptieren} zwei Argumente (vor dem Pfeil
stehen zwei Wörter);
\item die beiden Argumente sind natürliche Zahlen (\texttt{natural});
\item die Prozedur liefert wieder eine natürliche Zahl (das ist
das \texttt{natural} hinter dem Pfeil).
\end{itemize}
%
Die Signatur ähnelt also der mathematischen Notation für Funktionen,
die einen bestimmten Typ haben.

Aus der Signatur ergeben sich, wenn für die beiden Argumente
sprechende Namen gefunden worden sind, die ersten beiden Zeilen der folgenden
Definition, das sogenannte \textit{Gerüst\index{Gerüst}}:
%
\begin{alltt}
(define parking-lot-cars
  (lambda (n m)
    ...))
\end{alltt}
%
Es bleibt, die passende Formel einzusetzen.  Die Definition
von \texttt{parking-lot-cars} sieht dann vollständig so aus:\index{parking-lot-cars@\texttt{parking-lot-cars}}
%
\begin{alltt}
; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
(: parking-lot-cars (natural natural -> natural))
(define parking-lot-cars
  (lambda (n m)
    (/ (- m (* 2 n))
       2)))
\end{alltt}
%
Signaturen können für alle Arten von Werten deklariert werden, nicht
nur für Prozeduren.  Zum Beispiel so:
%
\begin{verbatim}
(: pi real)
\end{verbatim}
%
Bei \texttt{parking-lot-cars} ist die Signatur noch nicht besonders
umfangreich oder kompliziert.
Spätere Kapitel werden zeigen, dass sich aus vielen Signaturen ganz
automatisch \textit{Schablonen\index{Schablone}} ergeben, die dem
Programmierer einen Großteil der Denkarbeit bei der Entwicklung von
Funktionen abnehmen.

Aus diesem Grund schreiben wir in diesem Buch die
Kurzbeschreibung und die Signatur in das Programm, \emph{bevor} wir
die Definition entwickeln: 
Die
nachträgliche Entwicklung dieser Kommentare ist mühselig und
langweilig.  Außerdem sind die Kurzbeschreibung und die
Signatur ein hilfreicher Teil des Problemlösungsprozesses.
Schon mancher Programmierer~-- Anfänger und Profi~--
ist an Aufgaben gescheitert, die sich mit Hilfe systematischen Vorgehens
anhand der Signatur leicht hätten lösen lassen.

Aus dem fernen Osten stammt der Begriff des "`Mantras"' als einem
Sinnspruch, den es sich lohnt, auswendig zu lernen.  Hier das erste Mantra:
%
\begin{mantra}[Signatur vor Ausführung]\label{mantra:contract}
\input{mantra:contract}
\end{mantra}
%
Ab jetzt werden sich die Programmbeispiele in diesem Buch natürlich
an dieses Mantra halten.  Kurzbeschreibung, Signatur, Testfälle
(beschrieben im nächsten Abschnitt) Gerüst und
Schablone sind feste Bestandteile einer
\textit{Konstruktionsanleitung\index{Konstruktionsanleitung}}, die
systematisch beschreibt, wie eine Aufgabe schrittweise gelöst werden
kann.  Dieses Buch wird eine Reihe von Konstruktionsanleitungen
vorstellen, die sich stets an der Signatur einer Funktion orientieren.
Alle Mantras sind in Anhang~\ref{cha:mantras} und die
Konstruktionsanleitungen in Anhang~\ref{app:konstruktionsanleitungen}
zusammengefaßt.

\section{Testfälle}
\label{sec:test-cases}

\index{Testfall}Vertrauen ist gut~-- aber Fehler passieren, auch bei 
sorgfältiger Programmierung.  Angenommen, bei der Programmierung von
\texttt{parking-lot-cars} wäre folgendes herausgekommen:
%
\begin{alltt}
; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
(: parking-lot-cars (natural natural -> natural))
(define parking-lot-cars
  (lambda (n m)
    (/ (- m (* 4 n))
       2)))
\end{alltt}
%
Sehen Sie den Fehler auf den ersten Blick?  
Einfaches Ausprobieren ist da vielleicht schneller:
%
\begin{alltt}
(parking-lot-cars 1 4)
\evalsto{} 0
\end{alltt}
%
Bei der Entwicklung der Funktion sollten also
\textit{Testfälle\index{Testfall}} konstruiert werden, die an
ausgewählten Beispielen überprüfen, ob die gerade programmierte
Funktion auch korrekt funktioniert.  Testen ist eine unverzichtbare
Tätigkeit des Programmierers.

Die Testfälle werden am besten \emph{vor} der Definition der Prozedur
aufgestellt, denn  wenn sie erst hinterher geschrieben werden, ist die
Gefahr groß, dass unbewußt das tatsächliche Ergebnis
eines Prozeduraufrufs als das gewünschte eingegeben oder besonders
kritische Beispiele weggelassen werden.  (In der industriellen Praxis ist sogar
oft üblich, dass jemand anderes als der Autor der Definitionen
die Testfälle schreibt.)

Es ist mühselig, bei der Programmentwicklung ständig Testfälle in die
REPL einzutippen und durch einen Vergleich mit den erwarteten
Ergebnissen herauszubekommen, ob alles in Ordnung ist.  In \drscheme{}
geht es deshalb auch einfacher.  Testfälle können zusammen mit den
erwarteten Ergebnissen wie folgt spezifiziert werden:

\begin{alltt}
(check-expect (parking-lot-cars 1 4) 1)  
(check-expect (parking-lot-cars 2 6) 1)  
(check-expect (parking-lot-cars 10 28) 4)  
\end{alltt}

Beim Druck auf den \texttt{Start}-Knopf überprüft \drscheme{}, ob die
tatsächlichen Ergebnisse der Ausdrücke mit den Soll-Werten
übereinstimmen.  Für fehlgeschlagene Testfälle öffnet sich ein neues Fenster
mit Informationen über die Unterschiede zwischen erwarteten und
tatsächlichen Ergebnissen; ansonsten gibt es eine kurze Meldung, dass die
Testfälle erfolgreich waren.  Für die obere inkorrekte Version kommt
zum Beispiel Folgendes heraus:
%
\begin{alltt}
3 Tests gelaufen.
0 Tests bestanden.
2 Signaturverletzungen.

Check-Fehler:
	Der tatsächliche Wert 0 ist nicht der erwartete Wert 1.
in Zeile 4, Spalte 0 
	Der tatsächliche Wert -1 ist nicht der erwartete Wert 1.
in Zeile 5, Spalte 0 
	Der tatsächliche Wert -6 ist nicht der erwartete Wert 4.
in Zeile 6, Spalte 0 

Signaturverletzungen:
	bekam -1 in Zeile 5, Spalte 14 , Signatur in Zeile 2, Spalte 40 
	verantwortlich: Funktion in Zeile 9, Spalte 2 
	bekam -6 in Zeile 6, Spalte 14 , Signatur in Zeile 2, Spalte 40 
	verantwortlich: Funktion in Zeile 9, Spalte 2 
\end{alltt}
%
Eine großzügige Verwendung
von Testfällen kann viele Programmierfehler
aufdecken und damit die Programmierung erleichtern und beschleunigen.

\begin{mantra}[Testfälle]\label{mantra:test}
\input{mantra:test}
\end{mantra}

% FIXME: Coverage

\section{Unsinnige Daten}
\label{sec:nonsensical-data-prequel}

Die Testfälle aus dem vorangegangenen Abschnitt sind alle
"`sinnvoll"'~-- die Eingabedaten passen alle zu tatsächlichen
Parkplatzsituationen.  Was ist aber hiermit?
%
\begin{alltt}
(parking-lot-cars 3 9)
\end{alltt}
%
Wie schon in Kapitel~\ref{page:parking-lot-problem}
(Seite~\pageref{page:parking-lot-problem}) bereits angedeutet, 
lassen sich die \emph{Daten} 3 und 9 nicht als \emph{Information}
interpretieren: Es gibt keinen Parkplatz mit 3 Fahrzeugen und 9
Rädern~-- zumindest nicht mit den Einschränkungen der Aufgabenstellung
auf vollberäderte PKWs und Motorräder.

Die Prozedur \texttt{parking-lot-cars} stört dies allerdings wenig:
Sie liefert munter die Ausgabe \texttt{1.5}.  Allerdings meldet
DrRacket eine \textit{Signaturverletzung}\index{Signaturverletzung},
wenn es \texttt{(parking-lot-cars 3 9)} auswertet, da das Ergebnis
keine natürliche Zahl ist wie in der Signatur angegeben.  

Das Programm sollte natürlich abseits der Signaturverletzung unsinnige
Daten soweit möglich und praktikabel zurückweisen.  Für die Eingabe
\texttt{(parking-lot-cars 3 16)} hätte es nämlich keine Signaturverletzung
gegeben, sondern es wäre eine zunächst unschuldig aussehende $5$
herausgekommen. Da hätte es zuerst noch der Beobachtung bedurft, dass unmöglich
$5$ von $3$ Fahrzeugen PKWs sein können. Noch fehlen uns
die Mittel, solche unsinnigen Eingaben zurückzuweisen; in Abschnitt~\ref{sec:nonsensical-data} werden wir
dies nachholen.

\section{Probleme und Teilprobleme}
\label{sec:subproblems}

TBD

\section{Auswertung}
\label{sec:substitution-model}
\label{sec:scheme-anatomy}

Bei der Auswertung eines Programms geht DrRacket nach festen Regeln
vor.  Schauen wir uns noch einmal das Programm zum Parkplatzproblem
an:
%
\begin{alltt}
(define parking-lot-cars
  (lambda (n m)
    (/ (- m (* 2 n))
       2)))
(parking-lot-cars 4 10)
\end{alltt}
%
Bei der Auswertung \textit{substituiert}\index{Substitution} DrRacket
jeweils Namen durch ihre Werte.  Der erste Schritt ist also,
\texttt{parking-lot-cars} durch den dazugehörigen
\texttt{lambda}-Ausdruck zu ersetzen:
%
\begin{alltt}
(parking-lot-cars 4 10)
\evalsto
((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
\end{alltt}
%
Jetzt steht dort die Anwendung eines \texttt{lambda}-Ausdrucks auf die
zwei Zahlen \texttt{4} und \texttt{10}: Diese Argumente werden für die
ensprechenden Parameter \texttt{n} und \texttt{m} eingesetzt:
%
\begin{alltt}
((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
\evalsto
(/ (- 10 (* 2 4)) 2)
\end{alltt}
%
Nun werden sukzessive die Teilausdrücke ausgewertet.  Das passiert
immer von links nach rechts.  Bei einer Anwendung werden erst einmal
alle Argumente fertig ausgewertet, bevor es mit der Substitution der
Parameter und dem Rumpf der Prozezedur weitergeht:
%
\begin{alltt}
(/ (- 10 (* 2 4)) 2)
\evalsto
(/ (- 10 8) 2)
\evalsto
(/ 2 2)
\evalsto
1
\end{alltt}
%
Diese Vorgehensweise entspricht der Algebra aus der Mathematik, wo wir
auch Ausdrücke umformen, indem wir gleiches durch gleiches ersetzen.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/stepper.png}
  \caption{Stepper in DrRacket}
  \label{fig:stepper}
\end{figure}
%
Normalerweise zeigt uns DrRacket nur das Endergebnis dieses Prozesses
an.  Es ist aber auch in der Lage, die Schritte einzeln zu
visualisieren: Dazu müssen Sie auf den \texttt{Step}-Knopf drücken.
Es erscheint ein neues Fenster, der sogenannte \textit{Stepper}\index{Stepper}.
Sie können dann vorwärts und rückwärts durch den Substitutionsprozeß
navigieren.  Abbildung~\ref{fig:stepper} zeigt das Stepper-Fenster.

\section*{Aufgaben}


\begin{aufgabe}
  Betrachten Sie folgende Stromtarife.  Beide Tarife
  bestehen aus einer monatlichen Grundgebühr und einem Teil, der sich
  nach den verbrauchten Kilowattstunden (kWh) richtet.
  %
  \begin{center}
    \begin{tabular}{l|c|c|}
      & Grundgebühr pro Monat & Verbrauchspreis pro kWh \\
      \hline
      Tarif "`Billig-Strom"' & 4,90 Euro & 19 Cent \\
      \hline
      Tarif "`Watt für wenig"' & 8,20 Euro & 16 Cent \\
      \hline
    \end{tabular}
  \end{center}

  \begin{enumerate}
  \item Schreiben Sie eine Funktion
    \texttt{billig-strom}, die den Monatsverbrauch in Kilowattstunden
    akzeptiert und den im Tarif "`Billig-Strom"' zu zahlenden
    monatlichen Rechnungsbetrag 
    berechnet.

  \item Schreiben Sie eine Funktion
    \texttt{watt-für-wenig}, die den Monatsverbrauch in
    Kilowattstunden akzeptiert und den im Tarif "`Watt für wenig"' zu
    zahlenden monatlichen Rechnungsbetrag
    Verbrauch berechnet.
  \end{enumerate}
  %
  Halten Sie sich bei jeder Funktion, die Sie schreiben, an die
  Konstruktionsanleitungen: Schreiben Sie zuerst die Kurzbeschreibung
  und die Signatur.  Schreiben Sie als nächstes einige Testfälle.
  Leiten Sie danach das Gerüst von der Signatur her und vervollständigen
  Sie den Rumpf der Funktion.
\end{aufgabe}

\begin{aufgabe}
 Vervielfachung von Strings:
 \begin{itemize}
  \item Schreiben Sie eine Funktion \texttt{double-string}, die eine Zeichenkette konsumiert und
    diese "`verdoppelt"', d.h., für eine Eingabe \verb|"Sperber"| den
    Rückgabewert \verb|"SperberSperber"| liefert.
    
  \item Schreiben Sie eine Funktion \texttt{quadruple-string}, die eine
    Zeichenkette konsumiert und "`vervierfacht"'.

  \item Schreiben Sie eine Funktion \texttt{octuple-string}, die eine
    Zeichenkette konsumiert und "`verachtfacht"'.

  \item Schreiben Sie eine Funktion \texttt{sixteentuple-string}, die
    eine Zeichenkette konsumiert und "`versechzehnfacht"'.
  \end{itemize}
  % Schreiben Sie für jede Prozedur Kurzbeschreibung, Signatur, Testfälle, Gerüst und Rumpf.

%Vermeiden Sie bei all diesen Aufgaben, Code mehrfach zu schreiben.

\end{aufgabe}

\begin{aufgabe}

 Ein Boot überquert einen Fluss mit Strömung und
  kommt durch die Strömung vom geplanten Kurs ab.  Dadurch wird die
  Strecke, die das Boot tatsächlich zurücklegt, länger.

  \begin{center}
    \includegraphics{riverboat}
  \end{center}

  Geben ist die Breite des Flusses $a$, die Strömungsgeschwindigkeit
  des Flusses $v_{\text{Fluss}}$ und die Geschwindigkeit des Bootes
  $v_{\text{Boot}}$.  Berechnen Sie die Länge der Strecke, die das
  Boot tatsächlich zurücklegt.  Programmieren Sie dazu Prozeduren, die
  folgende Teilprobleme lösen:

  \begin{enumerate}
  \item Schreiben Sie zunächst eine Prozedur \texttt{speed-ratio}, die
    das Verhältnis der Strömungsgeschwindigkeit des Flusses
    $v_{\text{Fluss}}$ zur Geschwindigkeit des Bootes
    $v_{\text{Boot}}$ berechnet.

  \item Schreiben Sie dann eine Funktion \texttt{other-shore-offset},
    die die Länge der Strecke berechnet, die das Boot abgetrieben wird
    (also den Versatz am anderen Ufer, im Schaubild die Strecke $b$).
    % Dazu müssen Sie die Breite des Flusses $a$ mit dem Verhältnis von
    % $v_{\text{Fluss}}$ zu $v_{\text{Boot}}$ multiplizieren.

  \item Um $c$ zu berechnen, brauchen Sie den \textit{Satz des
      Pythagoras}:
    \begin{displaymath}
      a^2 + b^2 = c^2
    \end{displaymath}
    Schreiben Sie eine Funktion \texttt{pythagoras}, die $c$ der
    obigen Gleichung berechnet.  Erkennen und abstrahieren Sie weitere
    Teilprobleme!

  \item Schreiben Sie schließlich eine Prozedur
    \texttt{boat-travel-distance}, die die tatsächliche Strecke
    berechnet, die das Boot zurücklegt.  Benutzen Sie dafür die bisher
    geschriebenen Funktionen.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  In den USA und in Europa gibt es unterschiedliche
  Maße für die Energieeffizienz von Kraftfahrzeugen:
  \begin{itemize}
  \item In Europa ist das gängige Maß der \emph{Verbrauch} in Liter
    pro 100km (l/100km);
  \item in den USA ist das gängige Maß die \emph{Reichweite} in Meilen
    pro Gallone (mi/gal).
  \end{itemize}
  Schreiben Sie Prozeduren, die zwischen beiden Maßeinheiten
  umrechnen.  Gehen Sie dazu wie folgt vor:

  Halten Sie sich bei jeder Funktion, die Sie schreiben, an die
  Konstruktionsanleitungen: Schreiben Sie zuerst die Kurzbeschreibung
  und die Signatur.  Schreiben Sie als nächstes einige Testfälle.
  Leiten Sie danach das Gerüst von der Signatur her und vervollständigen
  Sie den Rumpf der Funktion.

  \begin{enumerate}

  \item Schreiben Sie eine Funktion
    \texttt{liters-per-hundred-kilometers}, die eine Menge Benzin in
    Liter und die Reichweite dieses Benzins in Kilometer akzeptiert
    und daraus den Verbrauch in Liter pro 100km berechnet.

  \item Schreiben Sie eine Funktion
    \texttt{miles-per-gallon}, die eine Entfernung in Meilen und den
    Benzinverbrauch auf diese Entfernung in Gallonen akzeptiert und
    daraus die Reichweite in Meilen pro Gallone berechnet.

  \item Definieren Sie eine Konstante
    \texttt{kilometers-per-mile} (eine US-Meile entspricht etwa $1,61$
    Kilometer) und schreiben Sie zwei Funktionen
    \texttt{kilometers->miles} und \texttt{miles->kilometers}, die
    jeweils eine Entfernung in einer Maßeinheit akzeptieren und die
    Entfernung in die jeweils andere Maßeinheit umrechnen.

  \item Definieren Sie eine Konstante
    \texttt{liters-per-gallon} (eine Gallone entspricht etwa $3,79$
    Liter) und schreiben Sie zwei Funktionen \texttt{liters->gallons}
    und \texttt{gallons->liters}, die jeweils eine Menge in einer
    Maßeinheit akzeptieren und die Menge in die jeweils andere
    Maßeinheit umrechnen.

  \item Schreiben Sie die Funktion
    \texttt{l/100km->mi/gal}, die einen Verbrauch in Liter pro 100km
    akzeptiert und in die Reichweite in Meilen pro Gallone umrechnet.
    Benutzen Sie dafür die Prozeduren, die Sie in den anderen
    Teilaufgaben erstellt haben.  Sollten Sie auf weitere Teilprobleme
    stoßen, abstrahieren Sie diese Teilprobleme in eigene Prozeduren.

  \item Schreiben Sie die Funktion
    \texttt{mi/gal->l/100km}, die eine Reichweite in Meilen pro
    Gallone akzeptiert und in den Verbrauch in Liter pro 100km
    umrechnet.  Benutzen Sie dafür die Prozeduren, die Sie in den
    anderen Teilaufgaben erstellt haben.  Sollten Sie auf weitere
    Teilprobleme stoßen, abstrahieren Sie diese Teilprobleme in eigene
    Funktionen.

  \item Finden Sie heraus, wie hoch der Benzinverbrauch
    verschiedener Kraftfahrzeuge ist, die Sie täglich im
    Straßenverkehr in Deutschland sehen.  Vergleichen Sie diesen
    Verbrauch mit den Reichweitenangaben typischer Kraftfahrzeuge für
    den US-amerikanischen Markt.
  \end{enumerate}

\end{aufgabe}

% In vielen Ländern sind die Benzinpreise ein Grund zur allgemeinen
% Aufregung. In Deutschland wird immer die magische Marke von 1,50
% Euro pro Liter genannt, die USA haben große Angst vor der 4 Dollar
% pro Gallone. Auch sind Spritsparende Autos immer beliebter, in
% Deutschland wird auf das 3 Liter auf 100km Auto gehofft, die USA
% wünschen sich mehr 55 Meilen pro Gallone Autos.  Diese verschiedenen
% Maßstäbe sind verwirrend.

% FIXME: Hier taucht noch "Substitutionsmodell" auf.

% FIXME: umbenennen von n und m in parking-lot-cars in sprechende Namen


\begin{aufgabe}

  Betrachten Sie das folgende Programm:

\begin{verbatim}
(define x 2)          ;  --> zwei
(define y -1)         ;  --> minuseins
(define z -3)         ;  --> minusdrei

(define f 
  (lambda (x z)
    (+ (* x x) z y)))

(f 4 -2)
\end{verbatim}
  %
  Benennen Sie die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um, und zwar \verb|x| in \verb|zwei|, \verb|y| in
  \verb|minuseins| und \verb|z| in \verb|minusdrei|. Achten Sie bei
  der Umbenennung auf die lexikalische Bindung.  Benennen Sie keine
  Parameter der Funktion \verb"f" um.

  Nachdem Sie die Umbenennung durchgeführt haben, welches Ergebnis liefert
  der Ausdruck \verb"(f 4 -2)"? Berechnen Sie das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halten Sie die Zwischenschritte fest.
\end{aufgabe}

\begin{aufgabe}

  Betrachten Sie das folgende Programm:

\begin{verbatim}
(define x 2)                    ; --> zwei
(define y 4)                    ; --> vier

(define z                       ; --> f
  (lambda (x y z)
    (+ x (z y))))

(z y x (lambda (z) (+ x z)))
\end{verbatim}
%
  Benennen Sie die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um. Der neue Name der Variable steht als Kommentar im
  Programm hinter dem Pfeil (\verb"-->").  Achten Sie bei der
  Umbenennung auf die lexikalische Bindung.  Benennen Sie keine
  Parameter der Funktion \verb"z" um.

  Berechnen Sie, nachdem Sie die Umbenennung durchgeführt haben, von
  Hand mit dem Substitutionsmodell \verb"(z y x"
  \verb"(lambda (z) (+ x z))))" und halten Sie die Zwischenschritte
  fest.

\end{aufgabe}

\begin{aufgabe}
  Betrachten Sie das folgende Programm:

\begin{verbatim}
(define x 1)
(define y 3)
(define z 5)

(define f
  (lambda (x)   
     ((lambda (y)
        ((lambda (z)
           (+ z (* x y)))
         (+ x z)))
      (+ x y))))

(f y)
\end{verbatim}

  Benennen Sie hier alle lokalen Variablen, die innerhalb der Funktion
  \verb"f" gebunden werden, um. Verändern Sie nicht den Namen der
  Variablen \verb"x", \verb"y" und \verb"z" aus den ersten drei Zeilen
  des Programms.

  Nachdem Sie die Umbenennung durchgeführt haben, welches Ergebnis liefert
  der Ausdruck \verb"(f y)"? Berechnen Sie das Ergebnis von Hand mithilfe
  des Substitutionsmodells und halten Sie die Zwischenschritte fest.

  \noindent \emph{Hinweis:} In diesen Aufgaben finden Sie keine
  Kommentare und Signaturen zu den Prozeduren. Hier können Sie an einem
  Beispiel sehen, dass es sehr wichtig ist, diese Informationen
  anderen Programmierern immer zur Verfügung zu stellen. Denn es kann
  auch bei kleinen Programmen schwer sein, die Funktionsweise der
  einzelnen Funktionen ohne Kommentare zu verstehen.
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
