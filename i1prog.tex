% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung 4.0 International (CC BY 4.0)"
% http://creativecommons.org/licenses/by/4.0/deed.de

\chapter{Elemente des Programmierens}
\label{cha:whats-programming}

Dieses Kapitel gibt einen Überblick über das wichtigste Handwerkszeug
des Programmierens: Welche Software Du dafür brauchst, wie Du diese
Software bedienst, wie kleine Programme aussehen und aus was für
Elementen sie bestehen.

\section{DrRacket}

Zunächst einmal benötigst Du die Software \textit{Racket}\index{Racket}, die es zum
kostenlosen Download auf der Seite \url{https://racket-lang.org/} für
alle gängingen Plattformen gibt.  Auf der Seite ist ein
\texttt{Download}-Knopf~-- folge den dortigen Instruktionen für die
Installation.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-start}
  \caption{DrRacket nach dem ersten Start}
  \label{fig:drracket-start}
\end{figure}

Zu Racket gehört ein Programm namens
\textit{DrRacket}\index{DrRacket}: starte es.  Es erscheint ein
Fenster, das ungefähr so aussehen sollte wie in
Abbildung~\ref{fig:drracket-start}.  Die Benutzeroberfläche kannst
Du auf Deutsch umstellen, indem Du im Hilfe-Menü auf \texttt{Deutsche
  Benutzeroberfläche für DrRacket} drückst.  Wenn Du die Auswahl
bestätigst, wird DrRacket danach beendet und Du musst es noch einmal
starten; dann sollten die Menüs auf Deutsch sein.

DrRacket ist eine \textit{Entwicklungsumgebung}, mit der Du Programme
schreiben und ausführen kannst.  DrRacket unterstützt nicht nur eine
Programmiersprache, darum musst Du die richtige Programmiersprache für
dieses Buch noch auswählen.  Dazu wählst Du den Menüpunkt
\texttt{Sprache $\rightarrow$ Sprache auswählen} (bzw.\
\texttt{Language $\rightarrow$ Choose language} in der englischen
Fassung), worauf ein Dialog erscheint.  In dem Dialog gibt es eine
Abteilung \texttt{Lehrsprachen\index{Lehrsprachen}}, und darunter eine
Überschrift namens \texttt{DeinProgramm}, unterhalb dessen mehrere
Einträge erscheinen, die speziell auf die Kapitel dieses Buchs
zugeschnitten sind.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-deinprogramm}
  \caption{DrRacket mit ausgewählter Lehrsprache}
  \label{fig:drracket-deinprogramm}
\end{figure}

Für den ersten Teil des Buches ist die Ebene \texttt{Schreibe Dein
  Programm! - Anfänger} zuständig:\index{Sprachebene!Anfänger} Wähle
diese aus und drücke dann einmal oben rechts auf den Knopf
\texttt{Start} (bzw.\ \texttt{Run}), damit die Auswahl aktiv wird.
Das Ergebnis sollte dann so aussehen wie in
Abbildung~\ref{fig:drracket-deinprogramm}.

Das DrRacket-Fenster besteht aus zwei Teilen:
%
\begin{enumerate}
\item In der oberen Hälfte des Fensters (dem
  \textit{Editor\index{Editor}} oder
  \textit{Definitionsfenster\index{Definitionsfenster}}) steht der
  Programmtext.  Der Editor funktioniert ähnlich wie ein reguläres
  Textverarbeitungsprogramm.  Was dort steht, kannst Du abspeichern.
\item In der unteren Hälfte des Fensters~-- dem
  \textit{Interaktionsfenster\index{Interaktionsfenster}} oder der
  sogenannten \textit{REPL\index{REPL}}\footnote{"`REPL"' steht für
    "`Read-Eval-Print-Loop"'~-- wir werden später zeigen, warum.}
  werden die Ausgaben des Programms angezeigt.  Außerdem kannst Du
  hier "`Fragen"' an das Programm stellen, um einzelne Programmteile
  gezielt auszuprobieren.
\end{enumerate}
%

\section{Ausdrücke und die REPL}

Fangen wir mit der REPL an: Wenn Du gerade \texttt{Start} gedrückt
hast, dann erscheint der Cursor rechts von dem \verb|>|-Zeichen: Du
kannst da etwas eingeben und Return drücken~-- DrRacket zeigt dann
das Ergebnis darunter an.

Wenn Du zum Beispiel \texttt{123} eintippst, zeigt DrRacket gleich
darunter 123 an.  DrRacket kann auch rechnen.  Dafür musst Du
allerdings die Rechenaufgaben etwas anders aufschreiben als sonst.
Zum Beispiel so:
%
\begin{verbatim}
(+ 123 42)
\end{verbatim}
%
Wenn Du das in die REPL tippst, zeigt DrRacket \texttt{165} an, die
\textit{Summe}\index{Summe} von 123 und 42.  Diese "`Rechenaufgabe"'
ist ein sogenannter \textit{Ausdruck\index{Ausdruck}}.  Ausdrücke, die
etwas ausrechnen sollten, haben in den Lehrsprachen immer die gleiche
Form, und die sieht so aus:
%
\begin{alltt}
(\textnormal{\textit{Operator}} \textnormal{\textit{Operand}} \ldots)
\end{alltt}
%
Das heißt, da stehen \emph{immer} Klammern\index{Klammer} drumherum
(und die können auch nirgendwo sonst stehen).  Dann steht da der
\textit{Operator\index{Operator}}, der bestimmt, \emph{was} gemacht
wird, also die \textit{Operation}.  Danach kommen die
\textit{Operanden\index{Operand}}, welche die Eingaben\index{Eingabe}
für die Operation bestimmen.

Zum Merken ist es hilfreich, Ausdrücke entsprechend vorzulesen: Also
nicht mehr "`Hundertdreiundzwanzig plus zweiundvierzig"', sondern
"`die \emph{Summe} von Hundertdreiundzwanzig und zweiundvierzig"'.

Wie schon gesagt, die Klammern sind wichtig.  Wenn Du sie vergisst,
können verwirrende Ergebnisse herauskommen.  Wenn Du zum Beispiel
\texttt{+ 123 42} in der REPL eintippst, sieht das so aus:
%
\begin{alltt}
> + {\color{green}123 42}
{\color{blue}#<function:+>
123
42}
\end{alltt}
%
Das liegt daran, dass ohne Klammern \texttt{+ 123 32} aus \emph{drei}
Ausdrücken besteht und die REPL darum auch drei Ergebnisse ausdruckt:
Die Funktion \texttt{+}, dann die \texttt{123}, dann \texttt{42}.
(Die Operation \texttt{+} ist eine sogenannte Funktion ist~-- das
erläutern wir später noch genauer.)  Ähnlich verhält es sich mit
\texttt{123 + 42}~-- probiere es aus!

Wenn Du versehentlich den Operator dazwischen schreibst, erscheint
in der REPL eine Fehlermeldung:
%
\begin{alltt}
> ({\color{green}123} + {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Etwas ähnliches passiert, wenn Du kein Leerzeichen zwischen den
Operator und die Operanden oder zwischen die Operanden setzt.  Das
sieht zum Beispiel so aus:
%
\begin{alltt}
> ({\color{green}+123} {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Das liegt daran, dass \texttt{+123} zusammen die Zahl "`plus
hundertdreiundzwanzig"' bildet und nicht etwa in das \texttt{+} und
\texttt{123} aufgeteilt wird.

Wenn ein Ausdruck wie \texttt{(+ 123 42)} ein Ergebnis wie 165 hat,
schreiben wir das im Buch zukünftig so, etwas anders als die
DrRacket-REPL:
%
\begin{alltt}
(+ 123 42)
\evalsto{} 165
\end{alltt}
%
Es gehen natürlich nicht nur Summen, sonderen auch Differenzen,
Produkte und Quotienten:
%
\begin{alltt}
(- 123 42)
\evalsto{} 81
(* 123 42)
\evalsto{} 5166
(/ 123 42)
\evalsto{} 2.9\(\overline{\mathtt{285714}}\)
\end{alltt}
%
Beim letzen Ausdruck ist zu sehen, dass Dezimalzahlen mit Punkt und
nicht mit Komma geschrieben werden.  Der Überstrich bei
\texttt{2.9\(\overline{\mathtt{285714}}\)} ist eine
\textit{Periode\index{Periode}}. Die Zahl ist also eigentlich
%
\begin{alltt}
2.9285714285714285714285714285714\ldots
\end{alltt}
%
Die REPL funktioniert also folgendermaßen: Sie \emph{liest} einen
Ausdruck ein ("`read"'), berechnet deren Wert oder \emph{wertet}
diesen \emph{aus} (auf Englisch "`eval"') und zeigt das Ergebnis an
oder \emph{druckt} dieses \emph{aus} ("`print"')~-- und dann geht es
von vorn los, wie in einer Schleife ("`loop"').  Die Abfolge
\emph{Read-Eval-Print-Loop} gibt der REPL ihren Namen.

Ausdrücke können auch kombiniert werden, zum Beispiel so:
%
\begin{alltt}
(* 123 (+ 20 22))
\evalsto{} 5166
(* 123 (+ (* 2 10) 22))
\evalsto{} 5166
\end{alltt}
%
Bei der Kombination ist wichtig, dass um jeden Teilausdruck wieder ein
Klammernpaar kommt.  Ist das nicht der Fall, erscheinen gelegentlich
auch mal englischsprachige Fehlermeldungen wie diese hier:
%
\begin{alltt}
(* 123 (+ * 2 10 22))
{\color{red}+: expects a number as 1st argument, given #<function:*>}
\end{alltt}
%
Das liegt daran, dass das \texttt{*} hier an der Stelle eines
Operanden für die Summe dient.  Ein anderes Wort für Operand in diesem
Zusammenhang ist \textit{Argument}, darum steht da sinngemäß, dass
\texttt{+} eine Zahl als erstes Argument etwartet, aber
stattdessen die Funktion \texttt{+} bekommen hat.

Ein hilfreicher Trick übrigens: Um einen Ausdruck zu korrigieren,
kannst Du ihn in der REPL "`zurückholen"', indem Du \texttt{Esc}, und
dann \texttt{P} drückst~-- probier es aus!

\begin{aufgabe}
  Schreibe folgende "`mathematischen"' Ausdrücke in der Notation der
  Lehrsprache in die REPL und lasse die REPL sie auswerten:
  %
  \begin{displaymath}
    \begin{array}{c}
      55 * 27\\
      23 * (44 + 27)\\
      \frac{23}{44} + \frac{44}{23}\\
      (23 + 42) * (12 + (14 * 2))
    \end{array}
  \end{displaymath}
\end{aufgabe}
%
Ein weiterer praktischer Trick ist, dass Du einen geklammerten
Ausdruck markieren (und dann ausschneiden) kannst, indem Du auf die
öffnende oder schließende Klammer doppelt klickst.

\section{Das Definitionsfenster}

Kommen wir zum Definitionsfenster oben.  Dort schreibst Du Dein
Programm, die REPL kannst Du dann benutzen, um es auszuprobieren.
Schreib in das Definitionsfenster folgende
\textit{Definition\index{Definition}}:
%
\begin{verbatim}
(define alles (+ 20 22))
\end{verbatim}
%
Diese Definition besagt, dass der Name \texttt{alles} für das Ergebnis
von \texttt{(+ 20 22)} steht.  Um das auszuprobieren, drück auf den
Knopf \texttt{Start} bzw.\ \texttt{Run} rechts oben.  Der Cursor
landet dann wieder in der REPL, wo Du das Programm ausprobieren
kannst:
%
\begin{alltt}
alles
\evalsto{} 42
\end{alltt}
%
Ein Name, der in einem Programm so definiert ist, heißt
\textit{Variable\index{Variable}}.

Hier sind ein paar weitere Beispiele für Definitionen:
%
\begin{alltt}
(define one 1)
(define temperature 23)
(define birgit-prinz 9)
(define michael-ballack 13)
\end{alltt}
%
Bei der Gestaltung eines Namens gibt es weitgehende
Freiheiten.\footnote{Anders als in anderen Programmiersprachen sind
  auch Bindestriche in Namen möglich.}  Nur Leerzeichen sind nicht
erlaubt.

In einem Programm kannst Du Zeilenumbrüche und Einrückung benutzen, um
Dein Programm übersichtlicher zu gestalten.  Zum Beispiel kannst Du
nach \texttt{alles} die Return-Taste drücken, das Ergebnis sieht so
aus:
%
\begin{alltt}
(define alles
  (+ 20 22))
\end{alltt}
%
DrRacket rückt die zweite Zeile ein bisschen ein, um auszudrücken,
dass sie noch in die Klammern vom \texttt{define} gehört.  Bei
komplizierteren Ausdrücken ist das hilfreich:
%
\begin{verbatim}
(define alles
  (+ 20
     (* 11 2)))
\end{verbatim}
%
Hier stellt DrRacket die Operanden der Summe genau untereinander.
DrRacket zwingt Dich nicht, die Einrückung genau so zu machen, und
durch Änderungen im Programm gerät sie auch manchmal aus dem Lot.  In
dem Fall kannst Du die Tab-Taste drücken (auf den meisten Tastaturen
steht $\longrightarrow\mid$ auf der Tab-Taste) und in der Zeile, in
welcher der Cursor steht, wird die Einrückung korrigiert.
Wenn Du einen Abschnitt im Programm markierst und dann Tab drückst,
wird der ganze Abschnitt neu eingerückt.  Das ist besonders praktisch
im Zusammenspiel damit, einen geklammerten Ausdruck mit einem
doppelten Mausklick auf die öffnende Klammer zu markieren.
Es gibt
außerdem einen Menüpunkt \texttt{Racket $\rightarrow$ Alles einrücken} (bzw.\
\texttt{Racket $\rightarrow$ Reindent All}), der das für das gesamte
Programm macht: Probier es aus!

\begin{aufgabe}
  Bring bei einem mehrzahligen Programm die Einrückung richtig
  durcheinander, zum Beispiel so:
\begin{verbatim}
(define nr
  (+ 12
 (- (* 42
  13)
    500)))
\end{verbatim}
  %
  Benutze dann die Tab-Taste, um die Einrückung wieder zu korrigieren.
\end{aufgabe}
%
Den Inhalt des Definitionsfenster kannst Du abspeichern, indem Du auf
den Knopf mit der Diskette
\raisebox{-1ex}{\includegraphics[height=12pt]{i1prog/save}} drückst.

Abspeichern geht mit der REPL nicht, und der REPL-Inhalt verschwindet
auch jedesmal, wenn Du \texttt{Start} bzw.\ \texttt{Run} drückst.  Du
kannst aber frühere Eingaben zurückholen, indem Du
\texttt{Strg-$\uparrow$} beziehungsweise \texttt{Control-$\uparrow$}
(je nach Computertyp)
drückst.

\section{Rechnen ohne Zahlen}

Computerprogramme können nicht nur mit Zahlen rechnen.  In diesem
Abschnitt geht es um das Rechnen mit Text und das Rechnen mit Bildern.

\subsection{Rechnen mit Zeichenketten}

Zum Beispiel gibt es auch Text, der in einem Programm immer von
doppelten Anführungszeichen umschlossen ist, zum Beispiel:
%
\begin{alltt}
"Mike Sperber"
"Herbert Klaeren"
"Schreibe Dein Programm!"
\end{alltt}
%
Diese Werte heißen \textit{Zeichenketten\index{Zeichenkette}}.

Die einfachste Art, eine Zeichenkette herzustellen, ist, die
Buchstaben hinzuschreiben, aus denen sie besteht.  Die
Anführungszeichen müssen drumherum, um die Zeichenketten von anderen
Ausdrücken zu unterscheiden.  Die Anführungszeichen gehören aber nicht
zu den Buchstaben dazu, aus denen die Zeichenkette besteht~--
\verb|"abc"| besteht aus den drei Buchstaben \texttt{abc}.

\begin{feature}{Zeichenketten}{scheme:strings}
\textit{Zeichenketten\index{Zeichenkette}} (auf Englisch
\textit{Strings}\index{String}) repräsentieren Text.
Literale für Zeichenketten haben folgende Form:
%
\begin{alltt}
"\(z\sb{1}\)\(z\sb{2}\) \(\ldots\) \(z\sb{n}\)"
\end{alltt}
%
Dabei sind die \(z\sb{i}\) beliebige einzelne Zeichen, außer \verb|"| selbst.
Beispiel:
%
\begin{alltt}
"Herbert was here!"
\end{alltt}
%
Das Anführungszeichen (\verb|"|) kann nicht "`ungeschützt"' vorkommen, da es das Ende der
Zeichenkette markiert. Es wird als Zeichen innerhalb einer Zeichenkette
durch \verb|\"| dargestellt:
%
\begin{alltt}
"Herbert sagt, Mike wäre \backwhack{}"doof\backwhack{}"!"
\end{alltt}
\end{feature}

Abbildung~\ref{scheme:strings} beschreibt die genaue Schreibweise für
solche "`festen"' Zeichenketten.  Feste Schreibweisen für Werte heißen
allgemein \textit{Literale\index{Literal}}.  Das kennen wir schon von
den Zahlen: Die Zeichenfolge \texttt{123} steht für die Zahl
"`hundertdreiundzwanzig"'.  Kästen wie Abbildung~\ref{scheme:strings}
werden in diesem Buch noch oft dazu dienen, neue Sprachelemente
einzuführen.

Mit Text kann ein Programm auch rechnen, und zwar mit der eingebauten
Funktion
\texttt{string"=append}\index{string-append@\texttt{string-append}},
die zwei Zeichenketten aneinanderhängt:
%
\begin{alltt}
(string-append "Herbert" "Mike")
\evalsto{} "HerbertMike"
(string-append "Mike" " " "ist doof")
\evalsto{} "Mike ist doof"
\end{alltt}
%
Die eingebaute Funktion
\texttt{string-length}\index{string-length@\texttt{string-length}}
liefert die Anzahl der Buchstaben in einer Zeichenkette:
%
\begin{alltt}
(string-length "Herbert")
\evalsto{} 7
(string-length "Mike")
\evalsto{} 4
\end{alltt}
%
Die Namen \texttt{string-append} und \texttt{string-length} sehen auf
den ersten Blick "`anders"' aus als \texttt{+} und \texttt{*} zum
Beispiel, dieser Eindruck täuscht jedoch: Sie sind allesamt Namen von
vordefinierten Operationen, die Programme benutzen können, ohne sie
selbst definieren zu müssen.

Die vordefinierten Funktionen
\texttt{string->number}\index{string->number@\texttt{string->number}}
und \texttt{number->string} konvertieren zwischen Zahlen und den
Zeichenketten, die diese darstellen:
%
\begin{alltt}
(string->number "23")
\evalsto{} 23
(number->string 23)
\evalsto{} "23"
\end{alltt}
%
\begin{aufgabe}
  Mache Dir den Unterschied zwischen der Zahl \texttt{23} und der
  Zeichenkette \verb|"23"| klar.  Probiere zum Beispiel aus:
\begin{alltt}
(+ "23" 42)
(string-append 23 "42")
(number->string "23")
\end{alltt}
\end{aufgabe}

\subsection{Rechnen mit Bildern}

Programme können auch mit Bildern rechnen.  Dazu wird eine Erweiterung
zu DrRacket benötigt, ein sogenanntes
\textit{Teachpack}\index{Teachpack}: Wähle dazu den Menüpunkt
\texttt{Sprache $\rightarrow$ Teachpack hinzufügen}.  (Beziehungsweise
\texttt{Language $\rightarrow$ Add Teachpack}.  In dem Dialog, der
dann erscheint, wähle \texttt{image.rkt} aus und drücke dann
\texttt{OK}.  Dann musst Du noch einmal auf \texttt{Start} drücken.

Das Teachpack \texttt{image.rkt} enthält zusätzliche vordefinierte
Funktionen, mit denen wir Bilder herstellen können.  Zum Beispiel
\texttt{square}, \texttt{circle} und \texttt{star-polygon}:
%
\begin{alltt}
(square 40 "solid" "red")
\evalsto{} \includegraphics[height=24pt]{i1prog/square}
(circle 40 "solid" "green")
\evalsto{} \includegraphics[height=24pt]{i1prog/circle}
(star-polygon 20 10 3 "solid" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon}
\end{alltt}
%
Schauen wir uns das eingebaute \texttt{star-polygon} etwas näher an:
Es akzeptiert fünf Eingaben, die ersten drei davon sind Zahlen~-- die
Seitenlänge, die Seitenanzahl und die Anzahl der Ecken, die für jede
Seite übersprungen wird.  Danach kommen zwei Zeichenketten~--
\verb|"solid"| heißt, dass das Innere des Sterns ausgefüllt ist und
\verb|"blue"| ist die Farbe.  Statt \verb|"solid"| kannst Du auch
\verb|"outline"| schreiben, dann wird auch etwas klarer, was
"`überspringen"' heißt:
%
% filename can't contain hyphen because of alltt
\begin{alltt}
(star-polygon 20 10 3 "outline" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon_outline}
\end{alltt}
%
\begin{aufgabe}
  Wofür stehen die Zahleneingaben bei \texttt{square} und
  \texttt{circle}?  Probiere unterschiedliche Zahlen aus!  Es gibt
  auch eine eingebaute Funktion \texttt{rectangle}.  Kannst Du ein
  funktionierendes Beispiel für den Einsatz von \texttt{rectangle}
  konstruieren?  Außerdem gibt es eine eingebaute Funktion
  \texttt{ellipse}, die genauso benutzt wird wie \texttt{rectangle}~--
  probiere sie aus!
\end{aufgabe}
%
Bilder sind Werte wie Zahlen und Zeichenketten auch.  Du kannst
mit Definitionen auch Namen dafür vergeben:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))
\end{verbatim}
%
\begin{aufgabe}
  Du kannst auch Bilddateien oder Bilder in Webseiten in Dein Programm
  einfügen, wie in einem Textverarbeitsprogramm.  Probier es aus und
  gib dem Bild einen Namen!
\end{aufgabe}

%
Mit Bildern kann DrRacket auch rechnen:
%
\begin{alltt}
(beside s1 p1)
\evalsto{} \includegraphics[height=24pt]{i1prog/beside.png}
(above s1 c1)
\evalsto{} \includegraphics[width=24pt]{i1prog/above.png}
(above (beside s1 p1) (beside p1 c1))
\evalsto{} \includegraphics[width=48pt]{i1prog/abovebeside.png}
\end{alltt}
%
\begin{aufgabe}
  Probiere in der der REPL folgende Ausdrücke aus:
\begin{verbatim}
(triangle 50 "outline" "red")
(square 100 "solid" "blue")
\end{verbatim}
  %
  Schreibe mit Hilfe der Funktionen \texttt{triangle} und
  \texttt{square} einen Ausdruck, der ein ganz einfaches Haus
  berechnet.
\end{aufgabe}
%
Das heißt, \texttt{beside} akzeptiert als Eingabe zwei (oder mehr)
Bilder und macht daraus wieder ein Bild, in dem die Teilbilder
nebeneinander stehen.  Das gleiche gilt für \texttt{above}, nur dass
die Bilder übereinander angeordnet werden.  Selbstverständlich können
\texttt{above} und \texttt{beside} auch kombiniert werden.

\section{Abstraktion und Applikation}
\label{sec:abstraktion-und-applikation}

Hier sind zwei Ausdrücke, welche die Bilder aus dem vorigen Abschnitt
zu einem Muster kombinieren:
%
\begin{alltt}
(above
 (beside s1 p1)
 (beside p1 s1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(above
 (beside p1 c1)
 (beside c1 p1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Beide Ausdrücke folgen dem gleichen Muster, sie "`kacheln"' jeweils zwei
Bilder in einer quadratischen Anordnung.  Das Muster könnte man so
hinschreiben:
%
\begin{verbatim}
(above
 (beside a b)
 (beside b a))
\end{verbatim}
%
Das erste Beispiel entsteht dann, indem für \texttt{a} \texttt{s1}
eingesetzt wird und für \texttt{b} \texttt{p1}, im zweiten für \texttt{a}
\texttt{p1} und für \texttt{b} dann \texttt{c1}.

Dieses Muster kannst Du in ein Programm gießen.  Dann müssen wir nicht
jedesmal \texttt{above \ldots{} beside \ldots{} beside} eintippen.
Dazu schreibst Du es erst einmal genauso hin, also mit \texttt{a} und
\texttt{b}.  Wenn Du das Programm startet, erscheint folgende Meldung:
%
\begin{alltt}
\color{red}a: Ungebundene Variable
\end{alltt}
%
Na klar, es gibt ja auch keine Definition für \texttt{a}.  Du könntest
eine hinschreiben, zum Beispiel:
%
\begin{verbatim}
(define a s1)
\end{verbatim}
%
Aber dann wäre \texttt{a} auf \texttt{s1} festgelegt.  Wir wollen
stattdessen das Muster verallgemeinern, so dass Du es mehrmals mit
unterschiedlichen Werten für \texttt{a} und \texttt{b} verwenden
kannst.  Dieser Verallgemeinerungsprozess heißt beim Programmieren
\textit{Abstraktion\index{Abstraktion}}.  Dafür müssen wir dem Muster
noch etwas hinzufügen, um zu sagen, dass wir unterschiedliche Werte
für \texttt{a} und \texttt{b} einsetzen wollen:
%
\begin{verbatim}
(lambda (a b)
  (above
   (beside a b)
   (beside b a)))
\end{verbatim}
%
Die \texttt{lambda}\index{lambda@\texttt{lambda}} ist eine Art Zauberwort, es sagt soviel wie: "`Für
die Variablen \texttt{a} und \texttt{b} möchte ich später (und
vielleicht mehrmals) Werte einsetzen."'  Wenn Du das Programm jetzt
startest, geht die Fehlermeldung weg und in der REPL erscheint:
%
\begin{alltt}
#<function:\ldots>
\end{alltt}
%
(Der Text anstelle des \ldots{} variiert etwas von Fall zu Fall.)

Das deutet darauf hin, dass bei dem \texttt{lambda} eine Funktion
herauskommt.  Um etwas damit anfzufangen, gib ihr einen Namen mit
\texttt{define}:
%
\begin{verbatim}
(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))
\end{verbatim}
%
(Alles schön richtig einrücken! "`Tile"' heißt auf Deutsch
"`kacheln"'.)

Dadurch ist eine neue Operation entstanden.  Die kannst Du direkt
verwenden:
%
\begin{alltt}
(tile s1 p1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(tile p1 c1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Was ist da passiert?  Am einfachsten kann man das in einem speziellen
Werkzeug sehen, dem \textit{Stepper\index{Stepper}}.  Um ihn zum
Einsatz zu bringen, sorge dafür, dass im Definitionsfenster folgendes
Programm steht, also das, was weiter oben schon steht:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))

(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))

(tile s1 p1)
(tile p1 c1)
\end{verbatim}
%
Dann drück auf den \texttt{Stepper}-Knopf oben rechts im
DrRacket-Fenster.  Es erscheint ein neues Fenster, das so aussieht:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{i1prog/stepper-0}
  \caption{Der Stepper in Aktion}
  \label{fig:stepper-0}
\end{figure}
%
\noindent Du kannst jetzt mit den Knöpfen mit dem Vorwärts- beziehungsweise dem
Rückwärts-Pfeil zusehen, wie DrRacket Dein Programm ausführt.  Wenn Du
ein paar Schritte vorwärts gehst, sieht das so aus:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-1}
  \caption{Stepper: Variable ersetzen}
  \label{fig:stepper-1}
\end{figure}
%
\noindent Du kannst sehen, wie DrRacket jeweils einen Ausdruck einen Schritt auf
einmal auswertet~-- der ist auf der linken Seite grün~-- und dann
rechts durch das Resultat ersetzt.  Oben kannst Du sehen, wie der
Stepper die Variable \texttt{tile} durch den \texttt{lambda}-Ausdruck
aus der Definition von \texttt{tile} ersetzt. Das macht der Stepper
auch mit den Definitionen von \texttt{s1} und \texttt{p1}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-2}
  \caption{Stepper: Variable}
  \label{fig:stepper-2}
\end{figure}
%
\noindent Interessant wird es danach. Die Variablen aus den Definitionen sind
alle ersetzt.  Hinter dem \texttt{lambda}-Ausdruck stehen jetzt das
Quadrat und der Stern, und die werden jetzt für die Variablen aus dem
\texttt{lambda}-Ausdruck eingesetzt, also das Quadrat für \texttt{a}
und der Stern für \texttt{b}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-3}
  \caption{Stepper: Applikation}
  \label{fig:stepper-3}
\end{figure}
%
\noindent Dabei verschwindet auch das \texttt{lambda}.
%
\begin{aufgabe}
  Probiere das Beispiel im Stepper aus und klicke Dich bis zum Ende
  durch. Mache Dir dabei klar, wie jeweils die linke mit der rechten
  Seite zusammenhängt.
\end{aufgabe}
%
\texttt{(tile s1 p1)} ist eine sogenannte
\textit{Applikation\index{Applikation}}: Das ist ein Ausdruck mit
(natürlich) Klammern drum.  Der Operator und die Operanden der
Applikation sind ebenfalls Ausdrücke.  Der Operator ergibt eine
Funktion~-- entweder eingebaut oder aus einem
\texttt{lambda}-Ausdruck.  Eine Applikation wird auch oft
\textit{Funktionsaufruf\index{Funktionsaufruf}} oder
\textit{Funktionsanwendung\index{Funktionsanwendung}} genannt.

Wenn die Funktion ein \texttt{lambda}-Ausdruck ist wie in
Abbildung~\ref{fig:stepper-3}, dann muss es genauso viele Operanden
geben wie der \texttt{lambda}-Ausdruck Variablen hat.
Dann wertet DrRacket den Ausdruck wie folgt aus:
%
\begin{enumerate}
\item Die Operanden werden ausgewertet und ergeben die sogenannten
  \textit{Argumente\index{Argument}}.
\item Die Argumente werden ausgewertet und die Ergebnisse für die
  Variablen des \texttt{lambda}-Ausdrucks~-- die sogenannten
  \textit{Parameter\index{Parameter}}~-- im Innenteil des
  \texttt{lambda}-Ausdrucks, dem \textit{Rumpf\index{Rumpf}}
  eingesetzt.
\end{enumerate}
%
\begin{feature}{Abstraktion und Applikation}{scheme:abstraction}
  Eine Abstraktion\index{Abstraktion} hat folgende Form:
\begin{alltt}
(lambda (\(p\sb{1} \ldots p\sb{n}\)) \(e\))
\end{alltt}
  %
  Die $p_i$ sind jeweils Namen, die \textit{Parameter}\index{Parameter}, und
  $e$ ist der \textit{Rumpf}\index{Rumpf}.  In $e$ dürfen die $p_i$
  vorkommen.  Der Wert einer Abstraktion ist eine \textit{Funktion}\index{Funktion},
  welche für jeden Parameter eine Eingabe erwartet.

  Eine \textit{Applikation} einer Funktion hat folgende Form:
  %
\begin{alltt}
(\(p\) \(a\sb{1}\) \ldots \(a\sb{n}\))
\end{alltt}
  %
  $p$ ist ein Ausdruck, der eine Funktion ergeben muß, die $a_i$ sind
  ebenfalls Ausdrücke, die \textit{Argumente}\index{Argument}.  Bei
  der Auswertung einer Applikation werden zunächst $p$ und die $a_i$
  ausgewertet; danach geht es mit der Auswertung des Rumpfes der
  Funktion weiter, wobei für die Parameter $p_i$ jeweils die Werte der
  Argumente $a_i$ eingesetzt werden.
\end{feature}
%
\texttt{Lambda}-Ausdrücke heißen auch
\textit{Abstraktionen\index{Abstraktion}}.
Abbildung~\ref{scheme:abstraction} fasst zusammen, wie Abstraktionen
und Applikationen aufgebaut sind und ausgewertet werden.

Verwirrend ist vielleicht der Unterschied zwischen Abstraktion und
Funktion: Die Abstraktion ist der \texttt{lambda}-Ausdruck im
Programm, die Funktion ist der Wert, der bei der Programmauswertung
dabei herauskommt.  Wir verwenden im Buch aber häufig den Begriff
"`Funktion"' für eine Abstraktion, weil uns interessiert, was bei der
Abstraktion herauskommt.

\begin{aufgabe}
  Denke Dir ein einzelnes Muster aus, mit dem mehrere Bilder
  kombiniert werden können (es muss nichts kompliziertes sein) und
  schreibe eine Funktion, die dies erledigt: Benutze diese Funktion,
  um mehrere Sätze von Bildern zu kombinieren.
\end{aufgabe}

\section{Exkurs: Information und Daten}

Eine Definition wie
%
\begin{alltt}
(define mehrwertsteuer 19)
\end{alltt}
%
suggeriert, dass die Zahl 19 an dieser Stelle eine Bedeutung "`in der
realen Welt"' hat, zum Beispiel in einem Programm, das eine Registrierkasse
steuert oder das bei der Steuererklärung hilft.  Die Bedeutung könnte
folgende Aussage sein: "`Der Mehrwertsteuersatz beträgt 19\%."'
Dieser Satz repräsentiert \textit{Information}\index{Information},
also einen Fakt über die Welt oder zumindest den Ausschnitt der Welt, in
dem das Programm arbeiten soll.  In Computerprogrammen wird
Information in eine vereinfachte Form gebracht, mit der das Programm
rechnen kann~-- in diesem Fall die Zahl 19.  Diese vereinfachte Form
heißt \textit{Daten}\index{Daten}: Daten sind
\textit{Repräsentationen}\index{Repräsentation} für Information.

Eine der wichtigsten Aufgaben beim Programmieren ist, die richtigen
Form für die Daten zu wählen, um die für das Programm relevanten
Informationen darzustellen die Informationen dann in Daten zu
übersetzen.

Nicht immer ist offensichtlich, welche Information durch bestimmte
Daten repräsentiert werden.  Die Zahl 23 zum Beispiel könnte eine Reihe
von Informationen darstellen:
%
\begin{itemize}
\item die Anzahl der Haare von Bruce Willis
\item die aktuelle Außentemperatur in °C in Tübingen
\item die Außentemperatur vom 1.7.2000 in °C in Tübingen
\item die Größe in m$^2$ des Schlafzimmers
\item die Rückennummer von Alexandra Popp
\end{itemize}
%
Damit andere unsere Programme lesen können, werden wir also immer
wieder klarstellen müssen, wie Information in Daten zu übersetzen ist
und umgekehrt.

\section{Programme systematisch konstruieren}

In Abschnitt~\ref{sec:abstraktion-und-applikation} haben wir gezeigt,
wie Abstraktion und Applikation bei der Programmauswertung
funktionieren.  Das Verständnis dafür ist wichtig, aber Du musst beim
Schreiben Deines Programms nicht die ganze Zeit daran denken, wie
DrRacket Dein Programm auswertet.  Entsprechend kümmern wir uns in
diesem Buch hauptsächlich darum, wie Du Programme systematisch
konstruierst.
Schauen wir uns das anhand einer realistischen Aufgabe an:
%
\begin{aufgabe}
  \label{aufgabe:stromtarif}
  Betrachte folgende Stromtarife.  Beide Tarife
  bestehen aus einer monatlichen Grundgebühr und einem Teil, der sich
  nach den verbrauchten Kilowattstunden (kWh) richtet.
  %
  \begin{center}
    \begin{tabular}{l|c|c|}
      & Grundgebühr pro Monat & Verbrauchspreis pro kWh \\
      \hline
      Tarif "`Billig-Strom"' & \EUR{4,90} & \EUR{0.19} \\
      \hline
      Tarif "`Watt für wenig"' & \EUR{8,20} & \EUR{0.16} \\
      \hline
    \end{tabular}
  \end{center}

  \begin{enumerate}
  \item Schreibe ein Programm das den Monatsverbrauch in
    Kilowattstunden akzeptiert und den im Tarif "`Billig-Strom"' zu
    zahlenden monatlichen Rechnungsbetrag berechnet.

  \item Schreibe ein Programm, die den Monatsverbrauch in
    Kilowattstunden akzeptiert und den im Tarif "`Watt für wenig"' zu
    zahlenden monatlichen Rechnungsbetrag
    berechnet.
  \end{enumerate}
  %
\end{aufgabe}
%
Fangen wir mit dem ersten Aufgabenteil an!

\paragraph{Funktion}

Zunächst einmal: Da steht "`Schreibe ein Programm~\ldots"'.  In den
Lehrsprachen dieses Buchs heißt das immer "`Schreibe eine
\emph{Funktion}~\ldots"'.  Später werden wir Programme schreiben, die
neben der "`Hauptfunktion"' noch "`Hilfsfunktionen"' haben, aber das
Prinzip bleibt immer das gleiche.

Wenn dort steht, "`das den Monatsverbrauch in Kilowattstunden
akzeptiert"', dann bedeutet dies, dass die Funktion den
Monatsverbraucht als Eingabe akzeptieren soll~-- also als Argument.

Ebenso bedeutet "`und den \ldots{} zu zahlenden monatlichen
Rechnungsbetrag berechnet"', dass die Funktion diesen Rechungsbetrag
als Ergebnis liefern soll.

\paragraph{Gerüst}

Funktionen, die ein Problem aus einer Aufgabenstellung lösen, sollten
immer einen Namen haben~-- den sollten wir uns gleich am Anfang
ausdenken.  Der Name \texttt{billig-strom} bietet sich an.  Wir wissen
schon, dass sie den Verbrauch in Kilowattstunden akzeptiert.  Wenn wir
uns noch dafür einen Namen ausdenken, können wir direkt ein unfertiges
Programm hinschreiben, ohne groß nachzudenken:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    ...))
\end{verbatim}
%
\emph{Wichtig:} Schreibe dieses \textit{Gerüst\index{Gerüst}}
unbedingt hin, auch wenn Du noch keine Vorstellung hast, wie es danach
weitergeht.  Immer.  Jedes Mal.

\paragraph{Rumpf}

Für das Berechnen des Rechnungsbetrags können wir eine Formel
aufschreiben, indem wir auf die Grundgebühr das Produkt aus dem
Verbrauchspreis addieren.  Entsprechend müssen wir den Rumpf\index{Rumpf} der
Funktion ergänzen:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (+ 4.90 (* 0.19 kWh))))
\end{verbatim}
%
Die Funktion \texttt{billig-strom} kannst Du jetzt aufrufen:
%
\begin{alltt}
(billig-strom 10)
\evalsto{} 6.8
(billig-strom 20)
\evalsto{} 8.7
(billig-strom 30)
\evalsto{} 10.6
\end{alltt}
%
Die Funktion \texttt{billig-strom} ist ein einigermaßen winziges
Programm.  Wenn Programme größer werden, ist häufig nicht mehr
unmittelbar ersichtlich, was die Programmteile tun oder ob sie
tatsächlich korrekt sind.  Es ist darum sinnvoll, die Funktion mit
einigen Programmelementen zu ergänzen, welche die Verständlichkeit
erhöhen und auch die Wahrscheinlichkeit, dass die Funktion korrekt
ist.

\paragraph{Kurzbeschreibung}
Wir fangen dazu an mit einer kurzen Beschreibung auf Deutsch (der
sogenannten \textit{Kurzbeschreibung\index{Kurzbeschreibung}}, die
beschreibt, was die Funktion macht.  Eine prägnante Zeile ist dabei
genug.  Das könnte so aussehen:
%
\begin{verbatim}
; monatlichen Rechnungsbetrag für Tarif Billig-Strom berechnen

(define billig-strom ...)
\end{verbatim}
%
\begin{feature}{Kommentare}{scheme:comment}
  Ein Semikolon \texttt{;} kennzeichnet einen 
  \textit{Kommentar\index{Kommentar}}.  Der Kommentar erstreckt sich
  vom Semikolon bis zum Ende der Zeile und wird von DrRacket
  ignoriert.
\end{feature}
%
Das Semikolon am Anfang kennzeichnet die Zeile als
\textit{Kommentar\index{Kommentar}}. DrRacket ignoriert diese Zeile
beim Auswerten, aber für menschliche Leserinnen ist sie nützlich.
Abbildung~\ref{scheme:comment} fasst zusammen, wie das Semikolon
funktioniert.

\paragraph{Signatur} Als nächstes ergänzen wir eine \textit{Signatur\index{Signatur}}, die
beschreibt, was für Daten die Funktion als Argumente erwartet und was
für Daten sie liefert.

Die Anzahl der Kilowattstunden auf dem Zählerableseblatt ist in der
Regel eine ganze Zahl, die nicht negativ sein kann.  Die Ausgabe kann
hingegen zwei Nachkommestellen enthalten, ist also ein Bruch.  Um die
Signatur zu schreiben, benutzen wir für diese Beschreibungen dieser
\textit{Sorten\index{Sorte}} mathematische Namen.  Eine ganze,
nicht-negative Zahl heißt auch \textit{natürliche
  Zahl\index{natürliche Zahl}}.  Ein Bruch heißt auch
\textit{rationale Zahl\index{rationale Zahl}}.  Die
Signatur-Deklaration für \texttt{billig-strom} sollte gleich nach der
Kurzbeschreibung kommen und sieht so aus:
%
\begin{verbatim}
(: billig-strom (natural -> rational))
\end{verbatim}
%
Die Elemente \texttt{natural} und \texttt{rational} sind die
Lehrsprachen-Namen für natürliche Zahlen respektive Brüche.

Diese Signatur-Deklaration besteht aus der Form \texttt{(: \ldots)},
dem Namen der Funktion und ihrer Signatur, \texttt{(natural ->
  rational)}.  Wir werden noch einer Vielzahl von Signaturen begegnen,
aber diese hier hat einen Pfeil \texttt{->} in der Mitte und ist
deshalb eine Signatur für eine Funktion: links vom Pfeil steht, was
die Funktion als Eingabe akzeptiert, rechts vom Pfeil die Ausgabe. Die
Signatur-Deklaration ist also so zu lesen: "`\texttt{Billig-strom} ist
eine Funktion, die eine natürliche Zahl als Eingabe akzeptiert und
eine rationale Zahl als Ausgabe produziert."'

\begin{feature}{Signaturen}{scheme:signature}
  Eine \textit{Signatur\index{Signatur}} beschreibt eine Menge oder
  Sorte von Werten.  Folgende Signaturen für Zahlenmengen sind
  eingebaut:
  %
  \begin{flushleft}
    \begin{tabular}{ll}
      \texttt{natural\index{natural@\texttt{natural}}} & natürliche
                                                         Zahlen\index{natürliche
                                                         Zahlen} ($0, 1, 2\ldots$)\\
      \texttt{integer\index{integer@\texttt{integer}}} & ganze
                                                         Zahlen\index{ganze
                                                         Zahlen}($0, 1, -1, 2, -2, \ldots$)\\
      \texttt{rational\index{rational@\texttt{rational}}} &
                                                            Brüche\index{Bruch} / rationale Zahlen\index{rationale Zahlen} \\
      \texttt{real\index{real@\texttt{real}}} & reelle
                                                Zahlen\index{reelle Zahlen}\\
      \texttt{number\index{number@\texttt{number}}} & beliebige Zahlen
    \end{tabular}
  \end{flushleft}
  %
  Diese Liste bildet einen "`Turm"': Jede natürliche Zahl ist auch eine
  ganze Zahl (da kommen noch die negativen Zahlen hinzu), jede ganze
  Zahl ist auch eine rationale Zahl (Brüche mit Nenner ungleich 1
  kommen hinzu), jede rationale Zahl ist eine reelle Zahl
  (nicht-rationale Zahlen wie $\sqrt{2}$ kommen hinzu, und jede reelle
  Zahl ist auch eine Zahl (komplexe Zahlen\index{komplexe Zahlen} kommen hinzu).
  
  Diese Liste wird in zukünftigen Kapiteln noch erweitert werden.

  Signaturen für Funktionen haben die Form
%
\begin{alltt}
(\(s\sb{1}\) \ldots \(s\sb{n}\) -> \(s\))
\end{alltt}
%
Die Signaturen $s_1 \ldots s_n$ sind die Signaturen für die Argumente
der Funktion und $s$ die Signatur für das Ergebnis.

Eine \textit{Signatur-Deklaration\index{Signatur-Ddeklaration}} hat
folgende Form:
%
\begin{alltt}
(: \(v\) : \(s\))
\end{alltt}
%
Sie sagt aus, dass der Wert der Variablen \(v\) zu der Menge gehört,
die durch die Signatur \(s\) beschrieben ist.
\end{feature}
%
Abbildung~\ref{scheme:signature} beschreibt das Format von Signaturen
und Signatur-Deklarationen genauer.

\paragraph{Tests} Wir haben oben in der REPL die Funktion
\texttt{billig-strom} ausprobiert, indem wir DrRacket mehrere Aufrufe
mit unterschiedlichen Eingaben habne auswerten lassen.  Anhand dieser
Beispiele können wir auch (vielleicht mit einem Taschenrechner)
überprüfen, ob die Funktion dabei korrekte Ergebnisse produziert hat.

Diese Beispielaufrufe sind noch hilfreicher für Leserinnen und Leser,
wenn sie im Programm stehen.  Gepaart mit den erwünschten Ergebnissen
erleichtern sie das Verständnis.  Im Programm schreiben schreiben wir
das folgendermaßen, gleich nach der Signatur:
%
\begin{alltt}
(check-expect (billig-strom 10) 6.8)
(check-expect (billig-strom 20) 8.7)
(check-expect (billig-strom 30) 10.6)
\end{alltt}
%
Wenn wir jetzt das Programm laufen lassen, steht in der REPL:
%
\begin{verbatim}
Alle 3 Tests bestanden!
\end{verbatim}
%
Das neue Programmelement
\texttt{check-expect\index{check-expect@\texttt{check-expect}}} (siehe
Abbildung~\ref{scheme:test}) macht
nämlich einen sogenannten \textit{Testfall\index{Testfall}} oder \textit{Test\index{Test}}.  In diesem Falle
meldet DrRacket, dass mit den Tests alles geklappt hat.  Aber das
Programm könnte einen Fehler enthalten.  Wenn wir in der Definition
von \texttt{billig-strom} statt \texttt{4.90} "`versehentlich"'
\texttt{5.90} schreiben, sieht die Ausgabe anders aus:
%
\begin{feature}{Tests}{scheme:test}
  Ein \textit{Test\index{Test}} hat die folgende Form:
  %
\begin{alltt}
(check-expect \(t\) \(e\))
\end{alltt}
%
Wenn das Programm läuft, wertet DrRacket den Test-Ausdruck $t$ aus und
überprüft, ob er mit dem Wert des Ausdrucks $e$ übereinstimmt.  Wenn
nicht, schlägt der Test fehl und wird von DrRacket protokolliert.
\end{feature}
%
\begin{verbatim}
Check-Fehler:
	Der tatsächliche Wert 7.8 ist nicht der erwartete Wert 6.8.
in stromtarif.rkt, Zeile 5, Spalte 0 
	Der tatsächliche Wert 9.7 ist nicht der erwartete Wert 8.7.
in stromtarif.rkt, Zeile 6, Spalte 0 
	Der tatsächliche Wert 11.6 ist nicht der erwartete Wert 10.6.
in stromtarif.rkt, Zeile 7, Spalte 0 
\end{verbatim}
%
Die Tests weisen uns also auf mögliche Fehler hin.  Das ist so
wertvoll, dass wir in Zukunft \emph{immer} Tests schreiben werden, und
zwar nach der Signatur.  Insbesondere werden wir die Tests schreiben,
\emph{bevor} wir die Definition angehen.  Das nervt manchmal, ist aber
psychologisch sinnvoll, damit wir uns vorher überlegen wie das
richtige Verhalten der Funktion aussehen soll.  Wenn wir die Tests
hinterher schreiben, ist die Versuchtung groß, die Funktion einfach in
der REPL aufzurufen und das tatsächliche Ergebnis in den Test zu
übernehmen, ohne es auf Korrektheit zu überprüfen.

Bei den drei Tests oben müssten wir vielleicht, wenn wir sie vorher
schrieben, einen Taschenrechner bemühen.  Es gibt aber fast immer
mindestens einen möglichen Test, der ganz einfach ist.  In diesem Fall
ist das:
%
\begin{verbatim}
(check-expect (billig-strom 0) 4.9)
\end{verbatim}
%
Hier können wir das Ergebnis direkt der Tabelle entnehmen.  Dieser
überprüft zwar nicht, ob der richtige pro-kWh-Preis berechnet wird,
ist aber so einfach zu schreiben, dass wir die Gelegenheit nicht
auslassen sollten, ihn zu schreiben.

Wieviele Tests sollte man schreiben?  Das hängt von der Komplexität
der Funktion ab.  Aber drei sollten es bei einfachen Funktionen
mindestens sein, bei komplizierteren mehr.  Ein einfaches weiteres
Kriterium ist, dass jeder Teil des Programms, das wir geschrieben
haben, im Laufe der Tests einmal ausgewertet werden sollte.  DrRacket
kann Dir dabei helfen.

Wenn Du das Programm nur auf die Funktionsdefinition reduzierst (also
alle Tests und Beispielaufrufe entfernst) und dann laufen lässt,
sollte Dir auffallen, dass der Rumpf von \texttt{billig-strom} blau
hinterlegt ist.  (Außerdem Teile der Signatur von
\texttt{billig-strom}.)  Diese Hinterlegung zeigt die sogenannte
\textit{Coverage\index{Coverage}} an: Die blau hinterlegten
Programmteile sind noch nie gelaufen und wurden ergo auch noch nicht
getestet.  Es fehlen also noch Tests.  In Zukunft achten wir also
darauf, dass, nachdem das Programm gelaufen ist, nichts blaues
übrigbleibt~-- andernfalls müssen wir mehr Tests schreiben kann.

Bei Programmen, die Bilder erzeugen, ist es in der Regel nicht
möglich, die Testfälle vorher zu schreiben.  Du kannst aber Beispiele
ausprobieren, die Du Dir vorher überlegt hast, und diese visuell überprüfen.
Wenn Dir ein Ergebnis richtig erscheint, kannst Du das Bild aus der
REPL kopieren in das Programm kopieren.  In der REPL könnte das so aussehen:
%
\begin{alltt}
(square 40 "solid" "red")
\evalsto{} \includegraphics[height=24pt]{i1prog/square}
\end{alltt}
%
Du kannst dann das Quadrat aus der REPL kopieren, also zum Beispiel
mit der Maus markieren und dann mit \texttt{Ctrl-C} beziehungsweise
\texttt{Command-C} kopieren und dann ins Programm mit \texttt{Ctrl-V}
beziehungsweise \texttt{Command-V} einfügen und dann daraus folgenden
Test machen:
%
\begin{alltt}
(check-expect (square 40 "solid" "red") \includegraphics[height=24pt]{i1prog/square})
\end{alltt}

\begin{aufgabe}
  Schreibe für \texttt{tile} zwei Tests!
\end{aufgabe}

\section{Konstruktionsanleitungen}
%
Wir haben im vorigen Abschnitt folgende Arbeitsschritte kennengelernt,
die zu einer Funktion führen:
%
\begin{itemize}
\item Gerüst
\item Kurzbeschreibung
\item Signatur-Deklaration
\item Tests
\item Rumpf
\end{itemize}
%
Diese Reihenfolge ist der Reihenfolge ihrer Einführung in diesem
Kapitel geschuldet.  Zukünftig ist es sinnvoll, dass wir diese Schritte
immer in der gleichen und zwar in folgender Reihenfolge durchführen:
%
\begin{itemize}
\item Kurzbeschreibung
\item Signatur
\item Tests
\item Gerüst
\item Rumpf
\end{itemize}
%
Dies entspricht auch der Reihenfolge, in der die entsprechenden
Elemente im Programm stehen: Wenn Du diese Reihenfolge befolgst,
kannst Du Dein Programm einfach "`herunterschreiben"'.

Eine solche Anleitung zur Konstruktion von Programmen nennen wir in
diesem Buch
\textit{Konstruktionsanleitung\index{Konstruktionsanleitung}}.  Da
noch viele weitere Konstruktionsanleitungen hinzukommen werden,
bekommen sie Nummern.  Wir fügen gleich noch zwei weitere Elemente
hinzu~-- Datenanalyse und Schablonen~-- die wir in späteren Kapiteln
erläutern werden.

\begin{konstruktionsanleitung}[Ablauf]
  Gehe bei der Konstruktion einer Funktion in folgender Reihenfolge
  vor:
  \begin{itemize}
    \item Kurzbeschreibung
    \item Datenanalyse
    \item Signatur
    \item Tests
    \item Gerüst
    \item Schablonen
    \item Rumpf
    \end{itemize}
\end{konstruktionsanleitung}
%
Es mag Dir übermäßig bürokratisch vorkommen, immer die gleiche
Reihenfolge einzuhalten.  Bürokratisch ist das in jedem Fall, ist aber
eine wertvolle Hilfestellung, die verhindert, dass Du in unnötige
Sackgassen gerätst.

Diesen Ablauf demonstruieren wir anhand des zweiten Teils von Aufgabe~
\ref{aufgabe:stromtarif}.  Zur Erinnerung:  Es ging um den Tarif
"`Watt für Wenig"' mit einem Grundbetrag von \EUR{8,20} und einem
Verbrauchspreis pro kWh von \EUR{0,16}.

\paragraph{Kurzbeschreibung}

Fangen wir mit der Kurzbeschreibung an.  Die können wir entsprechend
zu "`Billig-Strom"' formulieren:
\begin{verbatim}
; monatlichen Rechnungsbetrag für Tarif Watt für wenig berechnen
\end{verbatim}

\paragraph{Signatur}

Auch die Signatur-Deklaration können wir analog zu "`Billig-Strom"'
formulieren~-- wir müssen uns nur einen neuen Namen aussuchen:
%
\begin{verbatim}
(: watt-für-wenig (natural -> rational))
\end{verbatim}

\paragraph{Tests}

Die Tests müssen wir neu formulieren.  Es ist immer sinnvoll, mit dem
einfachsten Beispiel anzufangen:
\begin{verbatim}
(check-expect (watt-für-wenig 0) 8.2)
\end{verbatim}

Ansonsten nehmen wir wieder progressiv größere Verbrauchswerte und
rechnen den Rechnungsbetrag im Kopf aus:
%
\begin{verbatim}
(check-expect (watt-für-wenig 10) 9.8)
(check-expect (watt-für-wenig 20) 11.4)
(check-expect (watt-für-wenig 30) 13.0)
\end{verbatim}

\paragraph{Gerüst}

Das Gerüst ergibt sich direkt aus der Signatur:
%
\begin{verbatim}
(define watt-für-wenig
  (lambda (kWh)
    ...))
\end{verbatim}

\paragraph{Rumpf}

Schließlich müssen wir noch den Rumpf vervollständigen, indem wir die
entsprechende Formel hineinschreiben:
%
\begin{verbatim}
(define watt-für-wenig
  (lambda (kWh)
    (+ 8.20 (* 0.16 kWh))))
\end{verbatim}
%
Fertig!

\section{Die Macht der Abstraktion}

Wir haben bei Aufgabe~\ref{aufgabe:stromtarif} für die beiden
Aufgabenteile völlig voneinander unabhängige Lösungen geschrieben.
Diese unterscheiden sich allerdings nur in Details~-- in beiden Fällen
wird der Stromtarif aus einer Grundgebühr und einem Verbrauchspreis
pro kWh mit der gleichen Formel berechnet.  Die Definitionen ähneln
sich dementsprechend:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (+ 4.90 (* 0.19 kWh))))

(define watt-für-wenig
  (lambda (kWh)
    (+ 8.20 (* 0.16 kWh))))
\end{verbatim}
%
Diese "`Verdoppelung"' ist unbefriedigend und kann auch später
Probleme machen: Wenn ein Fehler bekannt wird, müssen möglicherweise
zwei Funktionen korrigiert werden beispielsweise.

Es wäre also gut, wenn wir die Gemeinsamkeiten der beiden Funktionen
irgendwie zusammenfassen könnten, mithin über \texttt{billig-strom}
und \texttt{watt-für-wenig} \textit{abstrahieren\index{Abstraktion}}
könnten.  Dazu kopieren wir die Funktion ein letztes Mal und benennen
sie um.  Außerdem ersetzen wir alle Stellen, bei denen sich die beiden
Funktionen unterscheiden, jeweils durch eine Variable, zum Beispiel
\texttt{grundgebuehr} und \texttt{pro-kWh}:
%
\begin{verbatim}
(define stromtarif-rechnungsbetrag
  (lambda (kWh)
    (+ grundgebuehr (* pro-kWh kWh))))
\end{verbatim}
%
Die beiden neuen Variablen sind noch nicht gebunden, wir müssen sie zu
den Parametern des \texttt{lambda} hinzufügen:
%
\begin{verbatim}
(define stromtarif-rechnungsbetrag
  (lambda (grundgebuehr pro-kWh kWh)
    (+ grundgebuehr (* pro-kWh kWh))))
\end{verbatim}
%
Wir ergänzen noch Kurzbeschreibung und Signatur.  Die neuen Parameter
sind auch beides rationale Zahlen, das sieht also so aus:
%
\begin{verbatim}
; monatlichen Rechnungsbetrag für Stromtarif berechnen
(: stromtarif-rechnungsbetrag (rational rational rational -> rational))
\end{verbatim}
%
Außerdem sollten wir Tests formulieren.  Diese können wir aus den
Tests für \texttt{billig-strom} und \texttt{watt-für-wenig} gewinnen.
Wir müssen nur jeweils zu den Argumenten noch die Grundgebühr
beziehungsweise den pro-kWh-Preis hinzufügen:
%
\begin{verbatim}
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 10) 6.8)  ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 20) 8.7)  ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 30) 10.6) ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 0) 4.9)   ; Billig-Strom

(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 0) 8.2)   ; Watt für wenig

(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 10) 9.8)  ; Watt für wenig
(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 20) 11.4) ; Watt für wenig
(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 30) 13.0) ; Watt für wenig
\end{verbatim}
%
Schließlich können wir auch die Definitionen von \texttt{billig-strom}
und \texttt{watt-für-wenig} so ändern, dass sie nicht mehr "`selbst"'
den Rechnungsbetrag ausrechnen, sondern dafür
\texttt{stromtarif"=rechnungsbetrag} benutzen:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (stromtarif-rechnungsbetrag 4.90 0.19 kWh)))

(define watt-für-wenig
  (lambda (kWh)
    (stromtarif-rechnungsbetrag 8.20 0.16 kwH)))
\end{verbatim}
%
Zu dieser Technik werden wir in diesem Buch noch oft greifen.  Sie
erspart nicht nur oft Arbeit und macht unsere Programme leichter zu
handhaben, sondern führt manchmal zu ganz neuen Erkenntnissen~--
speziell in Kapitel~\ref{cha:higher-order}.

% \section{Domänenwissen}
% \label{sec:domaenenwissen}

% Hier ist eine einfache Denksportaufgabe:
% %
% \begin{quote}
%   Auf einem Parkplatz stehen PKWs und Motorräder ohne Beiwagen.
%   Zusammen seien es $n$ Fahrzeuge mit insgesamt $m$ Rädern.  Bestimmen
%   Sie die Anzahl $P$ der PKWs.
% \end{quote}
% %
% Die Anzahl $P$ der PKWs plus die Anzahl $M$ der Motorräder muß
% offensichtlich die Gesamtzahl $n$ der Fahrzeuge ergeben.  Außerdem hat
% jeder PKW vier Räder und jedes Motorrad zwei Räder. Die Radzahlen der
% PKWs und Motorräder zusammen müssen $m$ ergeben.  Es ergibt sich
% folgendes Gleichungsystem:
% %
% \begin{eqnarray*}
%   P+M&=&n\\
%   4P+2M&=&m
% \end{eqnarray*}
% %
% Auflösen der ersten Gleichung nach $M$ ergibt
% \begin{eqnarray*}
%   M &=& n-P
% \end{eqnarray*}
% % 
% und Einsetzen in die zweite Gleichung führt zu
% \begin{eqnarray*}
%   4P+2(n-P) &=& m\\
%   4P+2n-2P &=& m\\
%   2P &=& m-2n\\
%   P &=& \frac{m-2n}{2}
% \end{eqnarray*}
% %
% Am Ende steht also eine Formel, die wir für konkrete $m$ und $n$ auch
% in einen Ausdruck verwandeln können:
% %
% \begin{alltt}
% (/ (- 10 (* 2 4)) 2)
% \evalsto{} 1
% (/ (- 12 (* 2 3)) 2)
% \evalsto{} 3
% \end{alltt}
% %
% Um zu den Ausdrücken zu kommen, welche die Anzahl der PKWs ausrechnen,
% haben wir sogenanntes \textit{Domänenwissen}\index{Domänenwissen}
% benutzt: Die "`Domäne"' der Aufgabe sind PKWs und Motorräder, und wir
% wissen, dass PKWs jeweils vier Räder und Motorräder zwei haben.
% Schließlich haben wir noch Algebra benutzt, um aus dem Domänenwissen
% eine Formel zu machen.

% \section{Kommentare und Formatierung}

% Der Ausdruck \texttt{(/ (- 10 (* 2 4)) 2)} ist für unbedarfte Leser
% schwer zu verstehen.  Manchmal hilft ein erläuternder Text beim
% Verständnis:
% %
% \begin{alltt}
% (/ (- 10 (* 2 4)) 2) ; 10 Räder, 4 Fahrzeuge
% \evalsto{} 1
% (/ (- 12 (* 2 3)) 2) ; 12 Räder, 3 Fahrzeuge
% \evalsto{} 3
% \end{alltt}

% %
% Der Text nach dem Semikolon ist ein \textit{Kommentar}\index{Kommentar} (siehe
% Abbildung~\ref{scheme:comment}), der von DrRacket ignoriert wird, aber
% für menschliche Leser hilfreich ist.

% Beim Verständnis kann außerdem die
% \textit{Formatierung}\index{Formatierung} des Programms helfen.  Die
% obigen Ausdrücke können auch folgendermaßen geschrieben werden:
% %
% \begin{alltt}
% (/ (- 10 (* 2 4))
%    2)
% (/ (- 12 (* 2 3))
%    2)
% \end{alltt}
% %
% Daß die \texttt{2} jetzt jeweils in einer weiteren Zeile steht, läßt
% die Ausdrücke so ähnlich aussehen wie der Bruch in der Formel.  Die
% Einrückung vor der \texttt{2} macht klar, dass die \texttt{2} noch in
% die Klammern vom \texttt{/} gehört.

% Wir als Programmierer müssen uns selbst darum kümmern, an sinnvollen
% Stellen eine neue Zeile anzufangen.  Um die Einrückung kann sich
% allerdings DrRacket automatisch kümmern: Die Tab-Taste (links auf der
% Tastatur, meist $\rightarrow$\verb/|/ o.ä.\ bedruckt) rückt die Zeile,
% in der sich der Cursor befindet, ein.  Außerdem gibt es noch den
% Menüpunkt \texttt{Racket} $\rightarrow$ \texttt{Alles einrücken}, der
% das gesamte Programm einrückt.

% \section{Abstraktion}

% Beim Parkplatzproblem aus Abschnitt~\ref{sec:domaenenwissen} ist es
% umständlich, für jede Kombination aus konkreten $m$ und $n$ die 
% Formel neu hinzuschreiben und andere Werte für $m$ und $n$
% einzusetzen.  Außerdem ist es fehleranfällig.  Es muß also besser
% gehen.  Ein erster Schritt in die richtige Richtung ist, für $m$ und
% $n$ auch im Programm Namen zu verwenden:
% %
% \begin{alltt}
% (define n 4)
% (define m 10)
% (/ (- m (* 2 n)) 2)
% \end{alltt}
% %
% Immerhin ist die ursprüngliche Formel jetzt wieder erkennbar.  Leider
% kann sie nur einmal verwendet werden.  Schreiben wir in dasselbe
% Programm die hier darunter:
% %
% \begin{alltt}
% (define n 3)
% (define m 12)
% (/ (- m (* 2 n)) 2)
% \end{alltt}
% %
% \ldots{} dann meckert DrRacket:
% %
% \begin{alltt}
% m: Für diesen Namen gibt es schon eine Definition
% \end{alltt}
% %
% Für jeden Namen kann es nur eine Definition geben.  Wir bräuchten
% Formeln, die wir mehrfach verwenden können, bei denen wir sagen können
% "`ich werde die Formeln mehrmals benutzen und möchte jedesmal andere
% Werte für $n$ und $m$ einsetzen"'. Das geht beim Programmieren mit
% \textit{Abstraktion}\index{Abstraktion} und sieht konkret so aus:
% %
% \begin{alltt}
% (lambda (n m) (/ (- m (* 2 n)) 2))
% \end{alltt}
% %
% Diese Abstraktion besteht aus folgenden Bestandteilen:
% \begin{itemize}
% \item das Schlüsselwort \texttt{lambda},
% \item die Namen \texttt{n} und \texttt{m}, die \textit{Parameter},\index{Parameter}
% \item der Ausdruck \texttt{(/ (- m (* 2 n)) 2)}, der \textit{Rumpf\index{Rumpf}}.
% \end{itemize}
% %
% Die Abstraktion hat als Wert eine \textit{Funktion\index{Funktion}}.  Wenn der
% $lambda$-Ausdruck so in einem Programm steht, druckt beim Auswerten
% DrRacket auch aus:
% %
% \begin{alltt}
% #<procedure>
% \end{alltt}
% %
% Für sich genommen macht eine Funktion noch nichts Interessantes.  Sie kann jedoch
% \emph{angewendet} werden, was heißt, dass konkrete Werte für $m$ und
% $n$ eingesetzt werden:
% %
% \begin{alltt}
% ((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
% \evalsto{} 1
% ((lambda (n m) (/ (- m (* 2 n)) 2)) 3 12)
% \evalsto{} 3
% \end{alltt}

% % 
% Abbildung~\ref{scheme:abstraction} erklärt die beiden Konzepte
% "`Abstraktion"' und "`Applikation"' im allgemeinen.

% Bisher ist jedoch noch nicht viel gewonnen, weil wir den
% $lambda$-Ausdruck jedesmal wiederholen mußten.  Da er jedoch beide
% Male genau gleich ist, können wir ihm mit \texttt{define} einen Namen
% geben:
% %
% \begin{alltt}
% (define parking-lot-cars
%   (lambda (n m) (/ (- m (* 2 n)) 2)))
% \end{alltt}
% %
% Am besten verteilen wir das Programm gleich noch auf etwas mehr Zeilen
% und rücken es ein, um es lesbarer zu machen:
% %
% \begin{alltt}
% (define parking-lot-cars
%   (lambda (n m)
%     (/ (- m (* 2 n))
%        2)))
% \end{alltt}
% %
% \texttt{Parking-lot-cars} können wir jetzt mehrfach verwenden:
% %
% \begin{alltt}
% (parking-lot-cars 4 10)
% \evalsto{} 1
% (parking-lot-cars 3 12)
% \evalsto{} 3
% \end{alltt}
% %
% Das sieht doch schon besser aus: Der Name \texttt{parking-lot-cars}
% ist außerdem sprechend und erlaubt uns, die eigentliche Formel auch
% wieder zu vergessen.

% % FIXME: Warum heißt es eigentlich $lambda$?

% \section{Kurzbeschreibung und Signatur}
% \label{sec:sorts-and-contracts}

% Angenommen, die Funktiondefinition von \texttt{parking-lot-cars} wird
% an jemanden weitergegeben, der dieses Buch nicht gelesen hat, aber die
% Funktion trotzdem einsetzen soll.  Der potentielle Leser kann zwar
% das Scheme-Programm prinzipiell verstehen, hat aber keinen weiteren
% Hinweis darauf, wofür \texttt{parking-lot-cars} verwendet werden kann.

% Das Problem ist, daß die Definition von \texttt{parking-lot-cars} 
% das Endprodukt des Denkprozesses ist, der in Kapitel~\ref{cha:intro}
% beschrieben wurde.  Der Denkprozeß selbst, der mit der Aufgabenstellung
% anfängt, ist nicht Teil der Definition.  Darum ist es hilfreich, wenn
% wichtige Aspekte des Denkprozesses als Kommentare  bei den Definitionen
% stehen.  Ein stets sinnvoller Kommentar ist eine \textit{Kurzbeschreibung}\index{Kurzbeschreibung} der
% Aufgabenstellung:
% %
% \begin{alltt}
% ; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
% \end{alltt}
% %
% Für die Kurzbeschreibung reicht in der Regel \emph{eine Zeile}: Nehmen
% Sie diese Einschränkung als Gelegenheit, sich knapp, prägnant und
% präzise auszudrücken.

% Als nächstes ist eine besondere Formulierung hilfreich, die
% sogenannte \textit{Signatur\index{Signatur}}. Wer nur gelesen hat, dass die
% Funktion \texttt{parking-lot-cars} zwei Argumente \texttt{n} und
% \texttt{m} hat, könnte ja auf den Gedanken kommen, einen Aufruf der
% Form

% \begin{alltt}
% (parking-lot-cars "zweiundzwanzig" "achtunddreissig")
% \end{alltt}
% zu notieren.  Das wird bei der Ausführung eine Fehlermeldung erzeugen, weil die
% eingebauten Funktionen \texttt{/}, \texttt{-} und \texttt{*} nur mit Zahlen in
% Form von Ziffernfolgen umgehen können, aber nicht mit Zeichenketten, die
% vielleicht auch Zahlen bezeichnen könnten.  In der Tat akzeptieren fast alle
% Funktionen nur Argumente einer ganz bestimmten \emph{Sorte}\index{Sorte}, in
% diesem Fall Argumente der Sorte "`natürliche Zahl"'.

% Hier eine Liste der wichtigsten "`eingebauten"' Sorten:
% %
% \begin{center}
%   \begin{tabular}{l|l}
%     natürliche Zahlen & \texttt{natural}\\\hline
%     ganze Zahlen & \texttt{integer}\\\hline
%     rationale Zahlen & \texttt{rational}\\\hline
%     reelle Zahlen & \texttt{real}\\\hline
%     Zahlen allgemein (inkl.\ komplexe) & \texttt{number}\\\hline
%     Zeichenketten & \texttt{string}\\\hline
%     Bilder & \texttt{image}
%   \end{tabular}
% \end{center}
% %
% Eine Signatur\index{Signatur}
% ist eine Vorstufe für die zu entwickelnde Funktion und faßt einige
% wichtige Informationen zusammen:
% %
% \begin{enumerate}
% \item den Namen der Funktion,
% \item Anzahl und Sorten der Argumente und
% \item die Sorte des Rückgabewerts der Funktion.
% \end{enumerate}
% %
% %Die \textit{Signaturen}\index{Signaturen} beschreiben die Sorten, aus
% %denen die Argumente bzw.\ der Rückgabewert stammen.  
% Die Funktion
% \texttt{parking-lot-cars} akzeptiert zwei natürliche Zahlen und
% liefert wieder eine natürliche Zahl.  Deshalb sieht die Signatur von
% \texttt{parking-lot-cars} so aus:
% %
% \begin{alltt}
% (: parking-lot-cars (natural natural -> natural))
% \end{alltt}
% %
% %Damit wird die Signatur \verb|(natural natural -> natural)| der
% %Funktion \texttt{parking-lot-cars} zugeordnet.  
% Diese Signatur besagt:
% %
% \begin{itemize}
% \item \texttt{Parking-lot-cars} ist eine Funktion (das sagt der Pfeil
%   \verb|->| zusammen mit den Klammern);
% \item \texttt{parking-lot-cars}
%   \textit{akzeptiert}\index{akzeptieren} zwei Argumente (vor dem Pfeil
% stehen zwei Wörter);
% \item die beiden Argumente sind natürliche Zahlen (\texttt{natural});
% \item die Funktion liefert wieder eine natürliche Zahl (das ist
% das \texttt{natural} hinter dem Pfeil).
% \end{itemize}
% %
% Die Signatur ähnelt also der mathematischen Notation für Funktionen,
% die einen bestimmten Typ haben.

% Aus der Signatur ergeben sich, wenn für die beiden Argumente
% sprechende Namen gefunden worden sind, die ersten beiden Zeilen der folgenden
% Definition, das sogenannte \textit{Gerüst\index{Gerüst}}:
% %
% \begin{alltt}
% (define parking-lot-cars
%   (lambda (n m)
%     ...))
% \end{alltt}
% %
% Es bleibt, die passende Formel einzusetzen.  Die Definition
% von \texttt{parking-lot-cars} sieht dann vollständig so aus:\index{parking-lot-cars@\texttt{parking-lot-cars}}
% %
% \begin{alltt}
% ; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
% (: parking-lot-cars (natural natural -> natural))
% (define parking-lot-cars
%   (lambda (n m)
%     (/ (- m (* 2 n))
%        2)))
% \end{alltt}
% %
% Signaturen können für alle Arten von Werten deklariert werden, nicht
% nur für Funktionen.  Zum Beispiel so:
% %
% \begin{verbatim}
% (: pi real)
% \end{verbatim}
% %
% Bei \texttt{parking-lot-cars} ist die Signatur noch nicht besonders
% umfangreich oder kompliziert.
% Spätere Kapitel werden zeigen, dass sich aus vielen Signaturen ganz
% automatisch \textit{Schablonen\index{Schablone}} ergeben, die dem
% Programmierer einen Großteil der Denkarbeit bei der Entwicklung von
% Funktionen abnehmen.

% Aus diesem Grund schreiben wir in diesem Buch die
% Kurzbeschreibung und die Signatur in das Programm, \emph{bevor} wir
% die Definition entwickeln: 
% Die
% nachträgliche Entwicklung dieser Kommentare ist mühselig und
% langweilig.  Außerdem sind die Kurzbeschreibung und die
% Signatur ein hilfreicher Teil des Problemlösungsprozesses.
% Schon mancher Programmierer~-- Anfänger und Profi~--
% ist an Aufgaben gescheitert, die sich mit Hilfe systematischen Vorgehens
% anhand der Signatur leicht hätten lösen lassen.

% Aus dem fernen Osten stammt der Begriff des "`Mantras"' als einem
% Sinnspruch, den es sich lohnt, auswendig zu lernen.  Hier das erste Mantra:
% %
% \begin{mantra}[Signatur vor Ausführung]\label{mantra:contract}
% \input{mantra:contract}
% \end{mantra}
% %
% Ab jetzt werden sich die Programmbeispiele in diesem Buch natürlich
% an dieses Mantra halten.  Kurzbeschreibung, Signatur, Testfälle
% (beschrieben im nächsten Abschnitt) Gerüst und
% Schablone sind feste Bestandteile einer
% \textit{Konstruktionsanleitung\index{Konstruktionsanleitung}}, die
% systematisch beschreibt, wie eine Aufgabe schrittweise gelöst werden
% kann.  Dieses Buch wird eine Reihe von Konstruktionsanleitungen
% vorstellen, die sich stets an der Signatur einer Funktion orientieren.
% Alle Mantras sind in Anhang~\ref{cha:mantras} und die
% Konstruktionsanleitungen in Anhang~\ref{app:konstruktionsanleitungen}
% zusammengefaßt.

% \section{Testfälle}
% \label{sec:test-cases}

% \index{Testfall}Vertrauen ist gut~-- aber Fehler passieren, auch bei 
% sorgfältiger Programmierung.  Angenommen, bei der Programmierung von
% \texttt{parking-lot-cars} wäre folgendes herausgekommen:
% %
% \begin{alltt}
% ; aus der Anzahl der Fahrzeuge und Räder die Anzahl der PKWs bestimmen
% (: parking-lot-cars (natural natural -> natural))
% (define parking-lot-cars
%   (lambda (n m)
%     (/ (- m (* 4 n))
%        2)))
% \end{alltt}
% %
% Sehen Sie den Fehler auf den ersten Blick?  
% Einfaches Ausprobieren ist da vielleicht schneller:
% %
% \begin{alltt}
% (parking-lot-cars 1 4)
% \evalsto{} 0
% \end{alltt}
% %
% Bei der Entwicklung der Funktion sollten also
% \textit{Testfälle\index{Testfall}} konstruiert werden, die an
% ausgewählten Beispielen überprüfen, ob die gerade programmierte
% Funktion auch korrekt funktioniert.  Testen ist eine unverzichtbare
% Tätigkeit des Programmierers.

% Die Testfälle werden am besten \emph{vor} der Definition der Funktion
% aufgestellt, denn  wenn sie erst hinterher geschrieben werden, ist die
% Gefahr groß, dass unbewußt das tatsächliche Ergebnis
% eines Funktionaufrufs als das gewünschte eingegeben oder besonders
% kritische Beispiele weggelassen werden.  (In der industriellen Praxis ist sogar
% oft üblich, dass jemand anderes als der Autor der Definitionen
% die Testfälle schreibt.)

% Es ist mühselig, bei der Programmentwicklung ständig Testfälle in die
% REPL einzutippen und durch einen Vergleich mit den erwarteten
% Ergebnissen herauszubekommen, ob alles in Ordnung ist.  In \drscheme{}
% geht es deshalb auch einfacher.  Testfälle können zusammen mit den
% erwarteten Ergebnissen wie folgt spezifiziert werden:

% \begin{alltt}
% (check-expect (parking-lot-cars 1 4) 1)  
% (check-expect (parking-lot-cars 2 6) 1)  
% (check-expect (parking-lot-cars 10 28) 4)  
% \end{alltt}

% Beim Druck auf den \texttt{Start}-Knopf überprüft \drscheme{}, ob die
% tatsächlichen Ergebnisse der Ausdrücke mit den Soll-Werten
% übereinstimmen.  Für fehlgeschlagene Testfälle öffnet sich ein neues Fenster
% mit Informationen über die Unterschiede zwischen erwarteten und
% tatsächlichen Ergebnissen; ansonsten gibt es eine kurze Meldung, dass die
% Testfälle erfolgreich waren.  Für die obere inkorrekte Version kommt
% zum Beispiel Folgendes heraus:
% %
% \begin{alltt}
% 3 Tests gelaufen.
% 0 Tests bestanden.
% 2 Signaturverletzungen.

% Check-Fehler:
% 	Der tatsächliche Wert 0 ist nicht der erwartete Wert 1.
% in Zeile 4, Spalte 0 
% 	Der tatsächliche Wert -1 ist nicht der erwartete Wert 1.
% in Zeile 5, Spalte 0 
% 	Der tatsächliche Wert -6 ist nicht der erwartete Wert 4.
% in Zeile 6, Spalte 0 

% Signaturverletzungen:
% 	bekam -1 in Zeile 5, Spalte 14 , Signatur in Zeile 2, Spalte 40 
% 	verantwortlich: Funktion in Zeile 9, Spalte 2 
% 	bekam -6 in Zeile 6, Spalte 14 , Signatur in Zeile 2, Spalte 40 
% 	verantwortlich: Funktion in Zeile 9, Spalte 2 
% \end{alltt}
% %
% Eine großzügige Verwendung
% von Testfällen kann viele Programmierfehler
% aufdecken und damit die Programmierung erleichtern und beschleunigen.

% \begin{mantra}[Testfälle]\label{mantra:test}
% \input{mantra:test}
% \end{mantra}

% % FIXME: Coverage

% \section{Unsinnige Daten}
% \label{sec:nonsensical-data-prequel}

% Die Testfälle aus dem vorangegangenen Abschnitt sind alle
% "`sinnvoll"'~-- die Eingabedaten passen alle zu tatsächlichen
% Parkplatzsituationen.  Was ist aber hiermit?
% %
% \begin{alltt}
% (parking-lot-cars 3 9)
% \end{alltt}
% %
% Wie schon in Kapitel~\ref{page:parking-lot-problem}
% (Seite~\pageref{page:parking-lot-problem}) bereits angedeutet, 
% lassen sich die \emph{Daten} 3 und 9 nicht als \emph{Information}
% interpretieren: Es gibt keinen Parkplatz mit 3 Fahrzeugen und 9
% Rädern~-- zumindest nicht mit den Einschränkungen der Aufgabenstellung
% auf vollberäderte PKWs und Motorräder.

% Die Funktion \texttt{parking-lot-cars} stört dies allerdings wenig:
% Sie liefert munter die Ausgabe \texttt{1.5}.  Allerdings meldet
% DrRacket eine \textit{Signaturverletzung}\index{Signaturverletzung},
% wenn es \texttt{(parking-lot-cars 3 9)} auswertet, da das Ergebnis
% keine natürliche Zahl ist wie in der Signatur angegeben.  

% Das Programm sollte natürlich abseits der Signaturverletzung unsinnige
% Daten soweit möglich und praktikabel zurückweisen.  Für die Eingabe
% \texttt{(parking-lot-cars 3 16)} hätte es nämlich keine Signaturverletzung
% gegeben, sondern es wäre eine zunächst unschuldig aussehende $5$
% herausgekommen. Da hätte es zuerst noch der Beobachtung bedurft, dass unmöglich
% $5$ von $3$ Fahrzeugen PKWs sein können. Noch fehlen uns
% die Mittel, solche unsinnigen Eingaben zurückzuweisen; in Abschnitt~\ref{sec:nonsensical-data} werden wir
% dies nachholen.

% \section{Probleme und Teilprobleme}
% \label{sec:subproblems}

% TBD

% \section{Auswertung}
% \label{sec:substitution-model}
% \label{sec:scheme-anatomy}

% Bei der Auswertung eines Programms geht DrRacket nach festen Regeln
% vor.  Schauen wir uns noch einmal das Programm zum Parkplatzproblem
% an:
% %
% \begin{alltt}
% (define parking-lot-cars
%   (lambda (n m)
%     (/ (- m (* 2 n))
%        2)))
% (parking-lot-cars 4 10)
% \end{alltt}
% %
% Bei der Auswertung \textit{substituiert}\index{Substitution} DrRacket
% jeweils Namen durch ihre Werte.  Der erste Schritt ist also,
% \texttt{parking-lot-cars} durch den dazugehörigen
% \texttt{lambda}-Ausdruck zu ersetzen:
% %
% \begin{alltt}
% (parking-lot-cars 4 10)
% \evalsto
% ((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
% \end{alltt}
% %
% Jetzt steht dort die Applikation eines \texttt{lambda}-Ausdrucks auf die
% zwei Zahlen \texttt{4} und \texttt{10}: Diese Argumente werden für die
% ensprechenden Parameter \texttt{n} und \texttt{m} eingesetzt:
% %
% \begin{alltt}
% ((lambda (n m) (/ (- m (* 2 n)) 2)) 4 10)
% \evalsto
% (/ (- 10 (* 2 4)) 2)
% \end{alltt}
% %
% Nun werden sukzessive die Teilausdrücke ausgewertet.  Das passiert
% immer von links nach rechts.  Bei einer Applikation werden erst einmal
% alle Argumente fertig ausgewertet, bevor es mit der Substitution der
% Parameter und dem Rumpf der Prozezedur weitergeht:
% %
% \begin{alltt}
% (/ (- 10 (* 2 4)) 2)
% \evalsto
% (/ (- 10 8) 2)
% \evalsto
% (/ 2 2)
% \evalsto
% 1
% \end{alltt}
% %
% Diese Vorgehensweise entspricht der Algebra aus der Mathematik, wo wir
% auch Ausdrücke umformen, indem wir gleiches durch gleiches ersetzen.

% \begin{figure}[tb]
%   \centering
%   \includegraphics[width=\textwidth]{i1prog/stepper.png}
%   \caption{Stepper in DrRacket}
%   \label{fig:stepper}
% \end{figure}
% %
% Normalerweise zeigt uns DrRacket nur das Endergebnis dieses Prozesses
% an.  Es ist aber auch in der Lage, die Schritte einzeln zu
% visualisieren: Dazu müssen Sie auf den \texttt{Step}-Knopf drücken.
% Es erscheint ein neues Fenster, der sogenannte \textit{Stepper}\index{Stepper}.
% Sie können dann vorwärts und rückwärts durch den Substitutionsprozeß
% navigieren.  Abbildung~\ref{fig:stepper} zeigt das Stepper-Fenster.

\section*{Aufgaben}



\begin{aufgabe}
 Vervielfachung von Strings:
 \begin{itemize}
  \item Schreibe eine Funktion \texttt{double-string}, die eine Zeichenkette konsumiert und
    diese "`verdoppelt"', d.h., für eine Eingabe \verb|"Sperber"| den
    Rückgabewert \verb|"SperberSperber"| liefert.
    
  \item Schreibe eine Funktion \texttt{quadruple-string}, die eine
    Zeichenkette konsumiert und "`vervierfacht"'.

  \item Schreibe eine Funktion \texttt{octuple-string}, die eine
    Zeichenkette konsumiert und "`verachtfacht"'.

  \item Schreibe eine Funktion \texttt{sixteentuple-string}, die
    eine Zeichenkette konsumiert und "`versechzehnfacht"'.
  \end{itemize}
  % Schreibe für jede Funktion Kurzbeschreibung, Signatur, Testfälle, Gerüst und Rumpf.

%Vermeide bei all diesen Aufgaben, Code mehrfach zu schreiben.

\end{aufgabe}

\begin{aufgabe}

 Ein Boot überquert einen Fluss mit Strömung und
  kommt durch die Strömung vom geplanten Kurs ab.  Dadurch wird die
  Strecke, die das Boot tatsächlich zurücklegt, länger.

  \begin{center}
    \includegraphics{riverboat}
  \end{center}

  Gegeben ist die Breite des Flusses $a$, die Strömungsgeschwindigkeit
  des Flusses $v_{\text{Fluss}}$ und die Geschwindigkeit des Bootes
  $v_{\text{Boot}}$.  Berechne die Länge der Strecke, die das
  Boot tatsächlich zurücklegt.  Programmiere dazu Funktionen, die
  folgende Teilprobleme lösen:

  \begin{enumerate}
  \item Schreibe zunächst eine Funktion \texttt{speed-ratio}, die
    das Verhältnis der Strömungsgeschwindigkeit des Flusses
    $v_{\text{Fluss}}$ zur Geschwindigkeit des Bootes
    $v_{\text{Boot}}$ berechnet.

  \item Schreibe dann eine Funktion \texttt{other-shore-offset},
    die die Länge der Strecke berechnet, die das Boot abgetrieben wird
    (also den Versatz am anderen Ufer, im Schaubild die Strecke $b$).
    % Dazu musst Du die Breite des Flusses $a$ mit dem Verhältnis von
    % $v_{\text{Fluss}}$ zu $v_{\text{Boot}}$ multiplizieren.

  \item Um $c$ zu berechnen, brauchst Du den \textit{Satz des
      Pythagoras}:
    \begin{displaymath}
      a^2 + b^2 = c^2
    \end{displaymath}
    Schreibe eine Funktion \texttt{pythagoras}, die $c$ der
    obigen Gleichung berechnet.  Erkenne und abstrahiere weitere
    Teilprobleme!

  \item Schreibe schließlich eine Funktion
    \texttt{boat-travel-distance}, die die tatsächliche Strecke
    berechnet, die das Boot zurücklegt.  Benutze dafür die bisher
    geschriebenen Funktionen.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  In den USA und in Europa gibt es unterschiedliche
  Maße für die Energieeffizienz von Kraftfahrzeugen:
  \begin{itemize}
  \item In Europa ist das gängige Maß der \emph{Verbrauch} in Liter
    pro 100km (l/100km);
  \item in den USA ist das gängige Maß die \emph{Reichweite} in Meilen
    pro Gallone (mi/gal).
  \end{itemize}
  Schreibe Funktionen, die zwischen beiden Maßeinheiten
  umrechnen.  Gehe dazu wie folgt vor:

  Halte sich bei jeder Funktion, die Du schreibst, an den
  Ablauf: Schreibe zuerst die Kurzbeschreibung
  und die Signatur.  Schreibe als nächstes einige Testfälle.
  Leite Sie danach das Gerüst von der Signatur her und vervollständige
  den Rumpf der Funktion.

  \begin{enumerate}

  \item Schreibe eine Funktion
    \texttt{liters-per-hundred-kilometers}, die eine Menge Benzin in
    Liter und die Reichweite dieses Benzins in Kilometer akzeptiert
    und daraus den Verbrauch in Liter pro 100km berechnet.

  \item Schreibe eine Funktion
    \texttt{miles-per-gallon}, die eine Entfernung in Meilen und den
    Benzinverbrauch auf diese Entfernung in Gallonen akzeptiert und
    daraus die Reichweite in Meilen pro Gallone berechnet.

  \item Definiere eine Konstante
    \texttt{kilometers-per-mile} (eine US-Meile entspricht etwa $1,61$
    Kilometer) und schreibe zwei Funktionen
    \texttt{kilometers->miles} und \texttt{miles->kilometers}, die
    jeweils eine Entfernung in einer Maßeinheit akzeptieren und die
    Entfernung in die jeweils andere Maßeinheit umrechnen.

  \item Definiere eine Konstante
    \texttt{liters-per-gallon} (eine Gallone entspricht etwa $3,79$
    Liter) und schreibe zwei Funktionen \texttt{liters->gallons}
    und \texttt{gallons->liters}, die jeweils eine Menge in einer
    Maßeinheit akzeptieren und die Menge in die jeweils andere
    Maßeinheit umrechnen.

  \item Schreibe die Funktion
    \texttt{l/100km->mi/gal}, die einen Verbrauch in Liter pro 100km
    akzeptiert und in die Reichweite in Meilen pro Gallone umrechnet.
    Benutze dafür die Funktionen, die Du in den anderen
    Teilaufgaben erstellt hast.  Solltest Du auf weitere Teilprobleme
    stoßen, abstrahiere diese Teilprobleme in eigene Funktionen.

  \item Schreibe die Funktion
    \texttt{mi/gal->l/100km}, die eine Reichweite in Meilen pro
    Gallone akzeptiert und in den Verbrauch in Liter pro 100km
    umrechnet.  Benutze dafür die Funktionen, die Du in den
    anderen Teilaufgaben erstellt hast.  Solltest Du auf weitere
    Teilprobleme stoßen, abstrahiere diese Teilprobleme in eigene
    Funktionen.

  \item Finde heraus, wie hoch der Benzinverbrauch
    verschiedener Kraftfahrzeuge ist, die Du täglich im
    Straßenverkehr in Deutschland siehst.  Vergleiche diesen
    Verbrauch mit den Reichweitenangaben typischer Kraftfahrzeuge für
    den US-amerikanischen Markt.
  \end{enumerate}

\end{aufgabe}

% In vielen Ländern sind die Benzinpreise ein Grund zur allgemeinen
% Aufregung. In Deutschland wird immer die magische Marke von 1,50
% Euro pro Liter genannt, die USA haben große Angst vor der 4 Dollar
% pro Gallone. Auch sind Spritsparende Autos immer beliebter, in
% Deutschland wird auf das 3 Liter auf 100km Auto gehofft, die USA
% wünschen sich mehr 55 Meilen pro Gallone Autos.  Diese verschiedenen
% Maßstäbe sind verwirrend.

% FIXME: Hier taucht noch "Substitutionsmodell" auf.

% FIXME: umbenennen von n und m in parking-lot-cars in sprechende Namen

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
