% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung 4.0 International (CC BY 4.0)"
% http://creativecommons.org/licenses/by/4.0/deed.de

\chapter{Zusammengesetzte Daten}
\label{cha:zusammengesetzte-daten}

TBD

Mit anderen Worten: mehrere Dinge werden \emph{zu einem}
zusammengesetzt.  Eine andere Betrachtungsweise ist, dass ein einzelnes
Ding durch mehrere Eigenschaften charakterisiert ist.

In Scheme lassen sich solche \textit{zusammengesetzte
Daten}\index{zusammengesetzten Daten} durch
\textit{Records}\index{Record} darstellen.  Ein Record ist wie ein
Behälter mit mehreren Fächern, in denen die Bestandteile der Daten
untergebracht sind.

\section{Computer konfigurieren}
\label{sec:computer-konfigurieren}

Viele Computerhändler erlauben ihren Kunden, bestimmte Komponenten
eines neues Computers selbst auszuwählen, zum Beispiel den Prozessor,
die Festplatte oder die Größe des RAM-Hauptspeichers:
%
\begin{center}
  \includegraphics[height=0.3\textheight]{computer}
\end{center}
%
Eine mögliche Beschreibung dieser Situation ist:

Ein Computer\index{Computer} \emph{besteht aus}:
%
\begin{itemize}
\item Prozessor
\item RAM
\item Festplatte
\end{itemize}
%
Natürlich besteht ein Computer auch noch aus anderen Teilen, die
aber (zumindest in diesem Beispiel) immer gleich sind.  In einer Bestellung muß
der Kunde also nur diese drei Bestandteile angeben.  Wir nehmen an,
dass es beim Prozessor nur auf den Namen ("`Athlon"', "`Xeon"',
"`Cell"', \ldots) ankommt, beim RAM nur auf die Größe in Gigabyte, und
auch bei der Festplatte nur auf die Größe in Gigabyte.  Eine
vereinfachte Darstellung könnte so aussehen:
%
\begin{center}
  Computer:
  \begin{tabular}[c]{|r|l|}
    \hline
    \textbf{Feld} & \textbf{Komponente}\\\hline
    \hline
     Prozessor & \verb|"Cell"|\\
     \hline
     RAM & 2\\
    \hline 
    Festplatte & 250\\
    \hline
  \end{tabular}
\end{center}
%
Diese Tabelle steht demnach für einen Computer mit Cell-Prozessor, 2
Gigabyte RAM und einer 250-Gigabyte-Festplatte.

Die Begriffe "`Feld"'\index{Feld} und "`Komponente"'\index{Komponente}
sind dabei Termini~-- das \textit{Feld} ist die Allgemeinbezeichnung
für ein Bestandteil, das alle Computer haben.  Die \textit{Komponente}
ist das konkrete Bestandteil eines einzelnen Computers.

Die Darstellung für solche \textit{zusammengesetzte
  Daten\index{zusammengesetzte Daten}}, die aus mehreren
\textit{Komponenten\index{Komponente}} (in diesem Fall "`\texttt{Cell}"', $2$
und $250$) bestehen, heißt \textit{Record}.  Alle
Records für Computer gehören zu einer gemeinsamen Menge, dem
\textit{Record-Typ\index{Record-Typ}} für Computer.  (Weiter hinten
in diesem Kapitel wird beschrieben, wie ein Programm eigene
Record-Typen definieren kann.)  Der Record-Typ für Computer sieht
feste \textit{Felder\index{Feld}} ("`Prozessor"', "`RAM"' und "`Festplatte"') vor,
welche die Komponenten aufnehmen.  Für jedes Feld des Record-Typs
"`Computer"' besitzt also jeder einzelne Computer jeweils eine
Komponente, in diesem Fall eine für das Prozessor-, eine für das RAM- und eine für das
Festplatten-Feld.

Der Computerhersteller stellt einen echten Computer her, indem er
zunächst den Prozessor, den RAM und die Festplatte fertigstellt und
diese dann zum Computer zusammensetzt.  Umgekehrt nehmen manche
Bastler aus dem Computer die Einzelteile wieder heraus, zum Beispiel,
um sie in einem anderen Computer zu verbauen.

In der \drscheme{}-Sprachebene \texttt{Die Macht der Abstraktion - Anfänger} sind
Computer schon eingebaut.  Ein Computer mit Cell-Prozessor, 2
Gigabyte RAM und 250 Gigabyte Festplatte wird folgendermaßen hergestellt:
%
\begin{alltt}
(make-computer "Cell" 2 250)
\evalsto{} #<record:computer "Cell" 2 250>
\end{alltt}
%
Die Prozedur \texttt{make-computer} hat folgende Signatur:
%
\begin{alltt}
(: make-computer (string rational rational -> computer))
\end{alltt}
%
Sie macht also aus einer Zeichenkette und zwei Zahlen einen Wert der eingebauten Sorte
\texttt{computer} der Computer-Records.
Die \drscheme{}-REPL druckt Record-Werte mit der Schreibweise
\verb|#<record:... ...>| aus, damit Sorte und Komponenten sichtbar
werden.

Computer sind Werte wie andere auch und lassen sich zum Beispiel an
Variablen binden:
%
\begin{alltt}
; Cell, 4 Gbyte RAM, 1000 Gbyte Festplatte
(define gamer (make-computer "Cell" 4 1000))
gamer
\evalsto{} #<record:computer "Cell" 4 1000>
; Xeon, 2 Gbyte RAM, 500 Gbyte Festplatte
(define workstation (make-computer "Xeon" 2 500))
workstation
\evalsto{} #<record:computer "Xeon" 2 500>
\end{alltt}
%
Da die Prozedur \texttt{make-computer} einen Computer
"`konstruiert"', heißt sie auch
\textit{Konstruktor\index{Konstruktor}}.  Für das Zerlegen von
Computern sind die Prozeduren \texttt{computer"=processor},
\texttt{computer"=ram} und \texttt{computer-hard-drive}
zuständig:
%
\begin{alltt}
(computer-processor gamer)
\evalsto{} "Cell"
(computer-ram gamer)
\evalsto{} 4
(computer-hard-drive gamer)
\evalsto{} 1000
\end{alltt}
%
Diese drei Prozeduren extrahieren die Bestandteile aus einem
Computer und heißen \textit{Selektoren\index{Selektor}}.  Sie haben
folgende Signaturen:
%
\begin{alltt}
(: computer-processor (computer -> string))
(: computer-ram (computer -> rational))
(: computer-hard-drive (computer -> rational))
\end{alltt}
%
Mit Hilfe des Konstruktors und der Selektoren kann der Programmierer
weitergehende Prozeduren definieren.  Für den Anfang könnte das
eine Prozedur sein, die den Gesamtspeicher eines Computers berechnet,
also Hauptspeicher und Festplattenspeicher zusammen.
Eine solche Prozedur müßte Kurzbeschreibung und Signatur wie folgt haben:\index{total-memory@\texttt{total-memory}}
%
\begin{alltt}
; Gesamtspeicher berechnen
(: total-memory (computer -> rational))
\end{alltt}
%
Hier sind unsere Erwartungen an \texttt{total-memory}, als Testfälle
formuliert:
%
\begin{alltt}
(check-expect (total-memory workstation) 502)
(check-expect (total-memory gamer) 1004)
\end{alltt}
% 
Das Gerüst müßte folgendermaßen sein:
%
\begin{alltt}
(define total-memory
  (lambda (c)
    ...))
\end{alltt}
%
Da in den Gesamtspeicher des Computer sowohl der Hauptspeicher als
auch die Festplatte eingehen, steht schon fest, dass die
entsprechenden Selektoraufrufe im Rumpf der Prozedur vorkommen müssen:
%
\begin{alltt}
(define total-memory
  (lambda (c)
    ... (computer-ram c) ...
    ... (computer-hard-drive c) ...))
\end{alltt}
%
Das Gesamtspeicher ergibt sich aus Addition der beiden Komponenten:
%
\begin{alltt}
(define total-memory
  (lambda (c)
    (+ (computer-ram c)
       (computer-hard-drive c))))
\end{alltt}
%
Fertig!

\texttt{total-memory} ist ein Beispiel für eine Prozedur, die einen
Record akzeptiert.  Umgekehrt gibt es auch Prozeduren, die Records
produzieren.  Angenommen, unser Computerhändler bietet neben der
Einzelkonfiguration von Prozessor, Hauptspeicher und Festplatte einige
Standardmodelle an~-- sagen wir, ein Billigmodell, ein Modell für
Profis (was immer ein "`Profi"' sein mag) und ein Modell für
Computerspieler.  Je nachdem, welches der Modelle der Kunde auswählt,
muß die entsprechende Konfiguration zusammengesetzt werden.  Für die
Standardkonfiguration gibt es drei feste Möglichkeiten, es handelt
sich hier also um eine Aufzählung.

Eine Prozedur, die zu einer Standardkonfiguration den passenden
Computer fertigt, könnte folgende Kurzbeschreibung und Signatur haben:
%
\begin{verbatim}
; Standard-Computer zusammenstellen
(: standard-computer ((one-of "cheap" "professional" "game") -> computer))
\end{verbatim}
%
Die Testfälle sollten alle drei Standardkonfigurationen abdecken:
%
\begin{verbatim}
(check-expect (standard-computer "cheap") (make-computer "Sempron" 2 500))
(check-expect (standard-computer "professional") (make-computer "Xeon" 4 1000))
(check-expect (standard-computer "game") (make-computer "Quad" 4 750))
\end{verbatim}
%
Hier ist das Gerüst:
%
\begin{verbatim}
(define standard-computer
  (lambda (k)
    ...))
\end{verbatim}
%
Da es sich beim Argument um eine Fallunterscheidung~-- eine Aufzählung
mit \emph{drei} Alternativen~-- handelt, können wir die
dazu passende Schablone~-- eine Verzweigung mit \emph{drei} Zweigen~--
zum Einsatz bringen:
%
\begin{verbatim}
(define standard-computer
  (lambda (k)
    (cond
      (... ...)
      (... ...)
      (... ...))))
\end{verbatim}
%
Bei den Tests der Zweige müssen wir \texttt{k} mit den Elementen der
Aufzählung vergleichen.  Da es sich um Zeichenketten handelt, nehmen
wir dazu \texttt{string=?}:
%
\begin{verbatim}
(define standard-computer
  (lambda (k)
    (cond
      ((string=? k "cheap") ...)
      ((string=? k "professional") ...)
      ((string=? k "game") ...))))
\end{verbatim}
%
In jedem Zweig müssen wir nun dafür sorgen, dass der entsprechende
Computer hergestellt wird.  Für das Herstellen von Computer-Records
ist der Konstruktor \texttt{make-computer} zuständig.  Dementsprechend
müssen wir in jedem Zweig einen Aufruf an \texttt{make-computer}
plazieren:
%
\begin{verbatim}
(define standard-computer
  (lambda (k)
    (cond
      ((string=? k "cheap")
       (make-computer ... ... ...))
      ((string=? k "professional")
       (make-computer ... ... ...))
      ((string=? k "game")
       (make-computer ... ... ...)))))
\end{verbatim}
%
Jetzt müssen wir nur noch die Argumente für die Aufrufe von
\texttt{make-computer} zur Verfügung stellen.  Für jeden Aufruf sind
das, wie gehabt, der Prozessor, die Größe des Hauptspeichers und die
Größe der Festplatte.  Die entsprechenden Angaben können wir zum
Beispiel den Testfällen entnehmen, und es kommt Folgendes dabei heraus:
%
\begin{verbatim}
(define standard-computer
  (lambda (k)
    (cond
      ((string=? k "cheap")
       (make-computer "Sempron" 2 500))
      ((string=? k "professional")
       (make-computer "Xeon" 4 1000))
      ((string=? k "game")
       (make-computer "Quad" 4 750)))))
\end{verbatim}
%
Fertig!

\section{Record-Definitionen}
\label{sec:record-definitions}

Natürlich sind zusammengesetzte Daten in Scheme nicht auf Computer-Konfigurationen
beschränkt~-- der Programmierer kann neue Arten zusammengesetzter
Daten selbst definieren.  Voraussetzung für die Definition einer neuen
Art zusammengesetzter Daten ist eine klare Vorstellung davon, was die
Komponenten sind.  Dabei hilft eine informelle Beschreibung wie diese
hier:
%
\begin{alltt}
; Eine kartesische Koordinate in der Ebene besteht aus X- und Y-Koordinate.
\end{alltt}
%
Eine solche \index{Datendefinition}\textit{Datendefinition} läßt sich
direkt in eine
\textit{Record-Definition\index{Record-Definition}} in Scheme übersetzen.
Dies ist eine Form mit dem syntaktischen
Schlüsselwort \texttt{define-record-procedures}.  Eine
Record-Definition definiert einen neuen Record-Typ und dabei
automatisch auch u.~a.\ den Konstruktor und die
Selektoren~-- nur ihre Namen müssen angegeben werden.

TBD
%
Eine \texttt{define"=record"=procedures}"=Form\index{define-record-procedures@\texttt{define-record-procedures}}
hat folgende allgemeine Gestalt:\label{def:define-record-procedures}
%
\begin{alltt}
(define-record-procedures \(t\)
  \(c\) \(p\)
  (\(s\sb{1}\) \(\ldots\) \(s\sb{n}\)))
\end{alltt}
%
Diese Form definiert einen Record-Typ mit $n$ Feldern.
Dabei sind $t$, $c$, $p$, $s_1 \ldots s_n$ allesamt Variablen, für die
\texttt{define-record-procedures} Definitionen anlegt:
%
\begin{itemize}
\item $t$ ist der Name des Record-Typs.
\item $c$ ist der Name des Konstruktors, den
  \texttt{define-record-procedures} anlegt.
\item $p$ ist der Name des Prädikats, das
  \texttt{define-record-procedures} anlegt.
\item $s_1, \ldots, s_n$ sind die Namen der Selektoren für die Felder
  des Record-Typen.
\end{itemize}
%
Beim Entwurf einer Record-Definition hilft es, mit der
Datendefinition anzufangen, die
ausführlich beschreibt, was für Komponenten die Daten haben.  Für
Computer sieht diese Datendefinition folgendermaßen aus:
%
\begin{alltt}
; Ein Computer besteht aus:
; - Prozessor (string)
; - Hauptspeicher-Kapazität in Gbyte (rational)
; - Festplatten-Kapazität in Gbyte (rational)
\end{alltt}
%
Hier ist die Datendefinition für kartesische Koordinaten:
%
\begin{alltt}
; Eine kartesische Koordinate besteht aus:
; - X-Anteil (real)
; - Y-Anteil (real)
\end{alltt}
%
Die Datendefinition muss genau soviele Komponenten aufweisen,
wie die zusammengesetzten Daten Bestandteile haben. 
Wenn es nicht absolut glaskar ist, sollten in Klammern die Signaturen der
jeweiligen Komponenten angegeben werden~-- wie in diesen Beispielen.

Aus der Datendefinition ergibt sich direkt die Record-Definition.  
Insbesondere gehört zu jeder Komponente ein Selektor.
Die Namen für den Konstruktor, das Prädikat und die Selektoren können
frei gewählt werden, sollten aber meist einer einheitlichen
Konvention folgen, um anderen das Lesen des Programms zu erleichern.
Die gängige Konvention ist, dass der Konstruktor mit \texttt{make-}
anfängt (\texttt{make-cartesian}), der Name des Prädikats auf ein
Fragezeichen endet (\texttt{cartesian?}), und die Selektoren mit dem Namen des
Record-Typs beginnen und auf die
Namen der Felder enden (\texttt{cartesian-x}, \texttt{cartesian-y}).

TBD

\section{Schablonen für  zusammengesetzte Daten}

Zusammengesetzte Daten können Sie an Formulierungen wie "`ein $X$
besteht aus~\ldots"', "`ein $X$ ist charakterisiert durch~\ldots"' oder "`ein
$X$ hat folgende Eigenschaften:~\ldots"'  erkennen.
Diese Formulierung bildet
dann~-- ordentlich aufgeschrieben und ggf.\ um die Signaturen für die
Komponenten ergänzt~-- das Herzstück der Datendefinition.  Diese
Datendefinition können Sie dann direkt in die dazugehörige
Record-Definition übersetzen.  Diese muss genauso viele Felder haben
wie die Datendefinition Komponenten beschreibt.

Diese Methode bildet Konstruktionsanleitung~\ref{ka:zusammengesetzt}
in Anhang~\ref{app:konstruktionsanleitungen}.

\subsection{Zusammengesetzte Daten als Eingabe}

Die Definitionen von \texttt{total-price} folgen dem selben Muster.  Dieses Muster
ergibt Schablonen für Prozeduren, die Records als Argumente
akzeptieren und läßt sich auch auf andere Record-Typen folgendermaßen
in eine Konstruktionsanleitung übertragen:
%
\begin{enumerate}
\item Stellen Sie fest, von welchen Komponenten des Records das Ergebnis
  der Prozeduren abhängt.
\item Für jede dieser Komponenten, schreiben Sie  \texttt{($s$ $c$)} in die
  Schablone, wobei $s$ der Selektor der Komponente und $c$ der Name
  des Record-Parameters ist.
\item Vervollständigen Sie die Schablone, indem Sie einen Ausdruck
  konstruieren, in dem die Selektor"=Anwendungen vorkommen.
\end{enumerate}
%
Konstruktionsanleitung~\ref{ka:zusammengesetzt-input} in
Anhang~\ref{app:konstruktionsanleitungen} faßt diese Schritte noch
einmal zusammen.

\subsection{Zusammengesetzte Daten als Ausgabe}

Prozeduren, die zusammengesetzte Daten als Ausgabe haben, müssen einen
entsprechenden Record konstruieren, mithin den Konstruktor aufrufen.
Die Schablone wird also folgendermaßen konstruiert:
%
\begin{quote}
  Wenn die Prozedur zusammengesetzte Daten als Ausgabe hat, schreiben
  Sie einen Aufruf des passenden Record-Konstruktors in den Rumpf,
  zunächst mit einer Ellipse für jedes Feld des Records.
\end{quote}
%
Im nächsten Schritt ersetzen Sie dann die Ellipsen durch Ausdrücke,
welche die entsprechenden Komponenten berechnen.

Konstruktionsanleitung~\ref{ka:zusammengesetzt-output} in
Anhang~\ref{app:konstruktionsanleitungen} faßt diese Schritte noch
einmal zusammen.

\section{Gürteltiere im Computer}
\label{sec:armadillo}

Nachdem wir aus den Beispielen die Schablonen für zusammengesetzte
Daten entwickelt haben, demonstrieren wir diese in diesem Abschnitt
noch einmal an einem frischen Beispiel:

In Texas gibt es viele Gürteltiere, die insbesondere die Highways
überqueren und dabei leider oft überfahren werden~-- am Straßenrand
sind entsprechend viele Gürteltiere zu sehen.  Außerdem füttern
freundliche Autofahrer gelegentlich die Gürteltiere.  Mit diesen
beiden Aspekte wollen wir uns beschäftigen: Was passiert, wenn ein
Gürteltier überfahren wird?  Was passiert, wenn ein Gürteltier
gefüttert wird?  Entsprechend interessiert uns, ob ein Gürteltier am
Leben ist und welches Gewicht es hat.  Das können wir direkt in eine
Datendefinition übersetzen:
%
\begin{verbatim}
; Ein Gürteltier hat folgende Eigenschaften:
; - Gewicht (in g)
; - lebendig oder tot
\end{verbatim}
%
Wiederum handelt es sich sichtlich um zusammengesetzte Daten.  Diesmal
trifft die Phrase "`besteht aus"' natürlich nicht zu.  Stattdessen
geht es um die Eigenschaften, von denen ein Gürteltier viele hat.
Von diesen vielen interessanten Eigenschaften sind aber etliche bei
allen Gürteltieren gleich (Säugetier, zwei Augen, vier Füße etc.) und
darum nicht Teil der Datendefinition.  Für unsere Aufgaben sind
außerdem nur zwei Eigenschaften von Belang, weshalb die
Datendefinition auch nur diese auflistet.

Aus der Datendefinition können wir direkt eine passende
Record-Definition machen:
% 
\begin{verbatim}
(define-record-procedures dillo
  make-dillo dillo?
  (dillo-weight dillo-alive?))
\end{verbatim}
%
("`Dillo"' steht kurz für "`Armadillo"', englisch für Gürteltier.)

Für das Feld \texttt{alive?} könnten wir unterschiedliche Repräsentationen
wählen: Eine Aufzählung wäre möglich; die Autoren haben sich für einen
booleschen Wert entschieden, der die Frage "`Lebt das Gürteltier?"'
beantwortet.  Hier sind die Signaturen für die Record-Prozeduren:
%
\begin{verbatim}
(: make-dillo (natural boolean -> dillo))
(: dillo? (any -> boolean))
(: dillo-weight (dillo -> natural))
(: dillo-alive? (dillo -> boolean))
\end{verbatim}
%
Dabei bedeutet \texttt{any}, dass an dieser Argumentstelle beliebige
Daten auftreten dürfen.  Riesengürteltiere werden um die 60~kg schwer.   Hier sind einige
Exemplare:
%
\begin{verbatim}
(define d1 (make-dillo 55000 #t)) ; 55 kg, lebendig 
(define d2 (make-dillo 58000 #f)) ; 58 kg, tot
(define d3 (make-dillo 60000 #t)) ; 60 kg, lebendig
(define d4 (make-dillo 63000 #f)) ; 63 kg, tot
\end{verbatim}
%
Fangen wir mit dem unangenehmen Teil an, dem Überfahren, das aus einem
lebenden Gürteltier ein totes macht.  Hier Kurzbeschreibung und
Signatur:\index{run-over-dillo@\texttt{run-over-dillo}}\label{page:run-over-dillo}
%
\begin{verbatim}
; Gürteltier überfahren
(: run-over-dillo (dillo -> dillo))
\end{verbatim}
%
Aus dem Beispiel \texttt{d1} können wir den ersten Testfall machen:
%
\begin{verbatim}
(check-expect (run-over-dillo d1) (make-dillo 55000 #f))
\end{verbatim}
%
Wir sollten aber auch berücksichtigen, was \texttt{run-over-dillo} mit
toten Gürteltieren anstellt: Diese bleiben auch nach dem Überfahren
tot:
%
\begin{verbatim}
(check-expect (run-over-dillo d2) d2)
\end{verbatim}
%
Hier das Gerüst der Prozedur:
%
\begin{verbatim}
(define run-over-dillo
  (lambda (d)
    ...))
\end{verbatim}

\texttt{Run-over-dillo} hat zusammengesetzte Daten sowohl als Eingabe
als auch als Ausgabe.  Entsprechend kommen die Schablonen für beide
Situationen zum Einsatz.  Zunächst die Schablone für zusammengesetzte
Daten als Eingabe; wir schreiben die Aufrufe der Selektoren auf:
%
\begin{verbatim}
(define run-over-dillo
  (lambda (d)
    ... (dillo-weight d) ...
    ... (dillo-alive? d) ...))
\end{verbatim}
%
Dazu kommt die Schablone für zusammengesetzte Daten als Ausgabe, also
der Aufruf des Konstruktors:
%
\begin{verbatim}
(define run-over-dillo
  (lambda (d)
    (make-dillo ... ...)
    ... (dillo-weight d) ...
    ... (dillo-alive? d) ...))
\end{verbatim}
%
Wir müssen beim Aufruf des Konstruktors \texttt{make-dillo} angeben,
welches Gewicht das frisch überfahrene Gürteltier haben soll und ob es
noch am Leben ist.  Da das Überfahren das Gewicht nicht ändert, übernimmt
der Ausdruck für das Gewicht das Gewicht des Eingabe-Gürteltiers aus
der Schablone:
%
\begin{verbatim}
(define run-over-dillo
  (lambda (d)
    (make-dillo (dillo-weight d) ...)
    ... (dillo-alive? d) ...))
\end{verbatim}
%
Das Gürteltier ist nach dem Überfahren auf jeden Fall tot.  Da es
keine Rolle spielt, ob das Gürteltier vorher lebendig war oder nicht,
können wir den Selektoraufruf \texttt{(dillo-alive? d)} verwerfen:
%
\begin{verbatim}
(define run-over-dillo
  (lambda (d)
    (make-dillo (dillo-weight d)
                #f)))
\end{verbatim}
%
Fertig!

Nächste Aufgabe: Gürteltier füttern.  Die Standard-Futter-Portion ist
dabei 500g, und das Gürteltier nimmt durch die Fütterung um das
entsprechende Gewicht zu.  Hier Kurzbeschreibung und Signatur:
%
\begin{verbatim}
; Gürteltier mit 500g Futter füttern
(: feed-dillo (dillo -> dillo))
\end{verbatim}
%
Hier der erste, naheliegende Testfall:
%
\begin{verbatim}
(check-expect (feed-dillo d1) (make-dillo 55500 #t))
\end{verbatim}
%
Auch bei \texttt{feed-dillo} ist relevant, was es mit toten
Gürteltieren macht: Tote Gürteltiere fressen nicht, entsprechend
nehmen sie auch nicht zu, wenn man ihnen Futter anbietet:
%
\begin{verbatim}
(check-expect (feed-dillo d2) d2)
\end{verbatim}
%
Hier das Gerüst der Prozedur:
\begin{verbatim}
(define feed-dillo
  (lambda (d)
    ...))
\end{verbatim}
%
\texttt{Feed-dillo} hat die gleiche Signatur wie
\texttt{run-over-dillo}; entsprechend benutzen wir die gleiche
Schablone:
%
\begin{verbatim}
(define feed-dillo
  (lambda (d)
    (make-dillo ... ...)
    ... (dillo-weight d) ...
    ... (dillo-alive? d) ...))
\end{verbatim}
%
Beim zweiten Testfall haben wir gesehen, dass, was \texttt{feed-dillo}
betrifft, die Gürteltiere in zwei verschiedene Gruppen fallen:
\texttt{Feed-dillo} verhält sich bei lebenden Gürteltieren anders als
bei toten: eine Fallunterscheidung.  Entsprechend brauchen wir eine
Verzweigung im Rumpf.  Da sich der Fall "`Gürteltier tot"' dadurch definiert, dass der
Fall "`Gürteltier lebendig"' nicht eintritt, ist die binäre Verzweigung
angemessen:
%
\begin{verbatim}
(define feed-dillo
  (lambda (d)
    (if (dillo-alive? d)
         ...
         ...)
    (make-dillo ... ...)
    ... (dillo-weight d) ...
\end{verbatim}
%
Nun müssen wir noch die beiden Zweige ergänzen.  Am
einfachsten ist die Alternative "`Gürteltier tot"', dann nämlich kommt
das gleiche Gürteltier aus der Prozedur, das hineingegangen ist:
%
\begin{verbatim}
(define feed-dillo
  (lambda (d)
    (if (dillo-alive? d)
         ...
         d)
    (make-dillo ... ...)
    ... (dillo-weight d) ...
\end{verbatim}
%
Im ersten Zweig müssen wir schließlich einen neuen Gürteltier-Wert
berechnen, der die Zunahme berücksichtigt.  Dabei werden der
Konstruktur-Aufruf und der zweite Selektor-Aufruf aus der Schablone
verbraucht:
%
\begin{verbatim}
(define feed-dillo
  (lambda (d)
    (if (dillo-alive? d)
        (make-dillo (+ (dillo-weight d) 500)
                    #t)
        d)))
\end{verbatim}
%
Fertig!

\section*{Aufgaben}

\begin{aufgabe}

  Schreiben Sie eine Daten- und eine
  Record-Definition für \textit{Brüche} und verschiedene Prozeduren
  für das Bruchrechnen:
  \begin{itemize}
  \item Kürzen eines Bruchs
  \item Test auf Gleichheit der durch zwei Brüche repräsentierter
    rationaler Zahlen
  \item Addition, Subtraktion, Multiplikation und Division von
    Brüchen
  \end{itemize}

  \textbf{Hinweis:} Zur Lösung der Aufgabe brauchen Sie die eingebaute
  Prozedur
  % 
  \begin{center}
    \texttt{gcd: number number -> number},
  \end{center}
  % 
  die den größten gemeinsamen Teiler (greatest common divisor) von
  zwei natürlichen Zahlen berechnet.

\end{aufgabe}

\begin{aufgabe}

  Jedes Qux hat einen Namen.  Außerdem interessiert
  Experten, wieviele Bas ein Qux hat.  Es wird außerdem zwischen
  Arg-Quxen, Foo-Quxen und Bla-Quxen unterschieden.
  \begin{enumerate}
  \item Schreiben Sie eine Daten-Definition für Quxe sowie eine dazu
    passende Record-Definition. Notieren Sie dazu auch die Signaturen der
    Selektoren.
  \item Schreiben Sie Signatur, Gerüst und Schablone für eine Prozedur,
    die ein Qux konsumiert und eine Zeichenkette zurückgibt.
    Identifizieren Sie die dazu benutzten Konstruktionsanleitungen.
    Achten Sie darauf, dass Sie auch die Konstruktionsanleitungen für die
    Komponenten von Qux-Records zur Anwendung bringen.
  \item Nehmen Sie an, Sie hätten für eine zu schreibende Prozedur
    \texttt{quxop2} die folgende Signatur festgelegt:
\begin{verbatim}
(: quxop2 (natural (one-of "Hx" "Bx" "Px") -> qux))
\end{verbatim}
    (Dabei ist angenommen, dass die Record-Definition für ein Qux
    den Namen \texttt{qux} hat.) Entwickeln Sie daraus Gerüst und
    Schablone der zu schreibenden Prozedur.  Identifizieren Sie die dazu
    benutzten Konstruktionsanleitungen.
  \end{enumerate}

\end{aufgabe}

\begin{aufgabe}

  Schreiben Sie ein Programm zur Verwaltung von wöchentlichen
  Raumreservierungen an der Uni!

  \begin{enumerate}
  \item Entwerfen Sie eine Daten- und Record-Definition für einen Eintrag eines
    Verwaltungssystems für Vorlesungs- und Seminarräume. Jeder Eintrag beinhaltet
    folgende Informationen: der Name des Raums (als Zeichenkette), der Wochentag,
    die Uhrzeit (es wird nur in Stunden gerechnet) und der Name des Dozenten, der
    den Raum belegt.

  \item Schreiben Sie eine Prozedur \texttt{reserve}, die als Argumente einen Eintrag und einen
    Dozentennamen konsumiert und einen Eintrag zurückgibt. Falls der Raum noch nicht belegt
    wurde (d.h. im Eintrag ist der Dozentenname "`"'), soll der Raum reserviert werden und
    damit ein neuer Eintrag zurückgegeben werden, bei dem der Dozentenname gesetzt ist.
    Andernfalls wird der Eintrag unverändert zurückgegeben.
  \end{enumerate}
\end{aufgabe}


\begin{aufgabe}

  Schreiben Sie weitere Prozeduren für die Computer aus Abschnitt~\ref{sec:computer-konfigurieren}:
  %
  \begin{itemize}
  \item Überlegen Sie sich, wie Sie für einen Computer einen
    geeigneten Preis abhängig von der Konfiguration berechnen würden.
    Schreiben Sie eine Prozedur, welche Ihre Methode realisiert.
  \item Schreiben Sie eine Prozedur, die den Speicher eines Computers
    erweitert.  Sie akzeptiert einen Computer und eine Zahl und liefert
    einen neuen Computer, bei dem der Hauptspeicher um die Zahl erhöht
    ist.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}

  Schreiben Sie eine Daten- und Record-Definition
  für \textit{Uhrzeiten} mit Stunden, Minuten und Sekunden.
  Programmieren Sie folgende Prozeduren für Uhrzeiten:

  \begin{enumerate}
  \item Test, ob zwei Uhrzeiten gleich sind
  \item Test, ob eine Uhrzeit früher ist als eine andere
  \item Test, ob eine Uhrzeit später ist als eine andere
  \item Test, ob eine Uhrzeit am Vormittag ist
  \item Test, ob eine Uhrzeit am Nachmittag ist
  \item Ausgabe der Zeit im 24h-Format, z.B. \verb|"18:45:10"| und
    \verb|"9:12:25"|
  \item Ausgabe der Zeit im 12h-Format, z.B. \verb|"6:45:10 p.m."| und
    \verb|"9:12:25 a.m."|

    \textbf{Hinweis:} Zur Lösung der beiden vorherigen Teilaufgaben
    brauchen Sie die eingebauten Prozeduren
    % 
    \begin{center}
      \texttt{(: number->string (number -> string))},
    \end{center}
    % 
    die eine Zahl in eine Zeichenkette umwandelt und
    % 
    \begin{center}
      \texttt{(: string-append (string string ... -> string))}, 
    \end{center}
    % 
    die eine beliebige Anzahl von Zeichenketten zu einer Zeichenkette
    zusammenhängt.

  \item Umrechnung von Sekunden seit Mitternacht in Uhrzeiten
    
    \textbf{Hinweis:} Zur Lösung der Aufgabe
    brauchen Sie die eingebauten Prozeduren
    % 
    \begin{center}
      \texttt{(: quotient (integer integer -> integer))},
    \end{center}
    % 
    um eine ganzzahlige Division durchzuführen und
    % 
    \begin{center}
      \texttt{(: remainder (integer integer -> integer))}, 
    \end{center}
    % 
    um den Rest einer ganzzahligen Division zu bestimmen.
  \end{enumerate}

  Sie können in jeder Teilaufgabe davon ausgehen, dass nur gültige
  Uhrzeiten (zwischen 0:00:00 und 23:59:59) übergeben werden.

  Benutzen Sie Abstraktionen und schreiben Sie Hilfsprozeduren an den
  Stellen, an denen Sie Teilprobleme lösen!

  Halten Sie sich bei jeder Prozedur, die Sie schreiben, an die
  Konstruktionsanleitungen: Schreiben Sie zuerst die Kurzbeschreibung
  und die Signatur.  Schreiben Sie als nächstes einige Testfälle.
  Leiten Sie danach das Gerüst von der Signatur her und vervollständigen
  Sie den Rumpf der Prozedur.

\end{aufgabe}


\begin{aufgabe}

  Heute backen wir einen Kuchen. 

  \begin{enumerate}
  \item Erstellen Sie eine Datendefinition
    \texttt{dough} für den Teig.  Jeder Teig besteht aus Eiern, Mehl,
    Zucker und Wasser und hat ein Gesamtgewicht.  Überlegen Sie sich
    geeignete Einheiten für die Zutaten.
    % In Teil 3. sind allerdings Einheiten angegeben. Absicht?
  \item Erstellen Sie eine Datendefinition \texttt{cake}
    für Kuchen.  Diese enthält einen Teig, eine Backdauer in Minuten und 
    das Endgewicht des Kuchens.
  \item Schreiben Sie eine Prozedur
    \texttt{ingredients->dough} welche eine Anzahl an Eiern, eine
    Menge Mehl in Gramm, eine Menge Zucker in Gramm und eine
    Menge Wasser in Milliliter erhält und daraus einen Teig
    herstellt. Gehen Sie davon aus, dass jedes Ei 64g wiegt.
  \item Schreiben Sie eine Prozedur \texttt{bake-cake}. 
    Diese erhält einen Teig, eine Backdauer in Minuten und erstellt einen 
    Kuchen.  Gehen Sie davon aus, dass nach dem Backen noch 80\% des
    Wassers im Kuchen sind.
  \end{enumerate}
  
\end{aufgabe}


\begin{aufgabe}

  Schreiben Sie eine Datendefinition
  \texttt{appointment} für Termine, bestehend aus Datum, Uhrzeit,
  Dauer (in Minuten) und Ort.  Verwenden sie für das Datum und die
  Uhrzeit weitere Datendefinitionen bestehend aus Tag, Monat und Jahr
  beziehungsweise Stunde und Minute.

  \begin{enumerate}
  \item Schreiben Sie eine Prozedur \texttt{date-ok?}, die feststellt,
    ob ein Datums-Objekt einem tatsächlichen Kalenderdatum entspricht,
    also korrekte Daten wie 1.1.1970 von unsinnigen wie 34.17.2006
    unterscheidet. Lassen Sie dazu Schaltjahre außer Acht. Beachten
    Sie die Monate mit 28, 30 und 31 Tagen.
  \item Schreiben Sie eine Prozedur \texttt{date-equal?}, die
    vergleicht, ob zwei Datums-Objekte gleich sind.
  \item Schreiben Sie eine Prozedur \texttt{time-ok?}, die feststellt,
    ob ein Zeit-Objekt einer tatsächlichen Uhrzeit entspricht.
  \item Schreiben Sie eine Prozedur \texttt{time-overlap?}, die
    überprüft, ob sich zwei Zeiten mit einer jeweils gegebenen Dauer
    (in Minuten) überschneiden. Gehen Sie davon aus, dass es sich um
    Zeiten desselben Tages handelt.
  \item Schreiben Sie eine Prozedur \texttt{overlap?}, die prüft, ob
    sich zwei gegebene Termine überschneiden. Beachten Sie die Dauer
    der Termine. Gehen Sie davon aus, dass die Termine nicht über
    Mitternacht liegen.
  \end{enumerate}
  %
  \textbf{Hinweis:} Zur Lösung der Aufgabe kann die eingebaute
  Prozedur
  \begin{center}
    \texttt{(: remainder natural natural -> natural)}
  \end{center}

  hilfreich sein. Sie bestimmt den Rest einer ganzzahligen Division.

\end{aufgabe}

\begin{aufgabe}

  Erstellen Sie eine Daten- und eine Record-Definition für einen
    Fahrzeugschein (siehe Abbildung~\ref{fig:fahrzeugschein}).  Gliedern Sie die Felder des
    Fahrzeugscheins sinnvoll in Untergruppen und erstellen Sie für diese
    Untergruppen eigene Daten- und Record-Definitionen.  Benutzen Sie
    sprechende Bezeichner für Records und Felder!  Geben Sie ein
    Beispiel an, indem Sie ein Fahrzeugschein-Objekt mit allen Einträgen
    erzeugen.
    
    
    \begin{figure}[tb]
      \begin{center}
        \includegraphics[width=\linewidth]{i1zus/kfzschein-front}\\
        \medskip
        \includegraphics[width=\linewidth]{i1zus/kfzschein-back}
      \end{center}
      \caption{Vorder- und Rückseite eines Fahrzeugscheins}
      \label{fig:fahrzeugschein}
    \end{figure}
\end{aufgabe}

\begin{aufgabe}

  Schreiben Sie für den Tübinger Stadtverkehr ein
  Programm, welches überprüft ob ein Fahrzeug in den Umweltzonen fahren 
  darf.
  \begin{enumerate}
  \item Definieren Sie einen Datentyp für Fahrzeuge. Dieser
    Datentyp soll den Typ, das Nummernschild und die Schadstoffklasse des
    Fahrzeuges beinhalten.
  \item Erstellen Sie die Beispielfahrzeuge für die
    Fahrzeugtypen "'Stadtbus"', "'Reisebus"', "'Dieselauto"'
    und "'Benzinauto"'. Gehen Sie davon aus, dass die Busse der
    Schadstoffklasse~2, das Dieselauto der Schadstoffklasse~3 und das
    Benzinauto der Schadstoffklasse~4 angehören.
  \item Schreiben Sie eine Prozedur \texttt{fahrverbot?},
    welche überprüft ob ein gegebenes Fahrzeug bei einer gegebenen
    Mindest-Schadstoffklasse noch fahren darf. Gestalten Sie die Signatur
    so, dass er nur Mindest-Schadstoffklassen von 1 bis 4 akzeptiert.
  \item Die Mühlstraße in Tübingen ist in einer Richtung für
    alle Fahrzeuge außer Stadtbusse gesperrt. Schreiben Sie eine Prozedur
    \texttt{sonderrecht?}, die überprüft ob ein gegebenes Fahrzeug die
    Mühlstraße in der gesperrten Richtung befahren darf.  
  \item Bürgermeister Boris Palmer hat die Idee, den Tourismus
    dadurch anzukurbeln, dass Sonntags auch Reisebusse die Mühlstrasse in
    der gesperrten Richtunge befahren dürfen. Erweitern Sie hierfür die
    Prozedur \texttt{sonderrecht?} um den Wochentag und lassen Sie Sonntags
    auch Reisebusse zu.
  \end{enumerate}
  Verwenden Sie beim Schreiben der Prozedur die
  Konstruktionsanleitungen für Prozeduren und für Fallunterscheidungen. 
  Schreiben Sie Testfälle, die alle Möglichkeiten der   
  Fallunterscheidung abdecken.
  
\end{aufgabe}

\begin{aufgabe}

  Schreiben Sie ein Programm für einen Paketdienst, das den Preis
  für ein Paket berechnet!
  \begin{enumerate}
    
  \item Schreiben Sie eine Daten- und eine Record-Definition für
    \textit{Adressen}.  Zu einer Adresse gehören der Name, die Straße
    mit Hausnummer, die Postleitzahl, der Ort und das Land.
    
  \item Der Paketdienst verlangt einen Zuschlag für Sendungen, die
    international verschickt werden.  Schreiben Sie eine Prozedur
    \texttt{international?}, die als Argument eine \textit{Adresse}
    bekommt und feststellt, ob die Adresse im Ausland liegt.

  \item Der Paketdienst hat einen Sondertarif für Sendungen, die
    innerhalb der gleichen Postleitzahl verschickt werden.  Schreiben
    Sie eine Prozedur \texttt{same-zip-code?}, die als Argumente zwei
    \textit{Adressen} bekommt und feststellt, ob die Postleitzahlen
    und die Länder der beiden Adressen gleich sind.

  \item Ein Paket wird klassifiziert nach seinen Abmessungen.
    Schreiben Sie eine Daten- und eine Record-Definition für
    \textit{Abmessungen}.  Abmessungen bestehen aus Länge, Breite und
    Höhe.

  \item Die Paketpreise richten sich nach der Größe des zu
    verschickenden Pakets.  Der Paketdienst verwendet die drei
    Größenklassen \textit{Small}, \textit{Medium} und \textit{Large},
    um die Kosten für das Paket zu berechnen.  Ausschlaggebendes
    Kriterium für die Paketgröße ist die Summe der längsten und der
    kürzesten Seite des Pakets.  Schreiben Sie eine Prozedur
    \texttt{add-longest-and-shortest-side}, die als Argument eine
    \textit{Abmessung} bekommt.  Der Rückgabewert von
    \texttt{add-longest-and-shortest-side} soll die Summe der längsten
    und der kürzesten Seite der Abmessung sein.  Lagern Sie die
    Teilprobleme in zwei Hilfsprozeduren aus: \texttt{longest-side}
    und \texttt{shortest-side}.

  \item Schreiben Sie eine Daten- und eine Record-Definition für
    \textit{Pakete}.  Ein Paket besteht aus einer Absender- und einer
    Empfängeradresse.  Benutzen Sie für die Adressen Ihre bereits
    erstellte Record-Definition.  Außerdem hat ein Paket noch weitere
    Eigenschaften: Die Abmessungen (benutzen Sie dafür Ihre bereits
    erstellte Record-Definition), das Gewicht, die Beförderungsdauer
    und eine Zusatz\-option Nachnahme.  Die Beförderungsdauer soll
    \emph{normal}, \emph{next-day} oder \emph{next-morning} sein.

  \item Schreiben Sie eine Prozedur \texttt{parcel-size-class}, die
    als Argument ein \textit{Paket} bekommt und die Größenklasse
    zurückgibt.  Ausschlaggebend für die Paketgröße ist die Abmessung
    (siehe oben).  Folgende Tabelle enthält die Zuordnung von
    Paketgröße und Abmessung:

    \begin{center}
      \begin{tabular}{c|l}
        Paketgröße & Abmessung \\
        \hline
        S & 0--50 cm \\
        M & $>$50--100 cm \\
        L & $>$100 cm \\
      \end{tabular}
    \end{center}

  \item Schreiben Sie eine Prozedur \texttt{calculate-base-postage},
    die als Argument ein \textit{Paket} bekommt und die
    Basis-Portokosten für dieses Paket berechnet.  Legen Sie dabei
    folgende Grundtariftabelle des Paketdienstes zugrunde:

    \begin{center}
      \begin{tabular}{c|ccc}
        & \multicolumn{3}{c}{Gewicht} \\
        Paketgröße & 0--5 kg & $>$5--10 kg & $>$10 kg \\
        \hline
        S & 3,00 & 6,00 & 9,00 \\
        M & 6,00 & 10,00 & 14,00 \\
        L & 9,00 & 15,00 & 21,00 \\
      \end{tabular}
    \end{center}

    

  \item Schreiben Sie eine Prozedur
    \texttt{transportation-time-factor}, die als Argument ein
    \textit{Paket} bekommt und den Aufschlagsfaktor für die
    Beförderungsdauer zurückliefert.  Legen Sie dabei folgende
    Aufschlagsfaktoren zugrunde:
    
    \begin{center}
      \begin{tabular}{c|ccc}
        & \multicolumn{3}{c}{Beförderungsdauer} \\
        Beförderungsdistanz & normal & next-day & next-morning \\
        \hline
        gleiche PLZ & -25\% & +0\% & +25\% \\
        Inland & +0\% & +50\% & +100\% \\
        Ausland & +100\% & +200\% & +300\% \\
      \end{tabular}
    \end{center}
    
  \item Schreiben Sie eine Prozedur
    \texttt{cash-on-delivery-surcharge}, die als Argument ein
    \textit{Paket} bekommt und den Aufschlag für die Nachnahme
    zurückliefert.  Legen Sie dabei folgende Aufschläge zugrunde:

    \begin{center}
      \begin{tabular}{c|c}
        Beförderungsdistanz & Nachnahmegebühr \\
        \hline
        Inland & +3,00 \\
        Ausland & +9,00 \\
      \end{tabular}
    \end{center}

  \item Schreiben Sie eine Prozedur \texttt{calculate-postage}, die
    als Argument ein \textit{Paket} bekommt und die Portokosten
    berechnet.  Benutzen Sie dafür die von Ihnen programmierten
    Lösungen der verschiedenen Teilprobleme.
    
  \end{enumerate}
  
\end{aufgabe}

\begin{aufgabe}

  Wir repräsentieren einen Lithium-Ionen-Akku als
  eine Liste von Lithium-Ionen-Zellen.  Eine Zelle besteht aus einer
  maximalen Ladung (in Milliamperestunden, mAh) und einer momentanen
  Ladung (ebenfalls in mAh).

  Wenn eine Zelle eine Ladung von 1000mAh hat, bedeutet das, dass die
  Zelle eine Stromstärke von 1000mA (Milliampere) für eine Stunde lang
  liefern kann.  Die momentane Ladung darf nie über die maximale
  Ladung steigen und nie unter 10\% der maximalen Ladung fallen, in
  unserer Beispielzelle also 100mAh, sonst geht die Zelle kaputt.

  % Die Zellen werden nach der Reihe ge- bzw.  entladen.  Wenn die erste
  % Zelle auf 400mAh entladen ist, wird die zweite Zelle entladen, dann
  % die nächste, etc.  Geladen wird in anderer Richtung: Zuerst wird die
  % letzte Zelle geladen, dann die davor, etc.
  
  \begin{enumerate}
    \setlength{\itemsep}{1cm}
  \item Führen Sie eine Datenanalyse für Li-Ionen-Akkus und
    Li-Ionen-Zellen durch, schreiben Sie die Datendefinitionen auf und
    setzen Sie die Datendefinitionen um.

  \item Schreiben Sie folgende Prozeduren:

    \begin{itemize}
    \item \texttt{cell-full?}, die überprüft, ob eine
      Zelle vollständig geladen ist (d.h. ob die momentante
      Ladung gleich der maximalen Ladung ist)

    \item \texttt{cell-empty?}, die überprüft, ob eine Zelle entladen
      ist (d.h. ob die momentane Ladung gleich der minimalen Ladung
      ist, also 10\% der maximalen Ladung)

    \item \texttt{cell-defect?}, die überprüft, ob eine
      Zelle defekt ist (d.h. ob die momentane Ladung die
      maximale Ladung überschreitet oder die minimale Ladung
      unterschreitet)

    \item \texttt{cell-ok?}, die überprüft, ob eine
      Zelle funktioniert (d.h. ob die momentane Ladung
      innerhalb der minimalen und maximalen Ladung liegt)

    \end{itemize}

  \item Schreiben Sie folgende Prozeduren:

    \begin{itemize}
    \item \texttt{battery-full?}, die überprüft, ob ein Akku
      vollständig geladen ist (d.h. ob alle Zellen voll sind); eine
      Batterie ohne Zelle gilt als geladen.

    \item \texttt{battery-empty?}, die überprüft, ob ein Akku entladen
      ist (d.h. ob alle Zellen leer sind); eine Batterie ohne Zelle
      gilt auch als leer.

    \item \texttt{battery-defect?}, die überprüft, ob ein Akku defekt
      ist (d.h. ob mindestens eine Zelle defekt ist); eine Batterie
      ohne Zelle gilt als nicht defekt.

    \item \texttt{battery-ok?}, die überprüft, ob ein Akku
      funktioniert (d.h. ob alle Zellen funktionieren); eine Batterie
      ohne Zelle gilt als funktionstüchtig.
      
    \end{itemize}

    \textbf{Gehen Sie in den folgenden Teilaufgaben davon aus, dass
      nur \emph{funktionierende} Zellen und Batterien übergeben
      werden!}

  \item Das Ladegerät kann eine Zelle um 500mAh pro Stunde
    aufladen.  Schreiben Sie eine Prozedur \\
    \texttt{time-to-fully-charge-cell}, die ausrechnet, wieviele
    Stunden es dauert, bis das Ladegerät die Zelle aufgeladen hat.

  \item Schreiben Sie eine Prozedur
    \texttt{time-to-fully-charge-battery}, die ausrechnet, wieviele
    Stunden es dauert, bis das Ladegerät den Akku aufgeladen hat.

  \item Schreiben Sie eine Prozedur \texttt{charge-cell}, die eine
    Zelle und eine Zeit in Stunden konsumiert und die Zelle
    zurückgibt, die mit dem in der vorherigen Teilaufgabe genannten
    Ladegerät für die übergebene Zeit geladen wurde.  Die Ladung darf
    aber nicht über die maximale Ladung steigen!  Die restliche Zeit
    verfällt, wenn die Zelle bereits voll ist.

  \item Schreiben Sie eine Prozedur \texttt{charge-battery}, die einen
    Akku auflädt.  Die Prozedur gibt einen Akku zurück, der mit dem
    Ladegerät für die übergebene Zeit geladen wurde.  Ist eine Zelle
    vollständig geladen, so wird die nächste Zelle mit der restlichen
    Zeit geladen.  Sind alle Zellen geladen und ist die Zeit jedoch
    noch nicht aufgebraucht, so verstreicht diese.

  \item Das Entladen einer Zelle hängt vom Verbraucher ab: Ein Gerät
    hat einen Verbrauchswert, angegeben in mA.  Anschaulich betrachtet
    heißt das, dass das Gerät pro Zeit eine gewissen Strom verbraucht.
    Schreiben Sie eine Prozedur \texttt{time-to-fully-discharge-cell},
    die eine Zelle und einen Verbrauch pro Stunde konsumiert und
    ausrechnet, wie lange es dauert, bis die Zelle entladen ist.

  \item Schreiben Sie eine Prozedur
    \texttt{time-to-fully-discharge-battery}, die einen Akku und einen
    Verbrauch pro Stunde konsumiert, und ausrechnet, wie lange es
    dauert, bis der Akku entladen ist.

  \item Schreiben Sie eine Prozedur \texttt{discharge-cell}, die eine
    Zelle, einen Verbrauch pro Stunde und die Dauer (in Stunden)
    konsumiert, für die der Verbraucher den Strom der Zelle
    verbraucht.  Die Prozedur soll eine Zelle zurückgeben, die für die
    Dauer den Verbraucher mit Strom versorgt hat.  Die Ladung darf
    aber nicht unter die minimale Ladung fallen! Die restliche Zeit
    verfällt, wenn die Zelle bereits leer ist (tatsächlich geht dem
    Verbraucher einfach der Strom aus...).

  \item Schreiben Sie eine Prozedur \texttt{discharge-battery}, die
    eine Batterie, einen Verbrauch pro Stunde und die Dauer (in
    Stunden) konsumiert.  Die Prozedur soll eine Batterie,
    zurückgeben, die für die Dauer den Verbraucher mit Strom versorgt
    hat.  Ist die Ladung einer Zelle verbraucht, wird die Ladung der
    nächsten Zelle für die verbleibende Zeit verbraucht.  Sind alle
    Zellen entladen und ist die Zeit jedoch noch nicht aufgebraucht,
    so verstreicht diese, dem Verbraucher geht der Strom aus.

  \end{enumerate}
  
\end{aufgabe}

\begin{aufgabe}
  \label{aufgabe:knaubichler}
  Auf seinen Reisen um die Welt trifft Dr.~Sperber
  viele interessante und skurrile Zeitgenossen. Unter ihnen
  Dr.~Knaubichler, ein Experte auf dem Gebiet der Kreuzung von
  mystischen Kreaturen.  Es gibt drei klassische Grundkreaturen:

  \begin{itemize}
  \item Der Garnolaf, der Stärke besitzt.
  \item Das Ronugor, das Wissen besitzt.
  \item Der Tschipotol, der Risikobereitschaft besitzt.
  \end{itemize}
  
  Die Merkmale der Kreaturen sind unterschiedlich ausgeprägt.  Die
  Knaubichler-Kreaturenmerkmal-Skala geht von 0 bis 100.  Die
  Grundkreaturen haben jeweils nur ein Merkmal, keine besitzt ein
  Merkmal einer anderen Grundkreatur.

  Nun kreuzt Dr.~Knaubichler die Grundkreaturen miteinander. Es
  entstehen also
  \begin{itemize}
  \item Das Ronulaf, mit Wissen und Stärke.
  \item Der Tschigor, mit Wissen und Risikobereitschaft.
  \item Das Lapotol, mit Stärke und Risikobereitschaft.
  \item Der Tschirgaronu, Wissen, Stärke und Risikobereitschaft.
  \end{itemize}
  
  Leider erben die Kreuzungen nicht die vollen Merkmale beider
  Grundkreaturen.

  Bei der Kreuzung unterschiedlicher Grunkreaturen gilt folgendes:
  Bei der Kreuzung von Ronugor und Tschipotol wird
  das übernommene Wissen um 10\% veringert; bei Tschipotol und
  Garnolaf hingegen nimmt die Risikobereitschaft um 5\% ab, aber die
  Stärke legt um 8\% zu. Garnolaf und Ronugor lassen die Stärke um 5\%
  zulegen. Kreuzt man alle drei Grundkreaturen, nimmt jede Eigenschaft
  um 3\% ab.
  
  Werden zwei Kreaturen der gleichen Sorte gekreuzt, so entsteht eine
  neue Kreatur mit $\frac{2}{3}$ der addierten Eigenschaften der
  beiden Grundkreaturen. Man kann nur Grundkreaturen kreuzen.

  In jedem Fall kann eine Eigenschaft maximal den Wert 100
  haben.
    
  Dr.~Knaubichler braucht ein Programm, welches die neue Kreatur
  berechnet, bevor er die Kreuzungen durchführt.  Helfen Sie ihm
  dabei!
  
  \begin{enumerate}

  \item Machen Sie eine Datenanalyse und erstellen
    Sie passende Daten- und Recorddefinitionen.  Geben Sie alle
    Signaturen der Record-Prozeduren an!

  \item Schreiben Sie für jede der oben aufgelisteten
    Kreuzungen von zwei Grundkreaturen eine Prozedur, die die Kreuzung
    vornimmt und eine neue Kreatur zurückgibt.
  \end{enumerate}
\end{aufgabe}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
