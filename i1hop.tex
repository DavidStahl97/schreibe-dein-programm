% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Higher-Order-Programmierung}
\label{cha:higher-order}

Der renommierte Informatiker Paul Hudak wurde einst gefragt, was die
drei wichtigsten Dinge beim Programmieren seien.  Er antwortete:
"<Abstraktion, Abstraktion, Abstraktion">.  Entsprechend ist das
Mantra~\ref{mantra:abstraktion} auf Seite~\pageref{mantra:abstraktion}
auch eins der wichtigsten:

\mantraabstraktion*

\noindent In diesem Kapitel werden wir dieses Mantra konsequent anwenden.  Dabei
kommt oft eine besondere Art Funktion heraus: Funktionen, die andere
Funktionen als Eingabe akzeptieren oder als Ausgabe liefern.  Solche
Funktionen heißen auch \textit{Funktionen höherer
  Ordnung}\index{Funktion!höherer Ordnung} oder
\textit{Higher-Order-Funktion}.\index{Higher-Order-Funktion}  Um die
resultierende Art der Programmierung~-- die
\textit{Higher-Order-Programmierung}~-- geht es in diesem Kapitel.

\section{Fußball-Fakten ermitteln}

Eine nahezu unerschöpfliche Quelle für Diskussionen stellen die
Fußballergebnisse dar.  Hier stellen sich so bedeutsame Fragen wie:
\begin{itemize}
\item Wie hat diese Saison Bayern München gegen 1.~FC Kaiserslautern
  auswärts gespielt?\footnote{Wir wissen, das ist schon eine Weile her.}
\item Wie viele Tore sind in dieser Saison gefallen?
\item Welche Mannschaft ist abstiegsgefährdet?
\end{itemize}
%
All diese Informationen speisen sich aus Ergebnissen der Spiele einer
Saison.  Ein Spiel können wir folgendermaßen charakterisieren:
%
\begin{lstlisting}
; Ein Spiel hat folgende Eigenschaften:
; - Spieltag
; - Gastgeber-Team
; - Gastgeber-Tore
; - Gast-Team
; - Gast-Tore
\end{lstlisting}
%
Es handelt sich sichtlich um zusammengesetzte Daten.  Wir müssen uns
überlegen, welche Signaturen zu den einzelnen Bestandteilen passen.
Spieltag und Tore sind allesamt natürliche Zahlen.  Ein Team können
wir durch seinen Namen als Zeichenkette repräsentieren.   Das ergibt
folgende Record-Definition:
%$
\begin{lstlisting}
(define-record-functions game
  make-game game?
  (game-matchday natural)
  (game-home-team string)
  (game-home-goals natural)
  (game-guest-team string)
  (game-guest-goals natural))
\end{lstlisting}
%
Es folgen hier beispielhaft die Ergebnisse des ersten Spieltags der Bundesliga-Saison
2009/2010:
\begin{lstlisting}
(define game1 (make-game 1 "Wolfsburg" 2 "Stuttgart" 0))
(define game2 (make-game 1 "Mainz" 2 "Bayer 04" 2))
(define game3 (make-game 1 "Hertha" 1 "Hannover" 0))
(define game4 (make-game 1 "Bremen" 2 "Frankfurt" 3))
(define game5 (make-game 1 "Nürnberg" 1 "Schalke" 2))
(define game6 (make-game 1 "Dortmund" 1 "1. FC Köln" 0))
(define game7 (make-game 1 "Hoffenheim" 1 "Bayern" 1))
(define game8 (make-game 1 "Bochum" 3 "Gladbach" 3))
(define game9 (make-game 1 "Freiburg" 1 "Hamburg" 1))

(define day1
  (list game1 game2 game3 game4 game5 game6 game7 game8 game9))
\end{lstlisting}
%
Die kompletten Ergebnisse dieser Saison lassen sich unter dem Namen
\texttt{soccer.rkt} von der Webseite des Buchs~--
\url{https://www.deinprogramm.de/}~-- herunterladen.

Eine recht einfache Frage ist die Bestimmung der Punktzahl, welche die
Gastgebermannschaft in einem bestimmten Spiel erzielt hat.  Die
Punktzahl ist zwar eine natürliche Zahl, es gibt aber nur drei
Möglichkeiten: 0, 1 und 3.  Wir können also eine präzisere Signatur
als \lstinline{points} definieren:
%
\begin{lstlisting}
; Punktzahl in Spiel
(define points
  (signature (enum 0 1 3)))
\end{lstlisting}
%
Unsere Funktion für die Bestimmung der Punktzahl hat Kurzbeschreibung,
Signatur, Tests und Gerüst wie folgt:\index{home-points@\texttt{home-points}}
%
\begin{lstlisting}
; Punktzahl für Gastgeber-Team berechnen
(: home-points (game -> points))

(check-expect (home-points game1) 3)
(check-expect (home-points game2) 1)
(check-expect (home-points game3) 3)
(check-expect (home-points game4) 0)

(define home-points
  (lambda (game)
    ...))
\end{lstlisting}
% 
Entsprechend der Signatur der Ausgabe fallen die Spiele in drei
unterschiedliche Klassen, das heißt wir brauchen eine Verzweigung mit
drei Zweigen entsprechend den drei möglichen Punktzahlen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (cond
      (... 3)
      (... 0)
      (... 1))))
\end{lstlisting}
%
Die Bedingungen der drei Zweige kommen aus den Fußballregeln~-- wir
müssen die Tore von Heim- und Gastmannschaft vergleichen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (define goals1 )
    (define goals2 )
    (cond
      ((> (game-home-goals game) (game-guest-goals game)) 3)
      ((< (game-home-goals game) (game-guest-goals game)) 0)
      ((= (game-home-goals game) (game-guest-goals game)) 1))))
\end{lstlisting}
%
Das funktioniert schon korrekt, ist aber noch unelegant.
Das \lstinline{(game-home-goals game)} ist dreimal wiederholt~-- wir
sollten eine lokale Definition einführen, damit es nur einmal
dasteht.  Ebenso für den Aufruf von \lstinline{game-guest-goals}.  Das
sieht dann so aus:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (define goals1 (game-home-goals game))
    (define goals2 (game-guest-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Du könntest berechtigterweise fragen, warum die lokalen Variablen
\lstinline{goals1} und \lstinline{goals2} heißen, und nicht
\lstinline{home-goals} und \lstinline{guest-goals} heißen.  Das wird
bei der nächsten Funktion (hoffentlich) klar, welche die Punkte
ausrechnet, die dem Gästeteam zustehen:
%
\begin{lstlisting}
; Punktzahl für Gast-Team berechnen
(: guest-points (game -> points))

(define guest-points
  (lambda (game)
    (define goals1 (game-guest-goals game))
    (define goals2 (game-home-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Diese beiden Funktionen sind weitgehend identisch, der einzige
Unterschied ist die Definition der lokalen Variablen
\lstinline{goals1} und \lstinline{goals2}. Eine solche Duplizierung
von Code ist immer schlecht, vor allem, wenn sich etwas
ändert. Theoretisch könnte der Fußballbund die Regeln für die Vergabe
von Punkten ändern sollte, und dann müssten wir beide Funktionen in
gleicher Weise anpassen.  Die Lösung für das Problem zeigt sich
dadurch, dass wir aus dem gemeinsamen Code der beiden Funktionen
eine neue Funktion machen, entsprechend dem Abstraktions-Mantra.

Zu diesem Zweck kopieren wir eine der beiden Funktionsdefinitionen und
geben ihr einen neuen Namen, in diesem Fall \lstinline{compute-points}:
%
\begin{lstlisting}
(define compute-points
  (lambda (game)
    (define goals1 (game-guest-goals game))
    (define goals2 (game-home-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Nun identifizieren wir in der kopierten Funktion die Stellen, die sich
bei den beiden ursprünglichen Funktionen unterscheiden und ersetzen
diese Stellen durch neue Namen.  Hier sind das gerade
\lstinline{game-guest-goals} und \lstinline{game-home-goals}, wir
ersetzen sie durch die Namen \lstinline{get-goals-1} und
\lstinline{get-goals-2}:
%
\begin{lstlisting}
(define compute-points
  (lambda (game)
    (define goals1 (get-goals-1 game))
    (define goals2 (get-goals-2 game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Diese neuen Variablen sind noch ungebunden, wir müssen sie deshalb
noch im \lstinline{lambda} unterbringen:
%
\begin{lstlisting}
(define compute-points
  (lambda (get-goals-1 get-goals-2 game)
    (define goals1 (get-goals-1 game))
    (define goals2 (get-goals-2 game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Damit können wir die bisherigen Definitionen von
\lstinline{home-points} und \lstinline{guest-points} ersetzen durch
die folgenden:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (compute-points game-home-goals game-guest-goals game)))

(define guest-points
  (lambda (game)
    (compute-points game-guest-goals game-home-goals game)))
\end{lstlisting}
%
Diese neuen Definitionen lassen die Gemeinsamkeiten und Unterschiede
beider Funktionen klar erkennen und vermeiden die doppelte Definition
der Fußball-Punkteregeln.

\textbf{Wichtig:} Diese beiden Definitionen müssen \emph{nach} der
Definition von \texttt{compute-points} stehen, da davor
\texttt{compute-points} noch nicht definiert ist.

Der neuen Funktion fehlt noch eine Signatur.  Die Funktion akzeptiert
drei Argumente.  Das letzte hat die Signatur \lstinline{game}.  Die
ersten beiden werden aus den Funktionen \lstinline{game-home-goals}
und \lstinline{game-guest-goals} bestückt, die jeweils die Signatur
\lstinline{(game -> natural)} haben.  Daraus können wir die Signatur
für \lstinline{compute-points} zusammensetzen:
%
\begin{lstlisting}
(: compute-points ((game -> natural) (game -> natural) game -> points))
\end{lstlisting}
%
In der Signatur tauchen mehrere Pfeile auf, weil die Funktion
\lstinline{compute-points} ihrerseits zwei Funktionen als Argumente
akzeptiert.  Solche Funktionen mit mehreren Pfeilen in der Signatur
heißen \textit{Funktionen höherer Ordnung\index{Funktion!höherer
    Ordnung}} oder
\textit{Higher-Order-Funktionen\index{Higher-Order-Funktion}}.

Die Abstraktion bei der Entwicklung von \lstinline{compute-points}
hätten wir auch etwas anders anstellen können: Wir haben bei
\lstinline{compute-points} die beiden Parameter
\lstinline{get-goals-1} und \lstinline{get-goals-2} zu dem schon
bestehenden \lstinline{lambda} hinzugefügt.  Wir können stattdessen
auch ein neues \lstinline{lambda} einfügen.  (Bei Definitionen, in
denen noch kein \lstinline{lambda} steht, müssten wir das sowieso.)
Das sieht dann so aus:
%
\begin{lstlisting}
(define make-compute-points
  (lambda (get-goals-1 get-goals-2)
    (lambda (game)
      (define goals1 (get-goals-1 game))
      (define goals2 (get-goals-2 game))
      (cond
        ((> goals1 goals2) 3)
        ((< goals1 goals2) 0)
        ((= goals1 goals2) 1)))))
\end{lstlisting}
%
Die Signatur dieser Funktion unterscheidet sich leicht von der
Signatur von \lstinline{compute-points}.  Sie akzeptiert nicht mehr drei
Argumente sondern nur zwei, aber liefert dafür eine Funktion, die von
einem Spiel die Punkte liefert:
%
\begin{lstinline}
(: make-compute-points ((game -> natural) (game -> natural) 
                         -> (game -> points)))
\end{lstinline}
%
Auch mit dieser Funktion können wir alternative Definitionen von
\lstinline{make-compute-points} schreiben.  Auf den ersten Blick ist
das umständlich, wenn wir das genauso machen wie mit
\lstinline{compute-points}, da wir noch mehr Klammern brauchen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    ((make-compute-points game-home-goals game-guest-goals) game)))

(define guest-points
  (lambda (game)
    ((make-compute-points game-guest-goals game-home-goals) game)))
\end{lstlisting}
%
Vielleicht fällt Dir aber das Muster auf, das diese beiden
Definitionen gemeinsam haben:
%
\begin{lstlisting}
(define f
  (lambda (x)
    (g x)))
\end{lstlisting}
%
Das heißt, wenn das Programm \lstinline{f} aufruft, ruft diese
Funktion direkt \lstinline{g} auf, mit der gleichen Eingabe:
\lstinline{f} und \lstinline{g} sind also äquivalent, und wir könnten
genauso gut schreiben:
%
\begin{lstlisting}
(define f g)
\end{lstlisting}
%
Das gleiche Prinzip können wir auch auf \lstinline{home-points} und
\lstinline{guest-points} anwenden:
%
\begin{lstlisting}
(define home-points
  (make-compute-points game-home-goals game-guest-goals))

(define guest-points
  (make-compute-points game-guest-goals game-home-goals))
\end{lstlisting}
%
Man kann auch schön an der Signatur von
\lstinline{make-compute-points} sehen, dass diese als Resultat eine
Funktion mit Signatur \lstinline{(game -> points)} liefert, das ist
gerade die gewünschte Signatur von \lstinline{home-points} und
\lstinline{guest-points}.

Vielleicht hast Du Dich über den Namen \lstinline{make-compute-points}
gewundert: Während die Funktion \lstinline{compute-points} direkt eine Punktzahl
berechnet, macht \lstinline{make-compute-points} eine Funktion, welche
die Punktzahl berechnet: Darum der Präfix \lstinline{make-}.  Es
handelt sich also um eine Art "<Funktionsfabrik">.

\begin{aufgabeinline}
  Wir hätten das neue \lstinline{lambda} auch unterhalb des alten
  \lstinline{lambda} einfügen können statt oberhalb.  Welche Signatur
  hätte die Funktion \lstinline{make-compute-points} dann?  Warum ist
  das keine so gute Idee?
\end{aufgabeinline}

Die Abstraktionstechnik, die wir für die Konstruktion von
\lstinline{compute-points} und \lstinline{make-compute-points}
verwendet haben, wenden wir in diesem Buch noch öfter an.  Sie
verdient deshalb eine eigene Konstruktionsanleitung:

\begin{konstruktionsanleitung}{Abstraktion}
  \label{ka:abstraktion}
  Wenn Du zwei Definitionen geschrieben hast, die inhaltlich verwandt
  sind und viele Ähnlichkeiten aufweisen, abstrahiere wie folgt:
  %
  \begin{enumerate}
  \item Kopiere eine der beiden Definitionen und gib ihr einen neuen
    Namen.
  \item Ersetze die Stellen, bei denen sich die beiden Definitionen
    unterscheiden, jeweils durch eine neue Variable.
  \item Füge die neuen Variablen als Parameter zum \lstinline{lambda}
    der Definition hinzu oder füge ein neues \lstinline{lambda} mit
    diesen Parametern ein.
  \item Schreibe eine Signatur für die neue Funktion.
  \item Ersetze die beiden alten Definitionen durch Aufrufe der neuen
    Definition.
  \end{enumerate}
\end{konstruktionsanleitung}

\section{Higher-Order-Funktionen auf Listen}

Eine weitere interessante Aufgabe ist es, aus einer Liste von Spielen die
unentschieden ausgegangenen Spiele herauszusuchen. Dazu ist zunächst eine
Funktion notwendig, die feststellt, ob ein bestimmtes Spiel unentschieden war:
\begin{lstlisting}
; Ist Spiel unentschieden?
(: game-draw? (game -> boolean))

(define game-draw?
  (lambda (g)
    (= 1 (home-points g))))
\end{lstlisting}
Die jetzt gesuchte Funktion muss Kurzbeschreibung und Signatur wie folgt haben:
\begin{lstlisting}
; Unentschiedene Spiele heraussuchen
(: games-draw ((list-of game) -> (list-of game)))
\end{lstlisting}
%
Die Definition folgt der Konstruktionsanleitung für Funktionen auf Listen.
Hier ist die Schablone:
%
\begin{lstlisting}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) ...)
      ((cons? lis)
       ... (first lis) ...
       ... (games-draw (rest lis)) ...))))
\end{lstlisting}
%
Der erste Fall ist klar: wo keine Spiele sind, sind auch keine
unentschiedenen.  Der zweite Fall betrachtet das erste Element \texttt{(first
  lis)}.  Dabei ist entscheidend, ob es sich dabei um ein unentschiedenes Spiel
handelt oder nicht:
%
\begin{lstlisting}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       ... (game-draw? (first lis)) ...
       ... (games-draw (rest lis)) ...))))
\end{lstlisting}
%
Die Fallunterscheidung bestimmt, ob ein Spiel in die Ergebnisliste kommt oder
nicht:
%
\begin{lstlisting}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (let ((f (first lis))
             (r (games-draw (rest lis))))
       (if (game-draw? f)
           (cons f r)
           r)))))))
\end{lstlisting}
%
Fertig!

Eine ganz ähnliche Funktion sortiert aus einer Liste von Spielen diejenigen
aus, an denen eine bestimmte Mannschaft teilgenommen hat:
\index{games-playing@\texttt{games-playing}}
%
\begin{lstlisting}
; Spielt Team bei Spiel?
(: plays-game? (string game -> boolean))

(define plays-game?
  (lambda (t g)
    (or (string=? t (game-home-team g))
        (string=? t (game-guest-team g)))))

; Alle Spiele mit einem Team herausfiltern
(: games-playing (string (list-of game) -> (list-of game)))

(define games-playing
  (lambda (t lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (let ((f (first lis))
             (r (games-playing t (rest lis))))
         (if (plays-game? t f)
             (cons f r)
             r))))))
\end{lstlisting}
%
Die Funktionen \texttt{games-draw} und \texttt{games-playing} unterscheiden
sich, abgesehen vom Namen und der Tatsache, dass \texttt{games-playing} noch
den Namen eines Teams als zusätzlichen Parameter hat, nur an
einer Stelle: \texttt{games-draw} verwendet
\texttt{game-draw?} an der Stelle, wo \texttt{games"=playing} 
\texttt{plays-game?} verwendet.  Eine einzelne Funktion könnte die
Aufgaben sowohl von \texttt{games-draw} als auch von \texttt{games-playing}
lösen, indem sie an der Stelle, an der \texttt{game-draw?}
bzw.\ \texttt{plays-game?} steht, verallgemeinert.  Das geht mit
Abstraktion: für das konkrete Prädikat wird ein
Parameter eingeführt.  Das Ergebnis, das sich ansonsten
direkt aus den Definitionen von \texttt{games-draw} und
\texttt{games-playing} ergibt, sieht so aus (erst einmal ohne
Signatur, die nachgeliefert wird):\index{filter-games@\texttt{filter-games}}
%
\begin{lstlisting}
(define filter-games
  (lambda (p? lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (if (p? (first lis))
           (cons (first lis)
                      (filter-games p? (rest lis)))
           (filter-games p? (rest lis)))))))
\end{lstlisting}
%
Das funktioniert tatsächlich:
%
\begin{lstlisting}
(define plays-nürnberg?
   (lambda (g)
      (plays-game? "Nürnberg" g)))

(filter-games plays-nürnberg? day1)
\evalsto{} #<list #<record:game 1 "Nürnberg" 1 "Schalke" 2>>
\end{lstlisting}
%
Das Abstrahieren über Funktionen funktioniert also genauso wie die
Abstraktion über andere Werte.  Die Signatur für die Funktion muss
natürlich berücksichtigen, dass \texttt{p?} eine Funktion ist.  Die Funktion
\texttt{plays-nürnberg?}, die für \texttt{p?}  verwendet wird, hat die
Signatur
%
\begin{lstlisting}
(: plays-nürnberg? (game -> boolean))
\end{lstlisting}
%
und deshalb hat \texttt{filter-games} folgende Signatur:
%
\begin{lstlisting}
(: filter-games ((game -> boolean) (list-of game) -> (list-of game)))
\end{lstlisting}
%
Tatsächlich steht aber in \texttt{filter-games} außer dem Namen dieser Funktion
jetzt nichts mehr, das
überhaupt Bezug darauf nimmt, dass es sich bei den Listenelementen um
\texttt{game}-Records handelt.  % Tatsächlich funktioniert die Funktion
% auch auf Listen von Zahlen:
% %
% \begin{lstlisting}
% (filter-games even? (list 1 2 3 4))
% \evalsto{} #<list 2 4>
% (filter-games odd? (list 1 2 3 4))
% \evalsto{} #<list 1 3>
% \end{lstlisting}
% So nicht, das gibt eine Signaturverletzung, denn \texttt{even?} hat nicht die
% Signatur \texttt{(game -> boolean)}!
% %
Damit kann das Wort \texttt{games} ganz aus der Funktiondefinition
verschwinden, und es entsteht eine vielseitig verwendbare Funktion
namens \texttt{list-filter}:\index{filter@\texttt{list-filter}}
%
\begin{lstlisting}
; aus einer Liste eine Liste der Elemente bilden,
; die eine bestimmte Eigenschaft haben
(: list-filter ((%a -> boolean) (list-of %a) -> (list-of %a)))
(define list-filter
  (lambda (p? lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (if (p? (first lis))
           (cons (first lis)
                      (list-filter p? (rest lis)))
           (filter p? (rest lis)))))))
\end{lstlisting}


Die Entstehung von \texttt{list-filter} aus \texttt{games-draw} und
\texttt{games-playing} ist ein Paradebeispiel für die Abstraktion mit
Hilfe von Mustern.  Die Anwendung dieser Technik bringt eine Reihe von
Vorteilen:
%
\begin{itemize}
\item Das Programm wird kürzer.
\item Das Programm wird leichter zu lesen.
\item Wenn die Funktion korrekt ist, sind auch alle ihre Anwendungen
  korrekt.
\end{itemize}
%
Damit diese Vorteile zur Geltung kommen, müssen die "<alten">
Abstraktionsvorlagen gelöscht und durch Anwendungen der Abstraktion
ersetzt werden:
%
\begin{lstlisting}
; aus einer Spieleliste eine Liste der unentschiedenen Spiele bilden
(: games-draw ((list-of game) -> (list-of game)))
(define games-draw
  (lambda (lis)
    (list-filter game-draw? lis)))

; aus einer Spieleliste eine Liste der Spiele einer Mannschaft t bilden
(: games-playing (string (list-of game) -> (list-of game)))
(define games-playing
  (lambda (t lis)
    (list-filter (lambda (g) (plays-game? t g)) lis)))
\end{lstlisting}
%
In der Definition von \texttt{games-playing} bekam die Funktion
\texttt{list-filter} statt des Namens eines Prädikats direkt eine
Funktiondefinition.  Hier handelt es sich also technisch um eine \emph{anonyme
  Funktion}; dies wird in Abschnitt~\ref{sec:anonymous-procedures} noch weiter ausgeführt.

\section{Listen zusammenfalten}

Aus Abschnitt~\ref{sec:lists} ist die Funktion \texttt{list-sum}
bekannt, welche die Summe einer Liste von Zahlen bildet:
%
\begin{lstlisting}
; Liste aufsummieren
(: list-sum ((list-of number) -> number))
(define list-sum
  (lambda (lis)
    (cond
      ((empty? lis) 0)
      ((cons? lis) 
       (+ (first lis)
          (list-sum (rest lis)))))))
\end{lstlisting}
%
Eine eng verwandte Funktion würde die Elemente einer Liste nicht
aufsummieren, sondern aufmultiplizieren.   Signatur und Schablone sind
identisch zu \texttt{list-sum}:\index{list-product@\texttt{list-product}}
%
\begin{lstlisting}
; Liste aufmultiplizieren
(: list-product ((list-of number) -> number))
(define list-product
  (lambda (lis)
    (cond
      ((empty? lis) ...)
      ((cons? lis) 
       ... (first lis) ...
       ... (list-product (rest lis)) ...))))
\end{lstlisting}
%
Die erste Ellipse muss das Produkt der leeren Liste sein, also das
neutrale Element $1$ der Multiplikation.\footnote{0 funktioniert
  hier nicht~-- es würde dafür sorgen,
  dass \emph{jede} Liste 0 als Produkt hat.} 
Aus dem ersten Element und dem Produkt der
Restliste wird das Produkt der Gesamtliste durch
Multiplikation gebildet.\index{list-product@\texttt{list-product}}
%
\begin{lstlisting}
(define list-product
  (lambda (lis)
    (cond
      ((empty? lis) 1)
      ((cons? lis) 
       (* (first lis)
          (list-product (rest lis)))))))
\end{lstlisting}
%
Die Definitionen von \texttt{list-sum} und \texttt{list-product}
unterscheiden sich, bis auf den Namen, nur an zwei Stellen: beim ersten
Zweig, wo das jeweilige neutrale Element steht, und bei der Funktion,
die benutzt wird, um das erste Element mit dem Ergebnis des rekursiven
Aufrufs zu kombinieren.  Die abstrahierte Funktion heißt
\texttt{list-fold} und sieht folgendermaßen aus (die Signatur muss noch
einen Moment warten):\index{list-fold@\texttt{list-fold}}
%
\begin{lstlisting}
; die Elemente einer Liste kombinieren
(define list-fold
  (lambda (unit combine lis)
    (cond
      ((empty? lis) unit)
      ((cons? lis) 
       (combine (first lis)
                (list-fold unit combine (rest lis)))))))
\end{lstlisting}
%
Listen lassen sich damit folgendermaßen summieren:
%
\begin{lstlisting}
(list-fold 0 + (list 1 2 3 4))
\evalsto{} 10
\end{lstlisting}
%
und so aufmultiplizieren:
%
\begin{lstlisting}
(list-fold 1 * (list 1 2 3 4))
\evalsto{} 24
\end{lstlisting}
%
Die Signatur für \texttt{list-fold} ist nicht auf den ersten Blick
ersichtlich.  Hier ein erster Anlauf:

FIXME: Wie kommt man darauf?

%
\begin{lstlisting}
(: list-fold (%a (%a %a -> %a) (list-of %a) -> %a))
\end{lstlisting}
%
Wie sich weiter unten herausstellen wird, kann
diese Signatur aber
noch verallgemeinert werden.  Erst kommen allerdings noch einige
Erläuterungen zur Funktionsweise.

FIXME: zuviele Funktionen

\texttt{List-fold} funktioniert wie folgt: Die Funktion hat als
Parameter eine Funktion mit zwei Parametern, einen Wert und eine
Liste von Werten.  Es gilt folgende Gleichung:
%
\begin{displaymath}
  \texttt{(list-fold}~u~o~\verb|#<list |a_1~\ldots~a_n\verb|>|\texttt{)}
  = \texttt{($o$ $a_1$ ($o$ $a_2$ ($\ldots$ ($o$ $a_n$ $u$)$ \ldots$)))}
\end{displaymath}
%
Die Funktionsweise von \texttt{list-fold} lässt sich daran
veranschaulichen, dass sich die ursprüngliche Liste auch als
%
\begin{displaymath}
\texttt{(cons $a_1$ (cons $a_2$ ($\ldots$ (cons $a_n$ empty)$ \ldots$)))}
\end{displaymath}
%
schreiben lässt.  Das heißt, an die Stelle von \texttt{cons} tritt
$o$ und an die Stelle von \texttt{empty} tritt $u$.

Eine andere, praktische Darstellung von 
\texttt{list-fold} ist, die Gleichung mit dem Operator
\emph{zwischen} den Operanden zu schreiben (und nicht davor), in
Infix-Schreibweise also:
%
\begin{displaymath}
  \texttt{(list-fold}~u~\odot~\verb|#<list |a_1~\ldots~a_n\verb|>|\texttt{)}
  = a_1 \odot (a_2 \odot (\ldots (a_n \odot u)\ldots ))
\end{displaymath}
%
Nach dieser Sichtweise wird $\odot$ zwischen die Elemente der Liste
eingefügt.

In jedem Fall wird die Liste "<eingefaltet">~-- daher der Name.

Die Definition von \texttt{concatenate} aus
Abschnitt~\ref{sec:more-lists} passt ebenfalls auf das abstrahierte
Muster von \texttt{list-fold}:
%
\begin{lstlisting}
(list-fold (list 4 5 6) cons (list 1 2 3))
\evalsto{} #<list 1 2 3 4 5 6>
\end{lstlisting}
%
Diese Applikation passt aber nicht mehr auf den obigen Signaturversuch von
\texttt{list-fold}, da \texttt{make"=pair} nicht die Signatur
%
\begin{lstlisting}
%a %a -> %a
\end{lstlisting}
%
sondern
%
\begin{lstlisting}
%a (list-of %a) -> (list-of %a)
\end{lstlisting}
%
und deshalb
%
\begin{lstlisting}
%a %b -> %b
\end{lstlisting}
besitzt.  \texttt{List-fold} hat also folgende Signatur:
%
\begin{lstlisting}
(: list-fold (%b (%a %b -> %b) (list-of %a) -> %b)))
\end{lstlisting}
%

\section{Anonyme Funktionen}\label{sec:anonymous-procedures}

\texttt{List-fold} kann auch benutzt werden, um die Länge einer Liste
auszurechnen.  Ganz so einfach wie bei den vorigen Beispielen ist das
nicht, da \texttt{list-length} aus
Abschnitt~\ref{sec:more-lists} nicht direkt dem Muster entspricht:
%
\begin{lstlisting}
(define list-length
  (lambda (lis)
    (cond
      ((empty? lis) 0)
      ((cons? lis) 
       (+ 1 
          (list-length (rest lis)))))))
\end{lstlisting}
%
Für das \texttt{combine}-Argument von \texttt{list-fold}
würde hier eine Funktion benötigt, die ihr erstes
Argument \texttt{(first lis)} ignoriert (es spielt ja für die Listenlänge
keine Rolle) und auf das zweite Argument eins addiert.  Diese
Hilfsfunktion sieht so aus:\index{add-1-for-length@\texttt{add-1-for-length}}
%
FIXME: warum nicht \texttt{\%a}?  Warum heißt das \texttt{ignore}?

\begin{lstlisting}
(: add-1-for-length (any natural -> natural))
(define add-1-for-length
  (lambda (ignore n)
    (+ n 1)))
\end{lstlisting}
%
Damit funktioniert es:
%
\begin{lstlisting}
(list-fold 0 add-1-for-length (list 1 2 3 4 5))
\evalsto{} 5
\end{lstlisting}
%
Für solche Mini-Funktionen lohnt es sich oft kaum, eine eigene
Definition anzugeben und einen sinnstiftenden Namen zu finden.  Das
ist auch nicht notwendig: die rechte Seite der Definition, also der
Lambda-Ausdruck, kann auch direkt eingesetzt werden:
%
\begin{lstlisting}
(list-fold 0 (lambda (ignore n) (+ n 1)) (list 1 2 3 4 5))
\evalsto{} 5
\end{lstlisting}
%
Meist tauchen Lambda-Ausdrücke zwar als Teil von Funktiondefinition
auf, aber es ist natürlich möglich, Funktionen außerhalb einer
Definition zu verwenden, ohne ihnen einen Namen zu geben.  Dafür gab
es schon in Kapitel~\ref{cha:whats-programming} Beispiele. Mit Hilfe
solcher "<anonymer Funktionen\index{anonyme
  Funktion}\index{Funktion!anonym}"> lässt sich auch \texttt{list-filter}
durch \texttt{list-fold} definieren:
%
\begin{lstlisting}
(define list-filter
  (lambda (p? lis)
    (list-fold empty
               (lambda (first result)
                 (if (p? first)
                     (cons first result)
                     result))
               lis)))
\end{lstlisting}
%
Ein weiteres Beispiel~-- die Funktion
\texttt{every?}\index{every?@\texttt{every?}} findet heraus, ob ein
übergebenes Prädikat auf alle Elemente einer Liste zutrifft:
\label{page:every}
%
\begin{lstlisting}
; prüfen, ob Prädikat auf alle Elemente einer Liste zutrifft
(: every? ((%a -> boolean) (list-of %a) -> boolean))
(define every?
  (lambda (p? lis)
    (list-fold #t
               (lambda (first result)
                 (and result
                      (p? first)))
               lis)))
\end{lstlisting}
%
Anders als \texttt{list-length} lassen sich diese Definitionen
nicht mit separaten Hilfsfunktionen schreiben.  Für
\texttt{list-filter} würde ein Versuch zwar so aussehen:
%
\begin{lstlisting}
(define list-filter-helper
  (lambda (first result)
    (if (p? first)
        (cons first result)
        result)))
\end{lstlisting}
%
In \drscheme{} erscheint bei dieser Definition eine Fehlermeldung 
"<\texttt{unbound variable}"> und \texttt{p?} wird rosa markiert.  Das
liegt daran, dass \texttt{p?} weiter außen im \texttt{lambda} von
\texttt{filter} gebunden ist.  Dieses \texttt{p?} ist aber nach den
Regeln der lexikalischen Bindung\index{lexikalische Bindung} (siehe
Abschnitt~\ref{sec:lexical-binding}) nur im Rumpf des äußeren
\texttt{lambda} in der Definition von \texttt{filter} sichtbar.  Darum
muss der Lambda-Ausdruck der Hilfsfunktion ebenfalls in diesem
Rumpf stehen.

FIXME: Hier auch noch \texttt{map} einführen? Das Unterrichtsbeispiel tat
es\ldots

\section{Funktionfabriken}

Ein nützlicheres Beispiel für eine Higher-Order-Funktion in der
Mathematik ist die
Komposition\index{Komposition}\index{*@$\circ$}
$\circ$.  Seien $f: B\rightarrow C$ und $g: A\rightarrow B$
Funktionen.  Dann ist $f\circ g$ folgendermaßen definiert:
%
\begin{displaymath}
  (f \circ g)(x) \deq{} f(g(x))
\end{displaymath}
%
$\circ$ lässt sich direkt als Funktion
programmieren:\index{compose@\texttt{compose}}
\label{page:compose}
%
\begin{lstlisting}
; zwei Funktionen komponieren
(: compose ((%b -> %c) (%a -> %b) -> (%a -> %c)))
(define compose
  (lambda (f g)
    (lambda (x)
      (f (g x)))))
\end{lstlisting}
%
Die beiden Argumente für \texttt{f} und \texttt{g} müssen Funktionen
mit einem Parameter sein:
%
\begin{lstlisting}
(define add-5
  (lambda (x)
    (+ x 5)))
(define add-23
  (lambda (x)
    (+ 23 x)))
(define add-28 (compose add-5 add-23))
(add-28 3)
\evalsto{} 31
((compose (lambda (x) (* x 2)) add-1) 5)
\evalsto{} 12
\end{lstlisting}
%
\texttt{Compose} ist eine
\textit{Funktionfabrik\index{Funktionfabrik}}~-- sie liefert selbst
eine Funktion zurück, die abhängig von \texttt{f} und \texttt{g}
konstruiert wird.

\texttt{Compose} lässt sich benutzen, um eine weitere praktische
Higher-Order-Funktion namens
\texttt{repeat} zu definieren:\index{repeat@\texttt{repeat}}
\label{page:repeat}
%
\begin{lstlisting}
; Funktion wiederholt anwenden
(: repeat (natural (%a -> %a) -> (%a -> %a)))
(define repeat
  (lambda (n proc)
    (if (= n 0)
        (lambda (x) x)
        (compose proc (repeat (- n 1) proc)))))
\end{lstlisting}
%
\texttt{Repeat} ist das Pendant zur Potenzierung\index{Potenzierung} von
Funktionen in der Mathematik, siehe Definition~\ref{def:power_fun}:
%
\begin{lstlisting}
((repeat 5 (lambda (n) (* n 2))) 1)
\evalsto{} 32
\end{lstlisting}

\section{Der Schönfinkel-Isomorphismus}
\label{sec:currying}
\index{Schönfinkel-Isomorphismus}
Hier ist eine Funktionfabrik, die Funktionen erzeugt, die auf eine
Zahl eine Konstante addieren:\index{make-add@\texttt{make-add}}
%
\begin{lstlisting}
; Funktion erzeugen, die eine Konstante addiert
(: make-add (number -> (number -> number)))
(define make-add
  (lambda (a)
    (lambda (b)
      (+ a b))))
\end{lstlisting}
%
Angewendet werden kann sie folgendermaßen:
%
\begin{lstlisting}
(define add-1 (make-add 1))
(add-1 15)
\evalsto{} 16
(define add-7 (make-add 7))
(add-7 15)
\evalsto{} 22
\end{lstlisting}
%
Das geht auch ohne Zwischendefinitionen:
%
\begin{lstlisting}
((make-add 7) 15)
\evalsto{} 22
((make-add 13) 42)
\evalsto{} 55
\end{lstlisting}
%
\texttt{Make-add} ist eine andere Version von \texttt{+}, nämlich
eine, die zwei Argumente nicht "<auf einmal"> akzeptiert, sondern
"<nacheinander">.  Summen von zwei Zahlen, normalerweise geschrieben
als \texttt{(+ $a$ $b$)} lassen sich auch als \texttt{((make-add $a$)
  $b$)} schreiben.  Diese Transformation von einer Funktion mit zwei
Parametern in eine Funktion mit nur einem Parameter, die eine Funktion
mit einem weiteren Parameter zurückgibt, die dann schließlich den "<Wert">
liefert, lässt sich auch auf andere Funktionen anwenden:\index{make-mult@\texttt{make-mult}}\index{make-prepend@\texttt{make-prepend}}
%
\begin{lstlisting}
; Funktion erzeugen, die mit einer Konstante multipliziert
(: make-mult (number -> (number -> number)))
(define make-mult
  (lambda (a)
    (lambda (b)
      (* a b))))

; Funktion erzeugen, die an eine Liste ein Element vorn anhängt
(: make-prepend (a -> ((list-of a) -> (list-of a))))
(define make-prepend
  (lambda (a)
    (lambda (b)
      (cons a b))))
\end{lstlisting}
%
Erneut folgt eine ganze Familie von Funktionen einem gemeinsamen
Muster, und erneut lässt sich dieses Muster als Funktion höherer
Ordnung formulieren.  Die Funktion \texttt{curry\index{curry@\texttt{curry}}} akzeptiert
eine Funktion mit zwei Parametern und liefert eine entsprechend
transformierte Funktion zurück:
%
\begin{lstlisting}
; Funktion mit zwei Parametern staffeln
(: curry ((%a %b -> %c) -> (%a -> (%b -> %c))))
(define curry
  (lambda (proc)
    (lambda (a)
      (lambda (b)
        (proc a b)))))
\end{lstlisting}
%
Nun lassen sich die \texttt{make-$x$}-Funktionen von oben mit Hilfe
von \texttt{curry} definieren:
%
\begin{lstlisting}
(define make-add (curry +))
(define make-mult (curry *))
(define make-prepend (curry cons))
\end{lstlisting}
%
Die \texttt{curry}-Transformation wurde unabhängig voneinander von den
Mathematikern \textsc{Moses Schönfinkel} und \textsc{Haskell Curry} entdeckt.  Im
englischsprachigen Raum heißt das Verb dazu darum  \textit{currify}, im deutschsprachigen Raum
\textit{schönfinkeln\index{schönfinkeln}}
oder \textit{curryfizieren\index{curryfizieren}}.
% Warum heißt dann die Funktion dann curry und nicht currify?

Die Schönfinkel-Transformation lässt sich auch umdrehen:\index{curry@\texttt{curry}}
%
\begin{lstlisting}
; Funktion zu einer Funktion mit zwei Parametern entstaffeln
(: uncurry ((%a -> (%b -> %c)) -> (%a %b -> %c)))
(define uncurry 
  (lambda (proc)
    (lambda (a b)
      ((proc a) b))))
\end{lstlisting}
%
Damit ist die Transformation ein \textit{Isomorphismus\index{Isomorphismus}}; es gilt
folgende Gleichung für Funktionen $p$ mit zwei Parametern:\label{sec:curry-isomorphismus}
%
\begin{center}
  \texttt{(uncurry (curry \(p\))) \(\equiv\) \(p\)}
\end{center}

\section*{Aufgaben}

\begin{aufgabe}
  Schreibe eine Funktion \texttt{any?} analog zu 
  \texttt{every?}, die dann \verb|#t| zurückgibt, wenn mindestens ein 
  Element der Liste das Prädikat erfüllt, sonst \verb|#f|.  Schreibe 
  zunächst eine Fassung nach dem Muster von \texttt{every?}.  Schreibe
  eine zweite Fassung, die einfach \texttt{every?} aufruft und selbst keine
  Rekursion benutzt.
\end{aufgabe}

\begin{aufgabe}
  Eine klassische Higher-Order-Funktion ist \texttt{list-map}, eine Funktion, die 
  eine Funktion und eine Liste akzeptiert.  \texttt{List-map}
  wendet diese Funktion auf alle Elemente der Liste an und produziert
  eine Liste der Rückgabewerte.

  \texttt{List-map} lässt sich beispielsweise folgendermaßen anwenden:
  % 
  \begin{lstlisting}
    (list-map even? (list 1 2 3 4 5))
    \evalsto{} #<list #f #t #f #t #f>
  \end{lstlisting}
  % 
  Programmiere \texttt{list-map}, indem sie die Signatur schreiben,
  das Gerüst der Funktion erstellen, Testfälle entwerfen und dann das
  Gerüst vervollständigen!

  \textbf{Hinweis:} \texttt{List-map} ist unter dem Namen \texttt{map} eingebaut.
\end{aufgabe}

\begin{aufgabe}
  Schreibe folgende Funktionen unter der  
  Verwendung von \texttt{filter}!
  \begin{itemize}
    \item Schreiben sie eine Funktion \texttt{evens}, die die ungeraden Zahlen aus 
      einer Liste entfernt,
  \item eine Funktion \texttt{count-zeroes}, die in einer Liste von
    Zahlen die Nullen zählt,
  \item und eine Funktion \texttt{multiples}, die eine Zahl $n$ und
    eine Liste von Zahlen akzeptiert, und eine Liste alle Vielfachen
    der Zahl $n$ liefert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmiere eine Funktion
  \texttt{filter-map}, die als Argumente eine Funktion \texttt{p} mit
  einem Argument sowie eine Liste \texttt{l} akzeptiert.
  \texttt{Filter-map} soll als Ergebnis die Liste der Rückgabewerte
  von \texttt{p} für diejenigen Elemente von \texttt{l} zurückgeben,
  für die \texttt{p} nicht \texttt{\#f} zurückgibt. Beispiel:

\begin{lstlisting}
(filter-map (lambda (x)
               (if (even? x)
                  (+ x 1)
                  #f))
            (list 1 2 5 17 24 13))
\evalsto{} #<list 3 25>
\end{lstlisting}
\end{aufgabe}

\begin{aufgabe}
  Verwende die Funktion \texttt{list-fold} um folgende 
  Funktionen zu schreiben:
  \begin{enumerate}
  \item Schreibe eine Funktion \texttt{list-map}, die eine Funktion auf jedes
    Element einer Liste anwendet.
  \item Schreibe eine Funktion \texttt{list-or}, die ein Prädikat auf alle
    Elemente einer Liste anwendet und die Resultate mit \texttt{or}
    verknüpft.
  \item Schreibe eine Funktion \texttt{count-predicate}, die ein Prädikat auf
    alle Elemente einer Liste anwendet und zählt, wie häufig \verb|#t|
    zurückgegeben wird.
  \item Schreibe eine Funktion \texttt{contains?}, die feststellt, ob ein
    Element in einer Liste enthalten ist.
  \item Schreibe eine Funktion \texttt{remove-duplicates}, die alle doppelten
    Elemente aus einer Liste filtert.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Fußballreporter zitieren gern obskure Fakten über
  vergangene Spiele, wenn sie zum Spielverlauf wenig zu sagen haben.

  Hier ein Beispiel:
  % 
  \begin{quote}
    "<In der Saison 2009/2010 gab es ja immerhin vier Spieltage, an
    denen die größte Tordifferenz kleiner als 3 war.">
  \end{quote}
  %
\begin{enumerate}
\item Stelle dem Fußballreporter Hilfsfunktionen zur Verfügung,
  die ihm erlauben, eine Antwort auf solch eine Frage zu
  finden:
  %
  \begin{quote}
    \emph{An wie vielen Spieltagen der Saison 2009/2010 war die größte
    Tordifferenz kleiner als 3?}
  \end{quote}
  %
  Schreibe mit Hilfe dieser Funktionen einen Ausdruck, der
  testet, ob die am Anfang dieser Aufgabe zitierte Aussage über die
  Tordifferenzen in der Saison 2009/2010 stimmt!

  \begin{enumerate}
  \item Schreibe eine Funktion, die aus einer Liste die Dubletten
    entfernt.  Diese Funktion akzeptiert eine Liste sowie eine
    Funktion, die zwei Elemente der Liste akzeptiert und
    zurückliefert, ob diese gleich sind.  (Also zum Beispiel
    \texttt{=} bei Listen von Zahlen.)  Sie liefert dann eine Liste,
    in der jedes Element "<nur einmal vorkommt">, also kein anderes,
    das dazu gleich ist.
  \item Schreibe eine Funktion, die aus der Liste aller Spiele
    eine Liste aller Spielplannummern extrahiert.
  \item Schreibe eine Funktion, die aus der Liste aller Spiele
    eine Liste von Listen aller Spiele macht~-- so dass in jeder
    Teilliste alle Spiele eines Spieltags zusammengefasst sind.
  \item Schreibe eine Funktion, welche die Tordifferenz eines
    Spiels zurückliefert.
  \item Schreibe eine Funktion, welche das maximale Element einer
    Liste berechnet.  Die Funktion sollte neben der Liste eine
    Funktion akzeptieren, die berechnet, ob ein Element "<kleiner oder
    gleich"> einem anderen ist.
  \item Schreibe schließlich einen Ausdruck, der die Anzahl der
    Spieltage der Saison 2009/2010 liefert, bei denen die größte
    Tordifferenz kleiner als 3 war.
  \end{enumerate}

  \item Schreibe Ausdrücke, die folgende Fragen beantworten~--
  entwickele dazu, falls nötig, weitere Hilfsfunktionen:
  \begin{itemize}
    \item An welchem Spieltag gab es die meisten Heimsiege?
    \item An welchem Spieltag fielen die meisten Tore?
    \item Gab es mehr Siege für die Heimmanschaften an ungeraden Spieltagen als an
      geraden?
    \end{itemize}
    
  \item Finde eine besonders
    kreativ-obskure Frage und schreibe den Ausdruck, der sie
    beantwortet.
\end{enumerate} 

\end{aufgabe}

\begin{aufgabe}
  \texttt{List-fold} sammelt die Elemente von hinten nach vorn bzw.
  von rechts nach links auf, entsprechend der "<natürlichen">
  Rekursionsstruktur über Listen.  Das gleiche Spiel lässt sich auch in
  der anderen Richtung durchführen.  Heraus kommt eine Funktion
  \texttt{list-fold-left}, die folgende Gleichung (in
  Infix-Schreibweise) erfüllt:
  % 
  \begin{displaymath}
    \texttt{(list-fold-left}~u~\odot~(a_1~\ldots~a_n)\texttt{)}
    = (\ldots((u\odot a_1)\odot a_2)\ldots\odot a_n)
  \end{displaymath}
  % 
  Programmiere \texttt{list-fold-left}!
\end{aufgabe}


\begin{aufgabe}
  Schreibe ein Programm, das Berechnungen
  mit unendlichen Werten durchführen kann:
  
  \begin{enumerate}
  \item Definiere den gemischten Typ \texttt{number*}, der den
    Datentyp \texttt{number} um $\infty$ (\texttt{infty}) und $- \infty$
    (\texttt{-infty}) erweitert.
  \item Definiere auf der Menge \texttt{number*} die
    Rechenoperationen $+$, $-$, $*$, und $/$.  Geben Sie den Funktionen
    die Namen \texttt{plus*}, \texttt{minus*}, \texttt{mult*} und
    \texttt{div*}.
  \item Definiere $\leq$, also eine Funktion mit dem
    Namen \texttt{<=*}, die die Ordnung auf \texttt{number*} darstellt.
  \item Definiere die Funktionen \texttt{list-max*} und
    \texttt{list-min*}, die das Maximum bzw. das Minimum einer Liste 
    aus \texttt{numbers*} berechnet!  Verwende hierzu die Funktion \texttt{list-fold}.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{lstlisting}
(define x 2)          ;  --> zwei
(define y -1)         ;  --> minuseins
(define z -3)         ;  --> minusdrei

(define f 
  (lambda (x z)
    (+ (* x x) z y)))

(f 4 -2)
\end{lstlisting}
  %
  Benenne die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um, und zwar \verb|x| in \verb|zwei|, \verb|y| in
  \verb|minuseins| und \verb|z| in \verb|minusdrei|. Achte bei
  der Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \verb"f" um.

  Nachdem Du die Umbenennung durchgeführt hast, welches Ergebnis liefert
  der Ausdruck \verb"(f 4 -2)"? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{lstlisting}
(define x 2)                    ; --> zwei
(define y 4)                    ; --> vier

(define z                       ; --> f
  (lambda (x y z)
    (+ x (z y))))

(z y x (lambda (z) (+ x z)))
\end{lstlisting}
%
  Benenne die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um. Der neue Name der Variable steht als Kommentar im
  Programm hinter dem Pfeil (\verb"-->").  Achte bei der
  Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \verb"z" um.

  Berechne, nachdem Du die Umbenennung durchgeführt haben, von
  Hand mit dem Substitutionsmodell \verb"(z y x"
  \verb"(lambda (z) (+ x z))))" und halte die Zwischenschritte
  fest.

\end{aufgabe}

\begin{aufgabe}
  Betrachte folgendes Programm:

\begin{lstlisting}
(define x 1)
(define y 3)
(define z 5)

(define f
  (lambda (x)   
     ((lambda (y)
        ((lambda (z)
           (+ z (* x y)))
         (+ x z)))
      (+ x y))))

(f y)
\end{lstlisting}

  Benenne hier alle lokalen Variablen, die innerhalb der Funktion
  \verb"f" gebunden werden, um. Verändere nicht den Namen der
  Variablen \verb"x", \verb"y" und \verb"z" aus den ersten drei Zeilen
  des Programms.

  Nachdem Du die Umbenennung durchgeführt haben, welches Ergebnis liefert
  der Ausdruck \verb"(f y)"? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.

  \noindent \emph{Hinweis:} In diesen Aufgaben findest keine
  Kommentare und Signaturen zu den Funktionen. Hier kannst Du an einem
  Beispiel sehen, dass es sehr wichtig ist, diese Informationen
  anderen Programmierern immer zur Verfügung zu stellen. Denn es kann
  auch bei kleinen Programmen schwer sein, die Funktionsweise der
  einzelnen Funktionen ohne Kommentare zu verstehen.
\end{aufgabe}

\begin{aufgabe}
  Funktionen können nicht nur als Argumente an
  andere Funktionen übergeben, sondern auch als Ergebnisse
  zurückgeliefert werden. Dies soll in dieser Aufgabe genutzt werden,
  um ein einfaches Telefonbuch zu implementieren: Ein Telefonbuch ist
  als Funktion repräsentiert, die den Namen einer Person akzeptiert
  und die Telefonnummer der Person zurückliefert. Falls die Person
  nicht im Telefonbuch verzeichnet ist, soll \verb|#f| zurückgeliefert
  werden.

  \begin{enumerate}
  \item Definiere zunächst eine Signatur
    \verb"phonebook-result" für das Ergebnis des Nachschlagens in einem
    Telefonbuch. Das Ergebnis ist entweder die Telefonnummer oder
    \verb|#f|. Die Telefonnummern sind Zeichenketten.
    Die Signatur des Telefonbuchs ist  \verb"string -> phonebook-result".
  \item Definiere einen Wert \verb"empty-phonebook", der das leere
    Telefonbuch repräsentiert.
  \item Definiere eine Funktion namens
    \verb"add-to-phonebook", welche ein Telefonbuch, einen Namen
    und eine Telefonnummer erwartet und das um den neuen Eintrag
    erweiterte
    Telefonbuch zurückliefert.
  \item Schreibe eine Funktion namens \verb"lookup-in-phonebook",
    welche ein Telefonbuch und einen Namen einer Person erwartet und die
    Nummer der Person im Telefonbuch nachschlägt und zurückliefert.
    Beispiele:
    \begin{itemize}
    \item \verb|(lookup-in-phonebook empty-phonebook "Hans")| liefert
      \verb|#f|.
    \item \verb|(lookup-in-phonebook| \\
      \verb|    (add-to-phonebook empty-phonebook "Hans" "754829")|\\
      \verb|    "Hans")| \\
      liefert \verb|"754829"|.
    \item \verb|(lookup-in-phonebook|\\
      \verb|    (add-to-phonebook empty-phonebook "Hans" "754829")|\\
      \verb|    "Lea")|\\
      liefert \verb|#f|.
    \end{itemize}
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Ein Polynom ist eine Funktion von $\mathbb{R}$ nach $\mathbb{R}$ und
  hat folgende Form:
  \begin{displaymath}
    p(x) = a_0 +
    a_1 \cdot x + a_2 \cdot x^2 + \ldots + a_n \cdot x^n    
  \end{displaymath}
  %
  Ein Polynom wird also eindeutig durch die Koeffizienten $a_0$ bis
  $a_n$ bestimmt.

  \begin{enumerate}
   \item Schreibe die Datendefinition für Polynome.
   \item Programmiere eine Funktion \texttt{polynomial+}, die
     zwei Polynome addiert.  Schreibe ggf.\ zutreffende Eigenschaften auf
     und überprüfe diese!
     
   \item Programmiere eine Funktion \texttt{polynomial*}, die zwei Polynome 
     multipliziert. 
     Beispielsweise werden die Polynome $a_0+a_1 x$ und $b_0+b_1 x$ nach folgendem Schema multipliziert:
     \begin{eqnarray*}
     & &a_0 \cdot (b_0+b_1x) \\
     &+&a_1 x \cdot (b_0+b_1 x) \\ 
     &=&a_0b_0+a_0b_1 x + a_1b_0x + a_1b_1x^2
     \end{eqnarray*}	
     Schreibe ggf.\ zutreffende Eigenschaften auf und überprüfe diese!
   \item Schreibe eine Funktion \texttt{polynomial-function}, die
     ein Polynom akzeptiert und eine Funktion liefert, die ein Polynom
     an einer bestimmten Stelle auswertet, also gerade der Funktion
     $p$ aus der Definition entspricht. 
   \item Die Ableitung eines Polynoms $p$ wie oben ist bekanntlich durch
     \begin{displaymath}
       p'(x) = a_1 + 2\cdot a_2 \cdot x + 3\cdot a_3\cdot x^2 + \ldots
       + n \cdot a_n \cdot x^{n-1}
     \end{displaymath}
     gegeben. Schreibe die Funktion
     \texttt{polynomial-derivative}, die von einem gegebenen Polynom das abgeleitete Polynom
     berechnet.
   \item Das Newton-Verfahren dient zur nährungsweisen
     Berechnung von Nullstellen. Für ein gegebenen Startwert nähert sich die
     Iteration 
     \begin{displaymath}
       x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
     \end{displaymath}
     immer näher an eine Nullstelle an.
     Programmiere das Newton-Verfahren!

     Hinweis: Die Lösung soll gut genug sein, wenn der Funktionswert nahe
     bei 0 liegt, also kleiner als eine Toleranz ist. 
     Da das
     Newton-Verfahren nicht immer eine Lösung liefert, programmiere
     Deine Funktion so, dass sie nach einer gewissen Anzahl von Schritten
     automatisch abbricht und \verb|#f| zurück gibt.
 \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Listen lassen sich nach verschiedenen Kriterien
  sortieren: zum Beispiel aufsteigend, absteigend, oder abhängig von
  einem Feld der Elemente.  So kann eine Liste von Fußballspielen nach
  der Gesamtanzahl der Tore, der Anzahl der Tore des Heimteams oder
  der Anzahl der Tore des Gästeteams oder der Anzahl der Tore des
  gewinnenden Teams sortiert werden.  Die genaue Anordnung wird durch
  eine Operation festgelegt, die bestimmt, ob ein Elemente vor einem anderen
  stehen soll.

\begin{enumerate}
\item Schreibe eine Funktion, die eine Liste nach einem beliebigen
  Kriterium sortiert.  Die Funktion sollte folgende Signatur haben:

\begin{lstlisting}
(: list-sort ((%a %a -> boolean) (list-of %a) -> (list-of %a)))
\end{lstlisting}

  Das erste Argument ist eine Funktion, die eine \textit{Halbordnung}
  realisiert, also zwei Elemente vergleicht, und \verb|#t|
  zurückliefert, falls sie schon in der richtigen Reihenfolge sind und
  \verb|#f|, falls nicht.  Zum Beispiel können \verb|<=| oder \verb|>=|
  für das Sortieren von Listen von Zahlen verwendet werden.
\item Benutze diese Funktion, um eine Liste von
  Fußballspielen nach den folgenden Kriterien zu sortieren:
  \begin{itemize}
  \item Gesamtanzahl der Tore,
  \item Anzahl der Tore des Heimteams,
  \item Anzahl der Tore des Gästeteams oder
  \item Anzahl der Tore des
    gewinnenden Teams
  \end{itemize}
\end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Folgen mit potentiell unendlicher Länge lassen sich als
  zusammengesetzte Daten mit zwei Komponenten repräsentieren: Dabei
  ist die erste Komponente das erste Element der Folge und die zweite
  eine Funktion ohne Parameter, die, wenn sie angewendet wird, eine Folge mit
  den restlichen Elementen ohne das erste liefert.
  Solche unendlichen Folgen heißen \textit{Streams}.
  Schreibe Daten- und Record-Definition für Streams!

  Hier ist eine Funktion, die einen Stream aus natürlichen Zahlen,
  angefangen bei einer Zahl $n$, liefert:
  % 
  \begin{lstlisting}
; Stream mit Zahlen ab n erzeugen
(: from (natural -> stream))
(define from
  (lambda (n)
    (make-stream n
                 (lambda () (from (+ n 1))))))
  \end{lstlisting}
  % 
  (Dabei ist angenommen, dass der Konstruktor der Record-Definition
  \texttt{make-stream} heißt.)
  Zur Betrachtung von Streams ist folgende Funktion nützlich, welche
  die ersten $n$ Elemente eines Streams als Liste extrahiert:
  % 
  \begin{lstlisting}
; erste Elemente eines Streams in eine Liste extrahieren
(: stream-take (natural stream -> (list-of %a)))
(define stream-take
  (lambda (n stream)
    (if (= n 0)
        empty
        (cons (stream-first stream)
                   (stream-take (- n 1)
                                ((stream-rest-proc stream)))))))
   \end{lstlisting}
   % 
   (Dabei ist angenommen, dass die Selektoren für Streams
   \texttt{stream-first} und \texttt{stream"=rest"=proc} heißen.)
   \texttt{Stream-take} lässt sich z.B.\ auf das Ergebnis von
   \texttt{from} anwenden:
   % 
   \begin{lstlisting}
(stream-take 17 (from 4))
\evalsto{} #<list 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20>
   \end{lstlisting}
   % 
   Programmiere einige intellektuelle Herausforderungen mit Streams!
   \begin{enumerate}
   \item Programmiere eine Funktion \texttt{stream-drop}, die eine
     natürliche Zahl $n$ und einen Stream akzeptiert, und einen neuen
     Stream liefert, der aus dem alten durch Weglassen der ersten $n$
     Elemente entsteht:
     \begin{lstlisting}
(stream-take 17 (stream-drop 3 (from 4)))
\evalsto{} #<list 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23>
     \end{lstlisting}
   \item Programmiere eine Funktion \texttt{stream-filter} analog zu
     \texttt{filter}:
     % 
     \begin{lstlisting}
(stream-take 10 (stream-filter odd? (from 1)))
\evalsto{} #<list 1 3 5 7 9 11 13 15 17 19>
     \end{lstlisting}
   \item Programmiere eine Funktion \texttt{drop-multiples}, die 
     eine Zahl $n$ und einen Stream von Zahlen $s$ akzeptiert.
     \texttt{Drop-multiples} soll einen Stream liefern, in dem
     gegenüber $s$  alle Vielfachen von $n$ entfernt wurden:
     % 
     \begin{lstlisting}
(stream-take 10 (drop-multiples 3 (from 1)))
\evalsto{} #<list 1 2 4 5 7 8 10 11 13 14>
     \end{lstlisting}
   \item Schreibe eine Funktion \texttt{sieve}, die aus einem Stream
     von Zahlen all diejenigen Zahlen entfernt, die Vielfache von
     Vorgängern im Stream sind:
     \begin{lstlisting}
(stream-take 10 (sieve (from 2)))
\evalsto{} #<list 2 3 5 7 11 13 17 19 23 29>
     \end{lstlisting}
     Um was für Zahlen handelt es sich in dem Beispielaufruf und
     warum?
   \item Schreibe eine Funktion \texttt{powers}, die für eine Zahl
     $n$ einen Stream ihrer Potenzen liefert:
     % 
     \begin{lstlisting}
(stream-take 10 (powers 2))
\evalsto{} #<list 2 4 8 16 32 64 128 256 512 1024>
     \end{lstlisting}
   \item Schreibe eine Funktion \texttt{stream-map} analog zu
     \texttt{list-map}:
     \begin{lstlisting}
(stream-take 10 (stream-map (lambda (x) (+ x 1)) (from 1)))
\evalsto{} #<list 2 3 4 5 6 7 8 9 10 11>
     \end{lstlisting}
   \item Schreibe eine Funktion \texttt{merge}, die zwei
     aufsteigende Streams von Zahlen zu einem aufsteigenden Stream
     der Elemente beider Streams vereinigt:
     \begin{lstlisting}
(stream-take 10 (merge (powers 2) (powers 3)))
\evalsto{} #<list 2 3 4 8 9 16 27 32 64 81>
     \end{lstlisting}
   \item Schreibe eine Definition für einen Stream aufsteigend
     sortierter Potenzen von Primzahlen:
     \begin{lstlisting}
(stream-take 10 prime-powers)
\evalsto{} #<list 2 3 4 5 7 8 9 11 13 16>
     \end{lstlisting}
     Definiere dazu zunächst einen Stream aus Streams von Potenzen
     % 
     \begin{lstlisting}
(define prime-powers-stream (stream-map powers (sieve (from 2))))
     \end{lstlisting}
     % 
     Definiere eine Funktion \texttt{merge-streams}, welche
     diesen Stream akzeptiert und die Elemente der Streams
     aus \texttt{prime-powers-stream} mit Hilfe von \texttt{merge}
     aufsteigend sortiert.
   \end{enumerate}
 \end{aufgabe}

 \begin{aufgabe}
  Betrachte folgende mysteriöse Funktion:
\begin{lstlisting}
(: // ((%a -> (%b -> %b)) (list-of %a) -> (%b -> %b)))

(define //
  (lambda (proc lis)
    (cond
      ((empty? lis)
       (lambda (y)
         y))
      ((cons? lis)
       (lambda (y)
         ((proc (first lis))
          ((// proc (rest lis))
           y)))))))
\end{lstlisting}
  % 
  \textbf{Hinweise:} Beachte die Signaturen! In mehreren
  Teilaufgaben gibt es Gelegenheiten, \texttt{curry} bzw.\
  \texttt{uncurry} zu benutzen.

  \begin{itemize}
  \item Vergleiche die Funktion mit \texttt{list-fold} und
    beschreibe, wie \texttt{//} und \texttt{list-fold} zueinander
    in Beziehung stehen.  Schreibe, falls möglich, eine
    Definition von \texttt{//}, die \texttt{list-fold} benutzt und
    umgekehrt.
  \item Schreibe mit Hilfe von \texttt{//} eine Funktion
    \texttt{list-sum}, welche die Elemente einer Liste addiert.
  \item Schreibe eine Funktion \texttt{insert}, die eine reelle
    Zahl $n$ konsumiert und eine Funktion zurückliefert, die eine
    aufsteigend sortierte Liste von reellen Zahlen konsumiert und
    eine Liste zurückliefert, in der $n$ an die entsprechende
    Stelle der Liste einsortiert wurde.
  \item Schreibe mit Hilfe von \texttt{//} eine Funktion, die
    eine Liste von reellen Zahlen aufsteigend sortiert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmiere eine Version von
  \texttt{list-fold-left}, nämlich die Funktion
  \texttt{list-fold-left-bonus}, die \texttt{list-fold} benutzt aber
  selbst keine Rekursion enthält und auch keine rekursiven
  Hilfsfunktionen aufruft.
\end{aufgabe}


\begin{aufgabe}
  Betrachte folgendes mysteriöse Programm:
  % 
  \begin{lstlisting}
(define y
  (lambda (f)
    ((lambda (x)
       (f (lambda (z) ((x x) z))))
     (lambda (x)
       (f (lambda (z) ((x x) z)))))))

(define m
  (y
   (lambda (f)
     (lambda (x)
       (if (= x 1)
           1
           (* x (f (- x 1))))))))
   \end{lstlisting}
  %
   Was macht \texttt{m}?  \texttt{Y} wird auch
   \textit{Fixpunktkombinator} genannt.  Erkläre einem Anfänger, der
   gerade drei Informatik-Stunden hinter sich hat, diesen Begriff~--
   außerdem was
   \texttt{y} bewirkt und warum.
 \end{aufgabe}

\begin{aufgabe}
  Beweise, dass für Funktionen $p_1$ mit einem Parameter, die
  einparametrige Funktionen zurückgeben, und Funktionen $p_2$ mit zwei
  Parametern gilt:
  %
  \begin{center}
    \texttt{(curry (uncurry $p_1$))} $\equiv$ $p_1$\\
    \texttt{(uncurry (curry $p_2$))} $\equiv$ $p_2$
  \end{center}
 \end{aufgabe}

\begin{aufgabe}
  Eine Funktion $f$ ist idempotent, wenn gilt:

  \begin{center}
    \texttt{(compose $f$ $f$) $\equiv$ $f$}
  \end{center}

  Zeige, dass folgende Funktion idempotent ist:

  \begin{lstlisting}
    (define abs
      (lambda (x)
         (if (negative? x)
             (- x)
             x)))  \end{lstlisting}

  Welche anderen idempotente Funktionen kennst Du?
\end{aufgabe}

\begin{aufgabe}
  Zwei Funktionen $f$ und $g$ sind invers
  zueinander, wenn gilt:

  \begin{center}
    \texttt{(compose $f$ $g$) $\equiv$ id} und \texttt{(compose $g$ $f$) $\equiv$ id}
  \end{center}

  Zeige, dass \texttt{curry} und \texttt{uncurry} invers zueinander sind.
\end{aufgabe}

\begin{aufgabe}
  Betrachte folgende Funktion:

  \begin{lstlisting}
(define mystery
  (lambda (l)
    (list-fold empty append
               (map (lambda (x)
                      (cons x empty))
                    l))))
  \end{lstlisting}

  \begin{enumerate}
  \item Was macht \texttt{mystery}?

  \item Schreibe eine Signatur für \texttt{mystery}.

  \item Beweise, dass \texttt{mystery} tatsächlich das macht, was
    Sie vermuten.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Beweise: $\forall n \in \mathbb{N}$ gilt
  \texttt{(repeat $n$ id) $=$ id}, wobei \texttt{id} die
  Identitätsfunktion ist.
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
