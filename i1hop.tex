% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Higher-Order-Programmierung}
\label{cha:higher-order}

Der renommierte Informatiker Paul Hudak wurde einst gefragt, was die
drei wichtigsten Dinge beim Programmieren seien.  Er antwortete:
"<Abstraktion, Abstraktion, Abstraktion">.  Entsprechend ist das
Mantra~\ref{mantra:abstraktion} auf Seite~\pageref{mantra:abstraktion}
auch eins der wichtigsten:

\mantraabstraktion*

\noindent In diesem Kapitel werden wir dieses Mantra konsequent anwenden.  Dabei
kommt oft eine besondere Art Funktion heraus: Funktionen, die andere
Funktionen als Eingabe akzeptieren oder als Ausgabe liefern.  Solche
Funktionen heißen auch \textit{Funktionen höherer
  Ordnung}\index{Funktion!höherer Ordnung} oder
\textit{Higher-Order-Funktion}.\index{Higher-Order-Funktion}  Um die
resultierende Art der Programmierung~-- die
\textit{Higher-Order-Programmierung}~-- geht es in diesem Kapitel.

\section{Fußball-Fakten ermitteln}

Eine nahezu unerschöpfliche Quelle für Diskussionen stellen die
Fußballergebnisse dar.  Hier stellen sich so bedeutsame Fragen wie:
\begin{itemize}
\item Wie hat diese Saison Bayern München gegen 1.~FC Kaiserslautern
  auswärts gespielt?\footnote{Wir wissen, das ist schon eine Weile her.}
\item Wie viele Tore sind in dieser Saison gefallen?
\item Welche Mannschaft ist abstiegsgefährdet?
\end{itemize}
%
All diese Informationen speisen sich aus Ergebnissen der Spiele einer
Saison.  Ein Spiel können wir folgendermaßen charakterisieren:
%
\begin{lstlisting}
; Ein Spiel hat folgende Eigenschaften:
; - Spieltag
; - Gastgeber-Team
; - Gastgeber-Tore
; - Gast-Team
; - Gast-Tore
\end{lstlisting}
%
Es handelt sich sichtlich um zusammengesetzte Daten.  Wir müssen uns
überlegen, welche Signaturen zu den einzelnen Bestandteilen passen.
Spieltag und Tore sind allesamt natürliche Zahlen.  Ein Team können
wir durch seinen Namen als Zeichenkette repräsentieren.   Das ergibt
folgende Record-Definition:
%$
\begin{lstlisting}
(define-record-functions game
  make-game game?
  (game-matchday natural)
  (game-home-team string)
  (game-home-goals natural)
  (game-guest-team string)
  (game-guest-goals natural))
\end{lstlisting}
%
Es folgen hier beispielhaft die Ergebnisse des ersten Spieltags der Bundesliga-Saison
2009/2010:
\begin{lstlisting}
(define game1 (make-game 1 "Wolfsburg" 2 "Stuttgart" 0))
(define game2 (make-game 1 "Mainz" 2 "Bayer 04" 2))
(define game3 (make-game 1 "Hertha" 1 "Hannover" 0))
(define game4 (make-game 1 "Bremen" 2 "Frankfurt" 3))
(define game5 (make-game 1 "Nürnberg" 1 "Schalke" 2))
(define game6 (make-game 1 "Dortmund" 1 "1. FC Köln" 0))
(define game7 (make-game 1 "Hoffenheim" 1 "Bayern" 1))
(define game8 (make-game 1 "Bochum" 3 "Gladbach" 3))
(define game9 (make-game 1 "Freiburg" 1 "Hamburg" 1))

(define day1
  (list game1 game2 game3 game4 game5 game6 game7 game8 game9))
\end{lstlisting}
%
% FIXME: actual link
Die kompletten Ergebnisse dieser Saison lassen sich unter dem Namen
\texttt{soccer.rkt} von der Webseite des Buchs~--
\url{https://www.deinprogramm.de/}~-- herunterladen.

Eine recht einfache Frage ist die Bestimmung der Punktzahl, welche die
Gastgebermannschaft in einem bestimmten Spiel erzielt hat.  Die
Punktzahl ist zwar eine natürliche Zahl, es gibt aber nur drei
Möglichkeiten: 0, 1 und 3.  Wir können also eine präzisere Signatur
als \lstinline{points} definieren:
%
\begin{lstlisting}
; Punktzahl in Spiel
(define points
  (signature (enum 0 1 3)))
\end{lstlisting}
%
Unsere Funktion für die Bestimmung der Punktzahl hat Kurzbeschreibung,
Signatur, Tests und Gerüst wie folgt:\index{home-points@\texttt{home-points}}
%
\begin{lstlisting}
; Punktzahl für Gastgeber-Team berechnen
(: home-points (game -> points))

(check-expect (home-points game1) 3)
(check-expect (home-points game2) 1)
(check-expect (home-points game3) 3)
(check-expect (home-points game4) 0)

(define home-points
  (lambda (game)
    ...))
\end{lstlisting}
% 
Entsprechend der Signatur der Ausgabe fallen die Spiele in drei
unterschiedliche Klassen, das heißt wir brauchen eine Verzweigung mit
drei Zweigen entsprechend den drei möglichen Punktzahlen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (cond
      (... 3)
      (... 0)
      (... 1))))
\end{lstlisting}
%
Die Bedingungen der drei Zweige kommen aus den Fußballregeln~-- wir
müssen die Tore von Heim- und Gastmannschaft vergleichen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (define goals1 )
    (define goals2 )
    (cond
      ((> (game-home-goals game) (game-guest-goals game)) 3)
      ((< (game-home-goals game) (game-guest-goals game)) 0)
      ((= (game-home-goals game) (game-guest-goals game)) 1))))
\end{lstlisting}
%
Das funktioniert schon korrekt, ist aber noch unelegant.
Das \lstinline{(game-home-goals game)} ist dreimal wiederholt~-- wir
sollten eine lokale Definition einführen, damit es nur einmal
dasteht.  Ebenso für den Aufruf von \lstinline{game-guest-goals}.  Das
sieht dann so aus:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (define goals1 (game-home-goals game))
    (define goals2 (game-guest-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Du könntest berechtigterweise fragen, warum die lokalen Variablen
\lstinline{goals1} und \lstinline{goals2} heißen, und nicht
\lstinline{home-goals} und \lstinline{guest-goals} heißen.  Das wird
bei der nächsten Funktion (hoffentlich) klar, welche die Punkte
ausrechnet, die dem Gästeteam zustehen:
%
\begin{lstlisting}
; Punktzahl für Gast-Team berechnen
(: guest-points (game -> points))

(define guest-points
  (lambda (game)
    (define goals1 (game-guest-goals game))
    (define goals2 (game-home-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Diese beiden Funktionen sind weitgehend identisch, der einzige
Unterschied ist die Definition der lokalen Variablen
\lstinline{goals1} und \lstinline{goals2}. Eine solche Duplizierung
von Code ist immer schlecht, vor allem, wenn sich etwas
ändert. Theoretisch könnte der Fußballbund die Regeln für die Vergabe
von Punkten ändern sollte, und dann müssten wir beide Funktionen in
gleicher Weise anpassen.  Die Lösung für das Problem zeigt sich
dadurch, dass wir aus dem gemeinsamen Code der beiden Funktionen
eine neue Funktion machen, entsprechend dem Abstraktions-Mantra:

\mantraabstraktion*

\noindent Um zu abstrahieren, kopieren wir eine der beiden Funktionsdefinitionen und
geben ihr einen neuen Namen, in diesem Fall \lstinline{compute-points}:
%
\begin{lstlisting}
(define compute-points
  (lambda (game)
    (define goals1 (game-guest-goals game))
    (define goals2 (game-home-goals game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Nun identifizieren wir in der kopierten Funktion die Stellen, die sich
bei den beiden ursprünglichen Funktionen unterscheiden und ersetzen
diese Stellen durch neue Namen.  Hier sind das gerade
\lstinline{game-guest-goals} und \lstinline{game-home-goals}, wir
ersetzen sie durch die Namen \lstinline{get-goals-1} und
\lstinline{get-goals-2}:
%
\begin{lstlisting}
(define compute-points
  (lambda (game)
    (define goals1 (get-goals-1 game))
    (define goals2 (get-goals-2 game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Diese neuen Variablen sind noch ungebunden, wir müssen sie deshalb
noch im \lstinline{lambda} unterbringen:
%
\begin{lstlisting}
(define compute-points
  (lambda (get-goals-1 get-goals-2 game)
    (define goals1 (get-goals-1 game))
    (define goals2 (get-goals-2 game))
    (cond
      ((> goals1 goals2) 3)
      ((< goals1 goals2) 0)
      ((= goals1 goals2) 1))))
\end{lstlisting}
%
Damit können wir die bisherigen Definitionen von
\lstinline{home-points} und \lstinline{guest-points} ersetzen durch
die folgenden:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    (compute-points game-home-goals game-guest-goals game)))

(define guest-points
  (lambda (game)
    (compute-points game-guest-goals game-home-goals game)))
\end{lstlisting}
%
Diese neuen Definitionen lassen die Gemeinsamkeiten und Unterschiede
beider Funktionen klar erkennen und vermeiden die doppelte Definition
der Fußball-Punkteregeln.

\textbf{Wichtig:} Diese beiden Definitionen müssen \emph{nach} der
Definition von \lstinline{compute-points} stehen, da davor
\lstinline{compute-points} noch nicht definiert ist.

Der neuen Funktion fehlt noch eine Signatur.  Die Funktion akzeptiert
drei Argumente.  Das letzte hat die Signatur \lstinline{game}.  Die
ersten beiden werden aus den Funktionen \lstinline{game-home-goals}
und \lstinline{game-guest-goals} bestückt, die jeweils die Signatur
\lstinline{(game -> natural)} haben.  Daraus können wir die Signatur
für \lstinline{compute-points} zusammensetzen:
%
\begin{lstlisting}
(: compute-points ((game -> natural) (game -> natural) game -> points))
\end{lstlisting}
%
In der Signatur tauchen mehrere Pfeile auf, weil die Funktion
\lstinline{compute-points} ihrerseits zwei Funktionen als Argumente
akzeptiert.  Solche Funktionen mit mehreren Pfeilen in der Signatur
heißen \textit{Funktionen höherer Ordnung\index{Funktion!höherer
    Ordnung}} oder
\textit{Higher-Order-Funktionen\index{Higher-Order-Funktion}}.

Die Abstraktion bei der Entwicklung von \lstinline{compute-points}
hätten wir auch etwas anders anstellen können: Wir haben bei
\lstinline{compute-points} die beiden Parameter
\lstinline{get-goals-1} und \lstinline{get-goals-2} zu dem schon
bestehenden \lstinline{lambda} hinzugefügt.  Wir können stattdessen
auch ein neues \lstinline{lambda} einfügen.  (Bei Definitionen, in
denen noch kein \lstinline{lambda} steht, müssten wir das sowieso.)
Das sieht dann so aus:
%
\begin{lstlisting}
(define make-compute-points
  (lambda (get-goals-1 get-goals-2)
    (lambda (game)
      (define goals1 (get-goals-1 game))
      (define goals2 (get-goals-2 game))
      (cond
        ((> goals1 goals2) 3)
        ((< goals1 goals2) 0)
        ((= goals1 goals2) 1)))))
\end{lstlisting}
%
Die Signatur dieser Funktion unterscheidet sich leicht von der
Signatur von \lstinline{compute-points}.  Sie akzeptiert nicht mehr drei
Argumente sondern nur zwei, aber liefert dafür eine Funktion, die von
einem Spiel die Punkte liefert:
%
\begin{lstinline}
(: make-compute-points ((game -> natural) (game -> natural) 
                         -> (game -> points)))
\end{lstinline}
%
Auch mit dieser Funktion können wir alternative Definitionen von
\lstinline{make-compute-points} schreiben.  Auf den ersten Blick ist
das umständlich, wenn wir das genauso machen wie mit
\lstinline{compute-points}, da wir noch mehr Klammern brauchen:
%
\begin{lstlisting}
(define home-points
  (lambda (game)
    ((make-compute-points game-home-goals game-guest-goals) game)))

(define guest-points
  (lambda (game)
    ((make-compute-points game-guest-goals game-home-goals) game)))
\end{lstlisting}
%
Vielleicht fällt Dir aber das Muster auf, das diese beiden
Definitionen gemeinsam haben:
%
\begin{lstlisting}
(define f
  (lambda (x)
    (g x)))
\end{lstlisting}
%
Das heißt, wenn das Programm \lstinline{f} aufruft, ruft diese
Funktion direkt \lstinline{g} auf, mit der gleichen Eingabe:
\lstinline{f} und \lstinline{g} sind also äquivalent, und wir könnten
genauso gut schreiben:
%
\begin{lstlisting}
(define f g)
\end{lstlisting}
%
Das gleiche Prinzip können wir auch auf \lstinline{home-points} und
\lstinline{guest-points} anwenden:
%
\begin{lstlisting}
(define home-points
  (make-compute-points game-home-goals game-guest-goals))

(define guest-points
  (make-compute-points game-guest-goals game-home-goals))
\end{lstlisting}
%
Man kann auch schön an der Signatur von
\lstinline{make-compute-points} sehen, dass diese als Resultat eine
Funktion mit Signatur \lstinline{(game -> points)} liefert, das ist
gerade die gewünschte Signatur von \lstinline{home-points} und
\lstinline{guest-points}.

Vielleicht hast Du Dich über den Namen \lstinline{make-compute-points}
gewundert: Während die Funktion \lstinline{compute-points} direkt eine Punktzahl
berechnet, macht \lstinline{make-compute-points} eine Funktion, welche
die Punktzahl berechnet: Darum der Präfix \lstinline{make-}.  Es
handelt sich also um eine Art "<Funktionsfabrik">.

\begin{aufgabeinline}
  Wir hätten das neue \lstinline{lambda} auch unterhalb des alten
  \lstinline{lambda} einfügen können statt oberhalb.  Welche Signatur
  hätte die Funktion \lstinline{make-compute-points} dann?  Warum ist
  das keine so gute Idee?
\end{aufgabeinline}

Die Abstraktionstechnik, die wir für die Konstruktion von
\lstinline{compute-points} und \lstinline{make-compute-points}
verwendet haben, wenden wir in diesem Buch noch öfter an.  Sie
verdient deshalb eine eigene Konstruktionsanleitung:

\begin{konstruktionsanleitung}{Abstraktion}
  \label{ka:abstraktion}
  Wenn Du zwei Definitionen geschrieben hast, die inhaltlich verwandt
  sind und viele Ähnlichkeiten aufweisen, abstrahiere wie folgt:
  %
  \begin{enumerate}
  \item Kopiere eine der beiden Definitionen und gib ihr einen neuen
    Namen.
  \item Ersetze die Stellen, bei denen sich die beiden Definitionen
    unterscheiden, jeweils durch eine neue Variable.
  \item Füge die neuen Variablen als Parameter zum \lstinline{lambda}
    der Definition hinzu oder füge ein neues \lstinline{lambda} mit
    diesen Parametern ein.  Du musst gegebenenfalls rekursive Aufrufe
    der Funktion anpassen.
  \item Schreibe eine Signatur für die neue Funktion.
  \item Ersetze die beiden alten Definitionen durch Aufrufe der neuen
    Definition.
  \end{enumerate}
\end{konstruktionsanleitung}

\section{Higher-Order-Funktionen auf Listen}

Als nächstes wollen wir herausbekommen, welche Spiele einer Saison
unentschieden ausgingen.  Dazu ist zunächst eine Funktion notwendig,
die feststellt, ob \emph{ein} bestimmtes Spiel unentschieden war:
%
\begin{lstlisting}
; Ist Spiel unentschieden?
(: game-draw? (game -> boolean))

(define game-draw?
  (lambda (g)
    (= 1 (home-points g))))
\end{lstlisting}
%
Die Spiele der Saison liegen in der einer Liste, wir schreiben also eine
Funktion, die aus einer Liste von Spielen die
unentschiedenen herausholt.  Kurzbeschreibung, Signatur und Gerüst
sehen so aus:
%
\begin{lstlisting}

\end{lstlisting}
%
Die Definition folgt der Konstruktionsanleitung für Funktionen auf Listen.
Hier ist die Schablone:\index{drawn-games@\texttt{drawn-games}}
%
\begin{lstlisting}
; Unentschiedene Spiele rausfiltern
(: drawn-games ((list-of game) -> (list-of game)))

(check-expect (drawn-games day1) (list game2 game7 game8 game9))

(define drawn-games
  (lambda (list)
    ...))
\end{lstlisting}
%
Die Funktion hat eine Liste als Eingabe, es kommt also die
entsprechende Schablone zur Anwendung:
%
\begin{lstlisting}
(define drawn-games
  (lambda (list)
    (cond
      ((empty? list) ...)
      ((cons? list)
       ... (first list) ...
       ... (drawn-games (rest list)) ...))))
\end{lstlisting}
%
Der rekursive Aufruf liefert die unentschiedenen Spiele des Rests, wir
müssen also nur noch beim ersten Spiel entscheiden, ob es
unentschieden ausging:
%
\begin{lstlisting}
(define drawn-games
  (lambda (list)
    (cond
      ((empty? list) ...)
      ((cons? list)
       ... (game-draw? (first list)) ...
       ... (drawn-games (rest list)) ...))))
\end{lstlisting}
%
Die Funktion \lstinline{game-draw?} liefert einen booleschen Wert
liefert, den können wir eigentlich nur in eine binäre Verzweigung stecken:
%
\begin{lstlisting}
(define drawn-games
  (lambda (list)
    (cond
      ((empty? list) ...)
      ((cons? list)
       (if (game-draw? (first list))
           ...
           ...)
       ... (drawn-games (rest list)) ...))))
\end{lstlisting}
%
Abhängig davon, ob das Spiel unentschieden ist oder nicht, bringen wir
es im Ergebnis unter:
%
\begin{lstlisting}
(define drawn-games
  (lambda (list)
    (cond
      ((empty? list) empty)
      ((cons? list)
       (if (game-draw? (first list))
           (cons (first list) (drawn-games (rest list)))
           (drawn-games (rest list)))))))
\end{lstlisting}
%
Fertig!

Analog zu \lstinline{drawn-games} schreiben wir als nächstes eine
Funktion, die alle Spiele aus einer extrahiert, die die Heimmannschaft
gewonnen hat.  Dazu brauchen wir erst einmal eine Funktion analog zu
\lstinline{game-draw?}:
%
\begin{lstlisting}
; Hat die Heimmannschaft gewonnen?
(: home-won? (game -> boolean))

(check-expect (home-won? game1) #t)
(check-expect (home-won? game2) #f)
(check-expect (home-won? game4) #f)

(define home-won?
  (lambda (game)
    (= 3 (home-points game))))
\end{lstlisting}
%
Die Funktion \lstinline{home-won-games} entsteht genau analog zu
\lstinline{drawn-games}.  Am Ende kommt folgendes heraus:
%
\begin{lstlisting}
; Spiele herausfiltern, bei denen die Heimmannschaft gewann
(: home-won-games ((list-of game) -> (list-of game)))

(check-expect (home-won-games day1) (list game1 game3 game6))

(define home-won-games
  (lambda (list)
    (cond
      ((empty? list) empty)
      ((cons? list)
       (if (home-won? (first list))
           (cons (first list)
                 (home-won-games (rest list)))
           (home-won-games (rest list)))))))
\end{lstlisting}
%
Die beiden Funktionen \lstinline{drawn-games} und
\lstinline{home-won-games} sind bis auf den Namen fast identisch.  Der
einzige Unterschied ist, dass an der Stelle von \lstinline{game-draw?}
in der zweiten Funktion \lstinline{home-won?} steht.  Darüber können
wir nach Konstruktionsanleitung~\ref{ka:abstraktion} auf
Seite~\pageref{ka:astraktion} abstrahieren.  Dazu kopieren wir die
letzte Funktion und denken uns einen neuen Namen aus~-- da es in
beiden Fällen ums "<extrahieren"> geht, nehmen wir
\lstinline{extract-games}:
%
\begin{lstlisting}
(define extract-games
  (lambda (list)
    (cond
      ((empty? list) empty)
      ((cons? list)
       (if (home-won? (first list))
           (cons (first list)
                 (extract-games (rest list)))
                 (extract-games (rest list)))))))
\end{lstlisting}
%
Als nächstes müssen wir die Stelle, die sich bei beiden Definitionen
unterscheidet (\lstinline{game-draw?} beziehungsweise
\lstinline{home-won?}), durch eine neue Variable.  Die nennen wir
\lstinline{f?}:
%
\begin{lstlisting}
(define extract-games
  (lambda (list)
    (cond
      ((empty? list) empty)
      ((cons? list)
       (if (f? (first list))
           (cons (first list)
                 (extract-games (rest list)))
                 (extract-games (rest list)))))))
\end{lstlisting}
%
Als nächstes müssen wir die neue Variable als Parameter zum
\lstinline{lambda} hinzufügen.  Aufpassen: Die beiden rekursiven
Aufrufe müssen ebenfalls um den Parameter erweitert werden:
%
\begin{lstlisting}
(define extract-games
  (lambda (f? list)
    (cond
      ((empty? list) empty)
      ((cons? list)
       (if (f? (first list))
           (cons (first list)
                 (extract-games f? (rest list)))
                 (extract-games f? (rest list)))))))
\end{lstlisting}
%
(Es ist Geschmackssache, ober der neue Parameter vor oder hinter die
alten kommt.)

Die Funktionsdefinition ist damit fertig, aber wir müssen noch eine
Signatur schreiben.  Wir fangen mit der Signatur von
\lstinline{home-won-games} an und erweitern um den zusätzlichen
Parameter:
%
\begin{lstinline}
(: extract-games (... (list-of game) -> (list-of game)))
\end{lstinline}
%
Der zusätzliche Parameter ist \lstinline{f?}, den wir für
\lstinline{game-draw?} und \lstinline{home-won?} eingesetzt haben.
Diese beiden Funktionen haben die Signatur
\lstinline{(game -> boolean)}, das können wir also für die Ellipse
einsetzen:
%
\begin{lstinline}
(: extract-games ((game -> boolean) (list-of game) -> (list-of game)))
\end{lstinline}
%
Nun können wir Aufrufe der alten Funktionen durch Aufrufe der neuen
ersetzen.  Wir tun das, indem wir die Testfälle für
\lstinline{drawn-games} und \lstinline{home-won-games} anpassen:
%
\begin{lstlisting}
(check-expect (extract-games game-draw? day1) (list game2 game7 game8 game9))
(check-expect (extract-games home-won? day1) (list game1 game3 game6))
\end{lstlisting}
%
Fertig!

Vielleicht hast Du das Gefühl, das Muster der Funktion
\lstinline{extract-games} schon gesehen zu haben.  In der Tat sieht
die Funktion~\lstinline{live-dillos} in
Abschnitt~\ref{page:live-dillos} auf
Seite~\ref{page:live-dillos} ebenfalls den Funktionen
\lstinline{drawn-games} und \lstinline{home-won-games} sehr ähnlich.
Hier ist sie noch einmal zur Erinnerung:
%
\begin{lstlisting}
(: live-dillos ((list-of dillo) -> (list-of dillo)))

(define live-dillos
  (lambda (dillos)
    (cond
      ((empty? dillos) empty)
      ((cons? dillos)
       (if (dillo-alive? (first dillos))
           (cons (first dillos)
                 (live-dillos (rest dillos)))
           (live-dillos (rest dillos)))))))
\end{lstlisting}
%
Und tatsächlich~-- wenn wir \lstinline{dillos} in \lstinline{list}
umbenennen und den gleichen Abstraktionsprozess wie bei
\lstinline{drawn-games} und \lstinline{home-won-games} durchlaufen,
dann entsteht die identische Funktionsdefinition zu
\lstinline{extract-games}.  Allerdings gibt es dann immer noch einen
Unterschied~-- die Signaturen sind unterschiedlich.
Die Funktion \lstinline{extract-games} kann nur Listen von Spielen
verarbeiten, während \lstinline{live-dillos} eine Liste von
Gürteltieren akzeptiert.  Können auch darüber~-- einmal
\lstinline{game}, das andere Mal \lstinline{dillo}~-- abstrahieren?

Können wir! Dazu sollten wir die Funktion noch umbenennen, wir wählen
\lstinline{extract-list} statt \lstinline{extract-games}.  Vor allem
aber müssen wir die Signatur ändern, die bisher auf \lstinline{game}
abonniert ist.  Auf Signaturebene abstrahieren wir durch
Signaturvariablen und ersetzen einfach mal probehalber jedes
\lstinline{game} durch \lstinline{%a}:
%
\begin{lstlisting}
(: extract-list ((%a -> boolean) (list-of %a) -> (list-of %a)))
\end{lstlisting}
%
Diese Funktion können wir nun versuchen zu verstehen: Sie akzeptiert
eine Liste von \lstinline{%a}s und eine Funktion, die \lstinline{%a}s
akzeptiert.  Man kann daran fast schon sehen, was die Funktion macht:
Das einzige, was sie mit der Funktion anfangen kann, ist sie auf die
Elemente der Liste anzuwenden~-- sonst gibt es ja weit und breit keine
anderen \lstinline{%a}s.  Dass die Funktion einen booleschen Wert
produziert, suggeriert schon, dass anhand dieses Werts unterschieden
wird.  Die Signatur liefert also wertvolle Informationen darüber, was
die Funktion macht~-- wenn auch nicht alle.
%
\begin{aufgabeinline}
  Schreibe eine andere sinnvolle Funktion mit der gleichen Signatur
  wie \lstinline{extract-list}!
\end{aufgabeinline}
%
Wir betrachten noch eine weitere Anwendung von
\lstinline{extract-list}: Wir wollen aus einer Liste von Spielen die
Spiele extrahieren, an denen eine bestimmte Mannschaft teilgenommen
hat.  Auch dazu definieren wir eine Hilfsfunktion, die feststellt, ob
ein Team bei einem Spiel die Heim- oder die Gastmannschaft ist:
%
\begin{lstlisting}
; Spielt Team bei Spiel?
(: plays-game? (team game -> boolean))

(check-expect (plays-game? "Wolfsburg" game1) #t)
(check-expect (plays-game? "Stuttgart" game1) #t)
(check-expect (plays-game? "Hannover" game1) #f)

(define plays-game?
  (lambda (team game)
    (or (string=? team (game-home-team game))
        (string=? team (game-guest-team game)))))
\end{lstlisting}
%
Nehmen wir an, wir wollen alle Spiele mit Beteiligung von Nürnberg
extrahieren, indem wir \lstinline{extract-list} verwenden.  Um
\lstinline{extract-list} zu verwenden, brauchen wir eine Funktion mit
Signatur~\lstinline{(game -> boolean)}.  Die können wir folgendermaßen
definieren:
%
\begin{lstlisting}
; Spielt Nürnberg mit?
(: plays-nürnberg? (game -> boolean))

(check-expect (plays-nürnberg? game1) #f)
(check-expect (plays-nürnberg? game5) #t)

(define plays-nürnberg?
  (lambda (game)
    (plays-game? "Nürnberg" game)))
\end{lstlisting}
%
Damit können wir zum Beispiel alle Nürnberg-Spiele aus der Saison
extrahieren:
%
\begin{lstlisting}
(extract-list plays-nürnberg? season-2009/2010)
\end{lstlisting}
%
Soweit so gut.  Aber was, wenn wir auch die Spiele des HSV extrahieren
wollen?  Wir könnten eine Funktion \lstinline{plays-hamburg?}
definieren, aber wenn wir viele solcher Anfragen stellen, wird es auf
Dauer umständlich, für jeden Verein extra eine Definiton zu schreiben.

Einfacher ist es, stattdessen die Funktion, die wir an
\lstinline{extract-list} übergeben, "<ad hoc"> mit einem
\lstinline{lambda} zu konstruieren:
%
\begin{lstlisting}
(extract-list (lambda (game) (plays-game? "Nürnberg" game)) 
              season-2009/2010)
(extract-list (lambda (game) (plays-game? "Hamburg" game)) 
              season-2009/2010)
\end{lstlisting}
%
Wir sind von der Signatur her vorgegangen: \lstinline{extract-list}
erwartet eine Funktion mit einem Parameter der Signatur
\lstinline{game}, also schreiben wir ein \lstinline{lambda} mit einem
entsprechenden Parameter.  Wir wollen alle Spiele extrahieren, bei
denen Nürnberg beziehungsweise Hamburg dabei ist, also schreiben wir
den entsprechenden Ausdruck in den Rumpf.
%
\begin{aufgabe}
  Schreibe eine Funktion \lstinline{games-playing}, die alle Spiele
  aus einer Liste extrahiert, bei denen ein bestimmtes Team dabei war.
\end{aufgabe}
%
Die Funktion \lstinline{extract-list} ist so praktisch, dass sie unter
dem Namen \lstinline{filter}\index{filter@\texttt{filter}} fest
eingebaut ist.

\section{Listen umwandeln}

FIXME: map

\section{Listen zusammenfalten}

In Abschnitt~\ref{sec:list-sum} haben wir auf
Seite~\pageref{sec:list-sum} die Funktionen \lstinline{list-sum} und
\lstinline{list-product} geschrieben, welche die Summe einer Liste von
Zahlen bildet:
%
\begin{lstlisting}
; Summe der Elemente einer Liste von Zahlen berechnen
(: list-sum ((list-of number) -> number))

(define list-sum
  (lambda (list)
    (cond
      ((empty? list) 0)
      ((cons? list)
       (+ (first list) (list-sum (rest list)))))))

; Produkt der Elemente einer Liste von Zahlen berechnen
(: list-product (list-of-numbers -> number))

(define list-product
  (lambda (list)
    (cond
      ((empty? list) 1)
      ((cons? list)
       (* (first list) (list-product (rest list)))))))
\end{lstlisting}
%
Die Definitionen von \lstinline{list-sum} und \lstinline{list-product}
unterscheiden sich, bis auf den Namen, nur an zwei Stellen: im Zweig
für \lstinline{empty}, wo das jeweilige neutrale Element steht, und im
Zweig für \lstinline{cons}, wo die Funktion steht, die benutzt wird,
um das erste Element mit dem Ergebnis des rekursiven Aufrufs zu
kombinieren.  Es ist also eine gute Idee zu abstrahieren!

Wir gehen wieder nach Konstruktionsanleitung~\ref{ka:abstraktion} auf
Seite~\pageref{ka:abstraktion} vor.  Uns ist beim ersten Mal, als wir
das gemacht haben, kein guter Name eingefallen.  Das ist keine
Schande: Wir fangen deshalb mit \lstinline{xxx} an in der Hoffnung,
dass uns später ein besserer Name einfällt:
%
\begin{lstlisting}
(define xxx
  (lambda (list)
    (cond
      ((empty? list) 1)
      ((cons? list)
       (* (first list) (xxx (rest list)))))))
\end{lstlisting}
%
Als nächstes müssen wir die Unterschiede zwischen den beiden
Funktionen durch neue Variablen ersetzen, das sind hier gerade
\lstinline{1} und \lstinline{*}.  Die neuen Variablen nennen wir
\lstinline{for-empty} und \lstinline{for-cons}, weil sie in den
Zweigen für \lstinline{empty} respektive \lstinline{cons} stehen:
%
\begin{lstlisting}
(define xxx
  (lambda (list)
    (cond
      ((empty? list) for-empty)
      ((cons? list)
       (for-cons (first list) (xxx (rest list)))))))
\end{lstlisting}
%
Für den nächsten Schritt fügen wir die neuen Variablen zum bestehenden
\lstinline{lambda} hinzu.  Wir müssen wieder darauf achten, die
Variablen auch zum rekursiven Aufruf hinzuzufügen:
%
\begin{lstlisting}
(define xxx
  (lambda (for-empty for-cons list)
    (cond
      ((empty? list) for-empty)
      ((cons? list)
       (for-cons (first list)
                 (xxx for-empty for-cons (rest list)))))))
\end{lstlisting}
%
Diese Funktion kann sowohl die Aufgabe von \lstinline{list-sum} als
auch die von \lstinline{list-product} erledigen:
%
\begin{lstlisting}
(xxx 0 + (list 1 2 3 4))
|\evalsto| 10
\end{lstlisting}
%
und so aufmultiplizieren:
%
\begin{lstlisting}
(xxx 1 * (list 1 2 3 4))
|\evalsto| 24
\end{lstlisting}
%
Als nächstes steht nach Konstruktionsanleitung die Signatur für die
neue Funktion an.  Es liegt nahe, die Signatur von
\lstinline{list-sum} beziehungsweise \lstinline{list-product} zu
verallgemeinern.  Für den neuen Parameter \lstinline{for-empty}
verwenden wir die Signatur von \lstinline{0} und \lstinline{1}, also
\lstinline{number}.  Für \lstinline{for-cons} verwenden wir die
Signatur von \lstinline{+} und \lstinline{*}, also
\lstinline{(number number -> number)}:
%
\begin{lstlisting}
(: xxx (number (number number -> number) (list-of number) -> number))
\end{lstlisting}
%
Bei näherer Betrachtung steht aber in der Definition von
\lstinline{xxx} allerdings nichts "<zahlenspezifisches">, wir könnten
also versuchen, \lstinline{number} durch eine Signaturvariable zu
ersetzen, wie wir es auch bei \lstinline{list-map} im vorigen
Abschnitt gemacht haben:
%
\begin{lstlisting}
(: xxx (%a (%a %a -> %a) (list-of %a) -> %a))
\end{lstlisting}
%
Das heißt, wir könnten versuchen, \lstinline{xxx} mit etwas
aufzurufen, das keine Liste von Zahlen ist.  Wir brauchen dafür ein
passendes zweites Argument, also eine
Funktion, deren Signatur die Form \lstinline{(%a %a -> %a)} hat.  Ein
Beispiel ist die Funktion \lstinline{append}, die zwei Listen
aneinanderhängt und folgende Signatur hat:
%
\begin{lstlisting}
((list-of %element) (list-of %element) -> (list-of %element))
\end{lstlisting}
% 
Weil wir \lstinline{(list-of %element)} für \lstinline{%a} einsetzen,
brauchen wir als weitere Argumente für \lstinline{xxx} noch eine
Liste als erstes Argument und eine Liste von Listen als drittes
Argument.  Das könnte so aussehen:
%
\begin{lstlisting}
(xxx empty append (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))
|\evalsto| #<list 1 2 3 4 5 6 7 8 9>
\end{lstlisting}
%
Wir können also \lstinline{xxx} benutzen, um eine Liste von Listen
"<flachzuklopfen">.

Aber ist das schon die beste Signatur für \lstinline{xxx}?  Wir können
wie bei \lstinline{list-map} untersuchen, ob die \lstinline{%a}s
tatsächlich alle gleich sein müssen.  Um das herauszubekommen, könnten
wir mal annehmen, sie seien alle verschieden:
  %
\begin{lstlisting}
(: xxx (%a (%b %c -> %d) (list-of %e) -> %f))
\end{lstlisting}
%
Wenn wir aber die Definition von \lstinline{xxx} genau anschauen, dann
sehen wir, dass jeweils einige Signaturvariablen gleich sein müssen:
%
\begin{itemize}
\item Die Signatur \lstinline{%a} von \lstinline{for-empty} muss die
  gleiche sein wie \lstinline{%f}, weil \lstinline{for-empty} als
  Ergebnis von \lstinline{xxx} verwendet wird.
\item Die Signatur \lstinline{%b} des ersten Arguments von
    \lstinline{for-cons} muss die gleiche sein wie die der
    Listenelemente \lstinline{%a}, weil als erstes Argument
      \lstinline{(first list)} verwendet wird.
\item Die Signatur \lstinline{%c} des Arguments von
    \lstinline{for-cons} muss die gleiche sein wie \lstinline{%f},
     weil das Ergebnis von \lstinline{xxx} dort verwendet wird.
\item Die Signatur \lstinline{%d} des Ergebnisses von
    \lstinline{for-cons} muss ebenfalls die gleiche sein wie
    \lstinline{%f}, weil der Aufruf von \lstinline{for-cons} als
    Ergebnis von \lstinline{xxx} verwendet wird.
\end{itemize}
%
Aber immerhin müssen \lstinline{%a} und \lstinline{%b} nicht gleich
sein.  Es bleibt:
%
\begin{lstlisting}
(: xxx (%a (%b %a -> %a) (list-of %b) -> %a))
\end{lstlisting}
%
FIXME ab hier

\lstinline{List-fold} funktioniert wie folgt: Die Funktion hat als
Parameter eine Funktion mit zwei Parametern, einen Wert und eine
Liste von Werten.  Es gilt folgende Gleichung:
%
\begin{lstlisting}
(list-fold |\(u\)| |\(o\)| #<list |\(a_1\)| |\(\ldots\)| |\(a_n\)| >) = (|\(o\)| |\(a_1\)| (|\(o\)| |\(a_2\)| (|\(\ldots\)| (|\(o\)| |\(a_n\)| |\(u\)|) |\(\ldots\)|)))
\end{lstlisting}
%
Die Funktionsweise von \lstinline{list-fold} lässt sich daran
veranschaulichen, dass sich die ursprüngliche Liste auch als
%
\begin{lstlisting}
(cons |\(a_1\)| (cons |\(a_2\)| (|\(\ldots\)| (cons |\(a_n\)| empty |\(\ldots\)|)))
\end{lstlisting}
%
schreiben lässt.  Das heißt, an die Stelle von \lstinline{cons} tritt
$o$ und an die Stelle von \lstinline{empty} tritt $u$.

Eine andere, praktische Darstellung von 
\lstinline{list-fold} ist, die Gleichung mit dem Operator
\emph{zwischen} den Operanden zu schreiben (und nicht davor), in
Infix-Schreibweise also:
%
\begin{lstlisting}
  (list-fold |\(u\)| |\(\odot\)| #<list |\(a_1\)| |\(\ldots\)| |\(a_n\)| >) = |\(a_1 \odot (a_2 \odot (\ldots (a_n \odot u)\ldots ))\)|
\end{lstlisting}
%
Nach dieser Sichtweise wird $\odot$ zwischen die Elemente der Liste
eingefügt.

\begin{aufgabe}
  FIXME: empty und cons
\end{aufgabe}

FIXME: allgmeines Rekursionsmuster

\section{Anonyme Funktionen}\label{sec:anonymous-procedures}

\lstinline{List-fold} kann auch benutzt werden, um die Länge einer Liste
auszurechnen.  Ganz so einfach wie bei den vorigen Beispielen ist das
nicht, da \lstinline{list-length} aus
Abschnitt~\ref{sec:more-lists} nicht direkt dem Muster entspricht:
%
\begin{lstlisting}
(define list-length
  (lambda (lis)
    (cond
      ((empty? lis) 0)
      ((cons? lis) 
       (+ 1 
          (list-length (rest lis)))))))
\end{lstlisting}
%
Für das \lstinline{combine}-Argument von \lstinline{list-fold}
würde hier eine Funktion benötigt, die ihr erstes
Argument \lstinline{(first lis)} ignoriert (es spielt ja für die Listenlänge
keine Rolle) und auf das zweite Argument eins addiert.  Diese
Hilfsfunktion sieht so aus:\index{add-1-for-length@\texttt{add-1-for-length}}
%
FIXME: warum nicht \lstinline{\%a}?  Warum heißt das \lstinline{ignore}?

\begin{lstlisting}
(: add-1-for-length (any natural -> natural))
(define add-1-for-length
  (lambda (ignore n)
    (+ n 1)))
\end{lstlisting}
%
Damit funktioniert es:
%
\begin{lstlisting}
(list-fold 0 add-1-for-length (list 1 2 3 4 5))
|\evalsto| 5
\end{lstlisting}
%
Für solche Mini-Funktionen lohnt es sich oft kaum, eine eigene
Definition anzugeben und einen sinnstiftenden Namen zu finden.  Das
ist auch nicht notwendig: die rechte Seite der Definition, also der
Lambda-Ausdruck, kann auch direkt eingesetzt werden:
%
\begin{lstlisting}
(list-fold 0 (lambda (ignore n) (+ n 1)) (list 1 2 3 4 5))
|\evalsto| 5
\end{lstlisting}
%
Meist tauchen Lambda-Ausdrücke zwar als Teil von Funktiondefinition
auf, aber es ist natürlich möglich, Funktionen außerhalb einer
Definition zu verwenden, ohne ihnen einen Namen zu geben.  Dafür gab
es schon in Kapitel~\ref{cha:whats-programming} Beispiele. Mit Hilfe
solcher "<anonymer Funktionen\index{anonyme
  Funktion}\index{Funktion!anonym}"> lässt sich auch \lstinline{list-filter}
durch \lstinline{list-fold} definieren:
%
\begin{lstlisting}
(define list-filter
  (lambda (p? lis)
    (list-fold empty
               (lambda (first result)
                 (if (p? first)
                     (cons first result)
                     result))
               lis)))
\end{lstlisting}
%
Ein weiteres Beispiel~-- die Funktion
\lstinline{every?}\index{every?@\texttt{every?}} findet heraus, ob ein
übergebenes Prädikat auf alle Elemente einer Liste zutrifft:
\label{page:every}
%
\begin{lstlisting}
; prüfen, ob Prädikat auf alle Elemente einer Liste zutrifft
(: every? ((%a -> boolean) (list-of %a) -> boolean))
(define every?
  (lambda (p? lis)
    (list-fold #t
               (lambda (first result)
                 (and result
                      (p? first)))
               lis)))
\end{lstlisting}
%
Anders als \lstinline{list-length} lassen sich diese Definitionen
nicht mit separaten Hilfsfunktionen schreiben.  Für
\lstinline{list-filter} würde ein Versuch zwar so aussehen:
%
\begin{lstlisting}
(define list-filter-helper
  (lambda (first result)
    (if (p? first)
        (cons first result)
        result)))
\end{lstlisting}
%
In \drscheme{} erscheint bei dieser Definition eine Fehlermeldung 
"<\texttt{unbound variable}"> und \lstinline{p?} wird rosa markiert.  Das
liegt daran, dass \lstinline{p?} weiter außen im \lstinline{lambda} von
\lstinline{filter} gebunden ist.  Dieses \lstinline{p?} ist aber nach den
Regeln der lexikalischen Bindung\index{lexikalische Bindung} (siehe
Abschnitt~\ref{sec:lexical-binding}) nur im Rumpf des äußeren
\lstinline{lambda} in der Definition von \lstinline{filter} sichtbar.  Darum
muss der Lambda-Ausdruck der Hilfsfunktion ebenfalls in diesem
Rumpf stehen.

FIXME: Hier auch noch \lstinline{map} einführen? Das Unterrichtsbeispiel tat
es\ldots

\section{Funktionfabriken}

Ein nützlicheres Beispiel für eine Higher-Order-Funktion in der
Mathematik ist die
Komposition\index{Komposition}\index{*@$\circ$}
$\circ$.  Seien $f: B\rightarrow C$ und $g: A\rightarrow B$
Funktionen.  Dann ist $f\circ g$ folgendermaßen definiert:
%
\begin{displaymath}
  (f \circ g)(x) \deq{} f(g(x))
\end{displaymath}
%
$\circ$ lässt sich direkt als Funktion
programmieren:\index{compose@\texttt{compose}}
\label{page:compose}
%
\begin{lstlisting}
; zwei Funktionen komponieren
(: compose ((%b -> %c) (%a -> %b) -> (%a -> %c)))
(define compose
  (lambda (f g)
    (lambda (x)
      (f (g x)))))
\end{lstlisting}
%
Die beiden Argumente für \lstinline{f} und \lstinline{g} müssen Funktionen
mit einem Parameter sein:
%
\begin{lstlisting}
(define add-5
  (lambda (x)
    (+ x 5)))
(define add-23
  (lambda (x)
    (+ 23 x)))
(define add-28 (compose add-5 add-23))
(add-28 3)
|\evalsto| 31
((compose (lambda (x) (* x 2)) add-1) 5)
|\evalsto| 12
\end{lstlisting}
%
\lstinline{Compose} ist eine
\textit{Funktionfabrik\index{Funktionfabrik}}~-- sie liefert selbst
eine Funktion zurück, die abhängig von \lstinline{f} und \lstinline{g}
konstruiert wird.

\lstinline{Compose} lässt sich benutzen, um eine weitere praktische
Higher-Order-Funktion namens
\lstinline{repeat} zu definieren:\index{repeat@\texttt{repeat}}
\label{page:repeat}
%
\begin{lstlisting}
; Funktion wiederholt anwenden
(: repeat (natural (%a -> %a) -> (%a -> %a)))
(define repeat
  (lambda (n proc)
    (if (= n 0)
        (lambda (x) x)
        (compose proc (repeat (- n 1) proc)))))
\end{lstlisting}
%
\lstinline{Repeat} ist das Pendant zur Potenzierung\index{Potenzierung} von
Funktionen in der Mathematik, siehe Definition~\ref{def:power_fun}:
%
\begin{lstlisting}
((repeat 5 (lambda (n) (* n 2))) 1)
|\evalsto| 32
\end{lstlisting}

\section{Der Schönfinkel-Isomorphismus}
\label{sec:currying}
\index{Schönfinkel-Isomorphismus}
Hier ist eine Funktionfabrik, die Funktionen erzeugt, die auf eine
Zahl eine Konstante addieren:\index{make-add@\texttt{make-add}}
%
\begin{lstlisting}
; Funktion erzeugen, die eine Konstante addiert
(: make-add (number -> (number -> number)))
(define make-add
  (lambda (a)
    (lambda (b)
      (+ a b))))
\end{lstlisting}
%
Angewendet werden kann sie folgendermaßen:
%
\begin{lstlisting}
(define add-1 (make-add 1))
(add-1 15)
|\evalsto| 16
(define add-7 (make-add 7))
(add-7 15)
|\evalsto| 22
\end{lstlisting}
%
Das geht auch ohne Zwischendefinitionen:
%
\begin{lstlisting}
((make-add 7) 15)
|\evalsto| 22
((make-add 13) 42)
|\evalsto| 55
\end{lstlisting}
%
\lstinline{Make-add} ist eine andere Version von \lstinline{+}, nämlich
eine, die zwei Argumente nicht "<auf einmal"> akzeptiert, sondern
"<nacheinander">.  Summen von zwei Zahlen, normalerweise geschrieben
als \texttt{(+ $a$ $b$)} lassen sich auch als \texttt{((make-add $a$)
  $b$)} schreiben.  Diese Transformation von einer Funktion mit zwei
Parametern in eine Funktion mit nur einem Parameter, die eine Funktion
mit einem weiteren Parameter zurückgibt, die dann schließlich den "<Wert">
liefert, lässt sich auch auf andere Funktionen anwenden:\index{make-mult@\texttt{make-mult}}\index{make-prepend@\texttt{make-prepend}}
%
\begin{lstlisting}
; Funktion erzeugen, die mit einer Konstante multipliziert
(: make-mult (number -> (number -> number)))
(define make-mult
  (lambda (a)
    (lambda (b)
      (* a b))))

; Funktion erzeugen, die an eine Liste ein Element vorn anhängt
(: make-prepend (a -> ((list-of a) -> (list-of a))))
(define make-prepend
  (lambda (a)
    (lambda (b)
      (cons a b))))
\end{lstlisting}
%
Erneut folgt eine ganze Familie von Funktionen einem gemeinsamen
Muster, und erneut lässt sich dieses Muster als Funktion höherer
Ordnung formulieren.  Die Funktion \lstinline{curry}\index{curry@\texttt{curry}} akzeptiert
eine Funktion mit zwei Parametern und liefert eine entsprechend
transformierte Funktion zurück:
%
\begin{lstlisting}
; Funktion mit zwei Parametern staffeln
(: curry ((%a %b -> %c) -> (%a -> (%b -> %c))))
(define curry
  (lambda (proc)
    (lambda (a)
      (lambda (b)
        (proc a b)))))
\end{lstlisting}
%
Nun lassen sich die \lstinline{make-}$x$-Funktionen von oben mit Hilfe
von \lstinline{curry} definieren:
%
\begin{lstlisting}
(define make-add (curry +))
(define make-mult (curry *))
(define make-prepend (curry cons))
\end{lstlisting}
%
Die \lstinline{curry}-Transformation wurde unabhängig voneinander von den
Mathematikern \textsc{Moses Schönfinkel} und \textsc{Haskell Curry} entdeckt.  Im
englischsprachigen Raum heißt das Verb dazu darum  \textit{currify}, im deutschsprachigen Raum
\textit{schönfinkeln\index{schönfinkeln}}
oder \textit{curryfizieren\index{curryfizieren}}.
% Warum heißt dann die Funktion dann curry und nicht currify?

Die Schönfinkel-Transformation lässt sich auch umdrehen:\index{curry@\texttt{curry}}
%
\begin{lstlisting}
; Funktion zu einer Funktion mit zwei Parametern entstaffeln
(: uncurry ((%a -> (%b -> %c)) -> (%a %b -> %c)))
(define uncurry 
  (lambda (proc)
    (lambda (a b)
      ((proc a) b))))
\end{lstlisting}
%
Damit ist die Transformation ein \textit{Isomorphismus\index{Isomorphismus}}; es gilt
folgende Gleichung für Funktionen $p$ mit zwei Parametern:\label{sec:curry-isomorphismus}
%
\begin{center}
  \lstinline{(uncurry (curry} \(p\)\lstinline{))} \(\equiv\) \(p\)
\end{center}

\section*{Aufgaben}

\begin{aufgabe}
  Schreibe eine Funktion \lstinline{any?} analog zu 
  \lstinline{every?}, die dann \lstinline{#t} zurückgibt, wenn mindestens ein 
  Element der Liste das Prädikat erfüllt, sonst \lstinline{#f}.  Schreibe 
  zunächst eine Fassung nach dem Muster von \lstinline{every?}.  Schreibe
  eine zweite Fassung, die einfach \lstinline{every?} aufruft und selbst keine
  Rekursion benutzt.
\end{aufgabe}

\begin{aufgabe}
  Eine klassische Higher-Order-Funktion ist \lstinline{list-map}, eine Funktion, die 
  eine Funktion und eine Liste akzeptiert.  \lstinline{List-map}
  wendet diese Funktion auf alle Elemente der Liste an und produziert
  eine Liste der Rückgabewerte.

  \lstinline{List-map} lässt sich beispielsweise folgendermaßen anwenden:
  % 
  \begin{lstlisting}
    (list-map even? (list 1 2 3 4 5))
    |\evalsto| #<list #f #t #f #t #f>
  \end{lstlisting}
  % 
  Programmiere \lstinline{list-map}, indem sie die Signatur schreiben,
  das Gerüst der Funktion erstellen, Testfälle entwerfen und dann das
  Gerüst vervollständigen!

  \textbf{Hinweis:} \lstinline{List-map} ist unter dem Namen \lstinline{map} eingebaut.
\end{aufgabe}

\begin{aufgabe}
  Schreibe folgende Funktionen unter der  
  Verwendung von \lstinline{filter}!
  \begin{itemize}
    \item Schreiben sie eine Funktion \lstinline{evens}, die die ungeraden Zahlen aus 
      einer Liste entfernt,
  \item eine Funktion \lstinline{count-zeroes}, die in einer Liste von
    Zahlen die Nullen zählt,
  \item und eine Funktion \lstinline{multiples}, die eine Zahl $n$ und
    eine Liste von Zahlen akzeptiert, und eine Liste alle Vielfachen
    der Zahl $n$ liefert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmiere eine Funktion
  \lstinline{filter-map}, die als Argumente eine Funktion \lstinline{p} mit
  einem Argument sowie eine Liste \lstinline{l} akzeptiert.
  \lstinline{Filter-map} soll als Ergebnis die Liste der Rückgabewerte
  von \lstinline{p} für diejenigen Elemente von \lstinline{l} zurückgeben,
  für die \lstinline{p} nicht \lstinline{#f} zurückgibt. Beispiel:

\begin{lstlisting}
(filter-map (lambda (x)
               (if (even? x)
                  (+ x 1)
                  #f))
            (list 1 2 5 17 24 13))
|\evalsto| #<list 3 25>
\end{lstlisting}
\end{aufgabe}

\begin{aufgabe}
  Verwende die Funktion \lstinline{list-fold} um folgende 
  Funktionen zu schreiben:
  \begin{enumerate}
  \item Schreibe eine Funktion \lstinline{list-map}, die eine Funktion auf jedes
    Element einer Liste anwendet.
  \item Schreibe eine Funktion \lstinline{list-or}, die ein Prädikat auf alle
    Elemente einer Liste anwendet und die Resultate mit \lstinline{or}
    verknüpft.
  \item Schreibe eine Funktion \lstinline{count-predicate}, die ein Prädikat auf
    alle Elemente einer Liste anwendet und zählt, wie häufig \lstinline{#t}
    zurückgegeben wird.
  \item Schreibe eine Funktion \lstinline{contains?}, die feststellt, ob ein
    Element in einer Liste enthalten ist.
  \item Schreibe eine Funktion \lstinline{remove-duplicates}, die alle doppelten
    Elemente aus einer Liste filtert.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Fußballreporter zitieren gern obskure Fakten über
  vergangene Spiele, wenn sie zum Spielverlauf wenig zu sagen haben.

  Hier ein Beispiel:
  % 
  \begin{quote}
    "<In der Saison 2009/2010 gab es ja immerhin vier Spieltage, an
    denen die größte Tordifferenz kleiner als 3 war.">
  \end{quote}
  %
\begin{enumerate}
\item Stelle dem Fußballreporter Hilfsfunktionen zur Verfügung,
  die ihm erlauben, eine Antwort auf solch eine Frage zu
  finden:
  %
  \begin{quote}
    \emph{An wie vielen Spieltagen der Saison 2009/2010 war die größte
    Tordifferenz kleiner als 3?}
  \end{quote}
  %
  Schreibe mit Hilfe dieser Funktionen einen Ausdruck, der
  testet, ob die am Anfang dieser Aufgabe zitierte Aussage über die
  Tordifferenzen in der Saison 2009/2010 stimmt!

  \begin{enumerate}
  \item Schreibe eine Funktion, die aus einer Liste die Dubletten
    entfernt.  Diese Funktion akzeptiert eine Liste sowie eine
    Funktion, die zwei Elemente der Liste akzeptiert und
    zurückliefert, ob diese gleich sind.  (Also zum Beispiel
    \lstinline{=} bei Listen von Zahlen.)  Sie liefert dann eine Liste,
    in der jedes Element "<nur einmal vorkommt">, also kein anderes,
    das dazu gleich ist.
  \item Schreibe eine Funktion, die aus der Liste aller Spiele
    eine Liste aller Spielplannummern extrahiert.
  \item Schreibe eine Funktion, die aus der Liste aller Spiele
    eine Liste von Listen aller Spiele macht~-- so dass in jeder
    Teilliste alle Spiele eines Spieltags zusammengefasst sind.
  \item Schreibe eine Funktion, welche die Tordifferenz eines
    Spiels zurückliefert.
  \item Schreibe eine Funktion, welche das maximale Element einer
    Liste berechnet.  Die Funktion sollte neben der Liste eine
    Funktion akzeptieren, die berechnet, ob ein Element "<kleiner oder
    gleich"> einem anderen ist.
  \item Schreibe schließlich einen Ausdruck, der die Anzahl der
    Spieltage der Saison 2009/2010 liefert, bei denen die größte
    Tordifferenz kleiner als 3 war.
  \end{enumerate}

  \item Schreibe Ausdrücke, die folgende Fragen beantworten~--
  entwickele dazu, falls nötig, weitere Hilfsfunktionen:
  \begin{itemize}
    \item An welchem Spieltag gab es die meisten Heimsiege?
    \item An welchem Spieltag fielen die meisten Tore?
    \item Gab es mehr Siege für die Heimmanschaften an ungeraden Spieltagen als an
      geraden?
    \end{itemize}
    
  \item Finde eine besonders
    kreativ-obskure Frage und schreibe den Ausdruck, der sie
    beantwortet.
\end{enumerate} 

\end{aufgabe}

\begin{aufgabe}
  \lstinline{List-fold} sammelt die Elemente von hinten nach vorn bzw.
  von rechts nach links auf, entsprechend der "<natürlichen">
  Rekursionsstruktur über Listen.  Das gleiche Spiel lässt sich auch in
  der anderen Richtung durchführen.  Heraus kommt eine Funktion
  \lstinline{list-fold-left}, die folgende Gleichung (in
  Infix-Schreibweise) erfüllt:
  % 
\begin{lstlisting}
(list-fold-left |\(u\)| |\(\odot\)| (|\(a_1\)| |\(\ldots\)| |\(a_n\)|)) = |\((\ldots((u\odot a_1)\odot a_2)\ldots\odot a_n)\)|
\end{lstlisting}
  % 
  Programmiere \lstinline{list-fold-left}!
\end{aufgabe}


\begin{aufgabe}
  Schreibe ein Programm, das Berechnungen
  mit unendlichen Werten durchführen kann:
  
  \begin{enumerate}
  \item Definiere den gemischten Typ \lstinline{number*}, der den
    Datentyp \lstinline{number} um $\infty$ (\lstinline{infty}) und $- \infty$
    (\lstinline{-infty}) erweitert.
  \item Definiere auf der Menge \lstinline{number*} die
    Rechenoperationen $+$, $-$, $*$, und $/$.  Gib den Funktionen
    die Namen \lstinline{plus*}, \lstinline{minus*}, \lstinline{mult*} und
    \lstinline{div*}.
  \item Definiere $\leq$, also eine Funktion mit dem
    Namen \lstinline{<=*}, die die Ordnung auf \lstinline{number*} darstellt.
  \item Definiere die Funktionen \lstinline{list-max*} und
    \lstinline{list-min*}, die das Maximum bzw. das Minimum einer Liste 
    aus \lstinline{numbers*} berechnet!  Verwende hierzu die Funktion \lstinline{list-fold}.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{lstlisting}
(define x 2)          ;  --> zwei
(define y -1)         ;  --> minuseins
(define z -3)         ;  --> minusdrei

(define f 
  (lambda (x z)
    (+ (* x x) z y)))

(f 4 -2)
\end{lstlisting}
  %
  Benenne die Variablen \lstinline{x}, \lstinline{y} und \lstinline{z}, die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um, und zwar \lstinline{x} in \lstinline{zwei}, \lstinline{y} in
  \lstinline{minuseins} und \lstinline{z} in \lstinline{minusdrei}. Achte bei
  der Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \lstinline{f} um.

  Nachdem Du die Umbenennung durchgeführt hast, welches Ergebnis liefert
  der Ausdruck \lstinline{(f 4 -2)}? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{lstlisting}
(define x 2)                    ; --> zwei
(define y 4)                    ; --> vier

(define z                       ; --> f
  (lambda (x y z)
    (+ x (z y))))

(z y x (lambda (z) (+ x z)))
\end{lstlisting}
%
  Benenne die Variablen \lstinline{x}, \lstinline{y} und \lstinline{z}, die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um. Der neue Name der Variable steht als Kommentar im
  Programm hinter dem Pfeil (\lstinline{-->}).  Achte bei der
  Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \lstinline{z} um.

  Berechne, nachdem Du die Umbenennung durchgeführt haben, von
  Hand mit dem Substitutionsmodell \lstinline{(z y x}
  \lstinline{(lambda (z) (+ x z))))} und halte die Zwischenschritte
  fest.

\end{aufgabe}

\begin{aufgabe}
  Betrachte folgendes Programm:

\begin{lstlisting}
(define x 1)
(define y 3)
(define z 5)

(define f
  (lambda (x)   
     ((lambda (y)
        ((lambda (z)
           (+ z (* x y)))
         (+ x z)))
      (+ x y))))

(f y)
\end{lstlisting}

  Benenne hier alle lokalen Variablen, die innerhalb der Funktion
  \lstinline{f} gebunden werden, um. Verändere nicht den Namen der
  Variablen \lstinline{x}, \lstinline{y} und \lstinline{z} aus den ersten drei Zeilen
  des Programms.

  Nachdem Du die Umbenennung durchgeführt haben, welches Ergebnis liefert
  der Ausdruck \lstinline{(f y)}? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.

  \noindent \emph{Hinweis:} In diesen Aufgaben findest keine
  Kommentare und Signaturen zu den Funktionen. Hier kannst Du an einem
  Beispiel sehen, dass es sehr wichtig ist, diese Informationen
  anderen Programmierern immer zur Verfügung zu stellen. Denn es kann
  auch bei kleinen Programmen schwer sein, die Funktionsweise der
  einzelnen Funktionen ohne Kommentare zu verstehen.
\end{aufgabe}

\begin{aufgabe}
  Funktionen können nicht nur als Argumente an
  andere Funktionen übergeben, sondern auch als Ergebnisse
  zurückgeliefert werden. Dies soll in dieser Aufgabe genutzt werden,
  um ein einfaches Telefonbuch zu implementieren: Ein Telefonbuch ist
  als Funktion repräsentiert, die den Namen einer Person akzeptiert
  und die Telefonnummer der Person zurückliefert. Falls die Person
  nicht im Telefonbuch verzeichnet ist, soll \lstinline{#f} zurückgeliefert
  werden.

  \begin{enumerate}
  \item Definiere zunächst eine Signatur
    \lstinline{phonebook-result} für das Ergebnis des Nachschlagens in einem
    Telefonbuch. Das Ergebnis ist entweder die Telefonnummer oder
    \lstinline{#f}. Die Telefonnummern sind Zeichenketten.
    Die Signatur des Telefonbuchs ist  \lstinline{string -> phonebook-result}.
  \item Definiere einen Wert \lstinline{empty-phonebook}, der das leere
    Telefonbuch repräsentiert.
  \item Definiere eine Funktion namens
    \lstinline{add-to-phonebook}, welche ein Telefonbuch, einen Namen
    und eine Telefonnummer erwartet und das um den neuen Eintrag
    erweiterte
    Telefonbuch zurückliefert.
  \item Schreibe eine Funktion namens \lstinline{lookup-in-phonebook},
    welche ein Telefonbuch und einen Namen einer Person erwartet und die
    Nummer der Person im Telefonbuch nachschlägt und zurückliefert.
    Beispiele:
    \begin{itemize}
    \item \lstinline{(lookup-in-phonebook empty-phonebook "Hans")} liefert
      \lstinline{#f}.
    \item \lstinline{(lookup-in-phonebook} \\
      \lstinline{    (add-to-phonebook empty-phonebook "Hans" "754829")}\\
      \lstinline{    "Hans")} \\
      liefert \lstinline{"754829"}.
    \item \lstinline{(lookup-in-phonebook}\\
      \lstinline{    (add-to-phonebook empty-phonebook "Hans" "754829")}\\
      \lstinline{    "Lea")}\\
      liefert \lstinline{#f}.
    \end{itemize}
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Ein Polynom ist eine Funktion von $\mathbb{R}$ nach $\mathbb{R}$ und
  hat folgende Form:
  \begin{displaymath}
    p(x) = a_0 +
    a_1 \cdot x + a_2 \cdot x^2 + \ldots + a_n \cdot x^n    
  \end{displaymath}
  %
  Ein Polynom wird also eindeutig durch die Koeffizienten $a_0$ bis
  $a_n$ bestimmt.

  \begin{enumerate}
   \item Schreibe die Datendefinition für Polynome.
   \item Programmiere eine Funktion \lstinline{polynomial+}, die
     zwei Polynome addiert.  Schreibe ggf.\ zutreffende Eigenschaften auf
     und überprüfe diese!
     
   \item Programmiere eine Funktion \lstinline{polynomial*}, die zwei Polynome 
     multipliziert. 
     Beispielsweise werden die Polynome $a_0+a_1 x$ und $b_0+b_1 x$ nach folgendem Schema multipliziert:
     \begin{eqnarray*}
     & &a_0 \cdot (b_0+b_1x) \\
     &+&a_1 x \cdot (b_0+b_1 x) \\ 
     &=&a_0b_0+a_0b_1 x + a_1b_0x + a_1b_1x^2
     \end{eqnarray*}	
     Schreibe ggf.\ zutreffende Eigenschaften auf und überprüfe diese!
   \item Schreibe eine Funktion \lstinline{polynomial-function}, die
     ein Polynom akzeptiert und eine Funktion liefert, die ein Polynom
     an einer bestimmten Stelle auswertet, also gerade der Funktion
     $p$ aus der Definition entspricht. 
   \item Die Ableitung eines Polynoms $p$ wie oben ist bekanntlich durch
     \begin{displaymath}
       p'(x) = a_1 + 2\cdot a_2 \cdot x + 3\cdot a_3\cdot x^2 + \ldots
       + n \cdot a_n \cdot x^{n-1}
     \end{displaymath}
     gegeben. Schreibe die Funktion
     \lstinline{polynomial-derivative}, die von einem gegebenen Polynom das abgeleitete Polynom
     berechnet.
   \item Das Newton-Verfahren dient zur nährungsweisen
     Berechnung von Nullstellen. Für ein gegebenen Startwert nähert sich die
     Iteration 
     \begin{displaymath}
       x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
     \end{displaymath}
     immer näher an eine Nullstelle an.
     Programmiere das Newton-Verfahren!

     Hinweis: Die Lösung soll gut genug sein, wenn der Funktionswert nahe
     bei 0 liegt, also kleiner als eine Toleranz ist. 
     Da das
     Newton-Verfahren nicht immer eine Lösung liefert, programmiere
     Deine Funktion so, dass sie nach einer gewissen Anzahl von Schritten
     automatisch abbricht und \lstinline{#f} zurück gibt.
 \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Listen lassen sich nach verschiedenen Kriterien
  sortieren: zum Beispiel aufsteigend, absteigend, oder abhängig von
  einem Feld der Elemente.  So kann eine Liste von Fußballspielen nach
  der Gesamtanzahl der Tore, der Anzahl der Tore des Heimteams oder
  der Anzahl der Tore des Gästeteams oder der Anzahl der Tore des
  gewinnenden Teams sortiert werden.  Die genaue Anordnung wird durch
  eine Operation festgelegt, die bestimmt, ob ein Elemente vor einem anderen
  stehen soll.

\begin{enumerate}
\item Schreibe eine Funktion, die eine Liste nach einem beliebigen
  Kriterium sortiert.  Die Funktion sollte folgende Signatur haben:

\begin{lstlisting}
(: list-sort ((%a %a -> boolean) (list-of %a) -> (list-of %a)))
\end{lstlisting}

  Das erste Argument ist eine Funktion, die eine \textit{Halbordnung}
  realisiert, also zwei Elemente vergleicht, und \lstinline{#t}
  zurückliefert, falls sie schon in der richtigen Reihenfolge sind und
  \lstinline{#f}, falls nicht.  Zum Beispiel können \lstinline{<=} oder \lstinline{>=}
  für das Sortieren von Listen von Zahlen verwendet werden.
\item Benutze diese Funktion, um eine Liste von
  Fußballspielen nach den folgenden Kriterien zu sortieren:
  \begin{itemize}
  \item Gesamtanzahl der Tore,
  \item Anzahl der Tore des Heimteams,
  \item Anzahl der Tore des Gästeteams oder
  \item Anzahl der Tore des
    gewinnenden Teams
  \end{itemize}
\end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Folgen mit potentiell unendlicher Länge lassen sich als
  zusammengesetzte Daten mit zwei Komponenten repräsentieren: Dabei
  ist die erste Komponente das erste Element der Folge und die zweite
  eine Funktion ohne Parameter, die, wenn sie angewendet wird, eine Folge mit
  den restlichen Elementen ohne das erste liefert.
  Solche unendlichen Folgen heißen \textit{Streams}.
  Schreibe Daten- und Record-Definition für Streams!

  Hier ist eine Funktion, die einen Stream aus natürlichen Zahlen,
  angefangen bei einer Zahl $n$, liefert:
  % 
  \begin{lstlisting}
; Stream mit Zahlen ab n erzeugen
(: from (natural -> stream))
(define from
  (lambda (n)
    (make-stream n
                 (lambda () (from (+ n 1))))))
  \end{lstlisting}
  % 
  (Dabei ist angenommen, dass der Konstruktor der Record-Definition
  \lstinline{make-stream} heißt.)
  Zur Betrachtung von Streams ist folgende Funktion nützlich, welche
  die ersten $n$ Elemente eines Streams als Liste extrahiert:
  % 
  \begin{lstlisting}
; erste Elemente eines Streams in eine Liste extrahieren
(: stream-take (natural stream -> (list-of %a)))
(define stream-take
  (lambda (n stream)
    (if (= n 0)
        empty
        (cons (stream-first stream)
                   (stream-take (- n 1)
                                ((stream-rest-proc stream)))))))
   \end{lstlisting}
   % 
   (Dabei ist angenommen, dass die Selektoren für Streams
   \lstinline{stream-first} und \lstinline{stream-rest-proc} heißen.)
   \lstinline{Stream-take} lässt sich z.B.\ auf das Ergebnis von
   \lstinline{from} anwenden:
   % 
   \begin{lstlisting}
(stream-take 17 (from 4))
|\evalsto| #<list 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20>
   \end{lstlisting}
   % 
   Programmiere einige intellektuelle Herausforderungen mit Streams!
   \begin{enumerate}
   \item Programmiere eine Funktion \lstinline{stream-drop}, die eine
     natürliche Zahl $n$ und einen Stream akzeptiert, und einen neuen
     Stream liefert, der aus dem alten durch Weglassen der ersten $n$
     Elemente entsteht:
     \begin{lstlisting}
(stream-take 17 (stream-drop 3 (from 4)))
|\evalsto| #<list 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23>
     \end{lstlisting}
   \item Programmiere eine Funktion \lstinline{stream-filter} analog zu
     \lstinline{filter}:
     % 
     \begin{lstlisting}
(stream-take 10 (stream-filter odd? (from 1)))
|\evalsto| #<list 1 3 5 7 9 11 13 15 17 19>
     \end{lstlisting}
   \item Programmiere eine Funktion \lstinline{drop-multiples}, die 
     eine Zahl $n$ und einen Stream von Zahlen $s$ akzeptiert.
     \lstinline{Drop-multiples} soll einen Stream liefern, in dem
     gegenüber $s$  alle Vielfachen von $n$ entfernt wurden:
     % 
     \begin{lstlisting}
(stream-take 10 (drop-multiples 3 (from 1)))
|\evalsto| #<list 1 2 4 5 7 8 10 11 13 14>
     \end{lstlisting}
   \item Schreibe eine Funktion \lstinline{sieve}, die aus einem Stream
     von Zahlen all diejenigen Zahlen entfernt, die Vielfache von
     Vorgängern im Stream sind:
     \begin{lstlisting}
(stream-take 10 (sieve (from 2)))
|\evalsto| #<list 2 3 5 7 11 13 17 19 23 29>
     \end{lstlisting}
     Um was für Zahlen handelt es sich in dem Beispielaufruf und
     warum?
   \item Schreibe eine Funktion \lstinline{powers}, die für eine Zahl
     $n$ einen Stream ihrer Potenzen liefert:
     % 
     \begin{lstlisting}
(stream-take 10 (powers 2))
|\evalsto| #<list 2 4 8 16 32 64 128 256 512 1024>
     \end{lstlisting}
   \item Schreibe eine Funktion \lstinline{stream-map} analog zu
     \lstinline{list-map}:
     \begin{lstlisting}
(stream-take 10 (stream-map (lambda (x) (+ x 1)) (from 1)))
|\evalsto| #<list 2 3 4 5 6 7 8 9 10 11>
     \end{lstlisting}
   \item Schreibe eine Funktion \lstinline{merge}, die zwei
     aufsteigende Streams von Zahlen zu einem aufsteigenden Stream
     der Elemente beider Streams vereinigt:
     \begin{lstlisting}
(stream-take 10 (merge (powers 2) (powers 3)))
|\evalsto| #<list 2 3 4 8 9 16 27 32 64 81>
     \end{lstlisting}
   \item Schreibe eine Definition für einen Stream aufsteigend
     sortierter Potenzen von Primzahlen:
     \begin{lstlisting}
(stream-take 10 prime-powers)
|\evalsto| #<list 2 3 4 5 7 8 9 11 13 16>
     \end{lstlisting}
     Definiere dazu zunächst einen Stream aus Streams von Potenzen
     % 
     \begin{lstlisting}
(define prime-powers-stream (stream-map powers (sieve (from 2))))
     \end{lstlisting}
     % 
     Definiere eine Funktion \lstinline{merge-streams}, welche
     diesen Stream akzeptiert und die Elemente der Streams
     aus \lstinline{prime-powers-stream} mit Hilfe von \lstinline{merge}
     aufsteigend sortiert.
   \end{enumerate}
 \end{aufgabe}

 \begin{aufgabe}
  Betrachte folgende mysteriöse Funktion:
\begin{lstlisting}
(: // ((%a -> (%b -> %b)) (list-of %a) -> (%b -> %b)))

(define //
  (lambda (proc lis)
    (cond
      ((empty? lis)
       (lambda (y)
         y))
      ((cons? lis)
       (lambda (y)
         ((proc (first lis))
          ((// proc (rest lis))
           y)))))))
\end{lstlisting}
  % 
  \textbf{Hinweise:} Beachte die Signaturen! In mehreren
  Teilaufgaben gibt es Gelegenheiten, \lstinline{curry} bzw.\
  \lstinline{uncurry} zu benutzen.

  \begin{itemize}
  \item Vergleiche die Funktion mit \lstinline{list-fold} und
    beschreibe, wie \lstinline{//} und \lstinline{list-fold} zueinander
    in Beziehung stehen.  Schreibe, falls möglich, eine
    Definition von \lstinline{//}, die \lstinline{list-fold} benutzt und
    umgekehrt.
  \item Schreibe mit Hilfe von \lstinline{//} eine Funktion
    \lstinline{list-sum}, welche die Elemente einer Liste addiert.
  \item Schreibe eine Funktion \lstinline{insert}, die eine reelle
    Zahl $n$ akzeptiert und eine Funktion zurückliefert, die eine
    aufsteigend sortierte Liste von reellen Zahlen konsumiert und
    eine Liste zurückliefert, in der $n$ an die entsprechende
    Stelle der Liste einsortiert wurde.
  \item Schreibe mit Hilfe von \lstinline{//} eine Funktion, die
    eine Liste von reellen Zahlen aufsteigend sortiert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmiere eine Version von
  \lstinline{list-fold-left}, nämlich die Funktion
  \lstinline{list-fold-left-bonus}, die \lstinline{list-fold} benutzt aber
  selbst keine Rekursion enthält und auch keine rekursiven
  Hilfsfunktionen aufruft.
\end{aufgabe}


\begin{aufgabe}
  Betrachte folgendes mysteriöse Programm:
  % 
  \begin{lstlisting}
(define y
  (lambda (f)
    ((lambda (x)
       (f (lambda (z) ((x x) z))))
     (lambda (x)
       (f (lambda (z) ((x x) z)))))))

(define m
  (y
   (lambda (f)
     (lambda (x)
       (if (= x 1)
           1
           (* x (f (- x 1))))))))
   \end{lstlisting}
  %
   Was macht \lstinline{m}?  \lstinline{Y} wird auch
   \textit{Fixpunktkombinator} genannt.  Erkläre einem Anfänger, der
   gerade drei Informatik-Stunden hinter sich hat, diesen Begriff~--
   außerdem was
   \lstinline{y} bewirkt und warum.
 \end{aufgabe}

\begin{aufgabe}
  Beweise, dass für Funktionen $p_1$ mit einem Parameter, die
  einparametrige Funktionen zurückgeben, und Funktionen $p_2$ mit zwei
  Parametern gilt:
  %
  \begin{center}
    \lstinline{(curry (uncurry $p_1$))} $\equiv$ $p_1$\\
    \lstinline{(uncurry (curry $p_2$))} $\equiv$ $p_2$
  \end{center}
 \end{aufgabe}

\begin{aufgabe}
  Eine Funktion $f$ ist idempotent, wenn gilt:

  \begin{center}
    \lstinline{(compose $f$ $f$) $\equiv$ $f$}
  \end{center}

  Zeige, dass folgende Funktion idempotent ist:

  \begin{lstlisting}
    (define abs
      (lambda (x)
         (if (negative? x)
             (- x)
             x)))  \end{lstlisting}

  Welche anderen idempotente Funktionen kennst Du?
\end{aufgabe}

\begin{aufgabe}
  Zwei Funktionen $f$ und $g$ sind invers
  zueinander, wenn gilt:

  \begin{center}
    \lstinline{(compose $f$ $g$) $\equiv$ id} und \lstinline{(compose $g$ $f$) $\equiv$ id}
  \end{center}

  Zeige, dass \lstinline{curry} und \lstinline{uncurry} invers zueinander sind.
\end{aufgabe}

\begin{aufgabe}
  Betrachte folgende Funktion:

  \begin{lstlisting}
(define mystery
  (lambda (l)
    (list-fold empty append
               (map (lambda (x)
                      (cons x empty))
                    l))))
  \end{lstlisting}

  \begin{enumerate}
  \item Was macht \lstinline{mystery}?

  \item Schreibe eine Signatur für \lstinline{mystery}.

  \item Beweise, dass \lstinline{mystery} tatsächlich das macht, was
    Du vermutest.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Beweise: $\forall n \in \mathbb{N}$ gilt
  \lstinline{(repeat $n$ id) $=$ id}, wobei \lstinline{id} die
  Identitätsfunktion ist.
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
