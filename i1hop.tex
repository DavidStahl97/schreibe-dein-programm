% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Higher-Order-Programmierung}
\label{cha:higher-order}


TBD

\section{Higher-Order-Funktionen auf Listen}

Eine nahezu unerschöpfliche Quelle für Diskussionen stellen die
Fußballergebnisse dar.  Hier stellen sich so bedeutsame Fragen wie:
\begin{itemize}
\item Wann hat Bayern München zuletzt den 1.~FC Kaiserslautern in einem
  Auswärtsspiel geschlagen?
\item Wie viele Tore sind in dieser Saison schon gefallen?
\item Welche Mannschaft ist abstiegsgefährdet?
\end{itemize}
In letzter Konsequenz läuft die Beantwortung solcher und ähnlicher Fragen auf
eine Datenbank hinaus; es geht aber auch schon wesentlich einfacher:

\begin{verbatim}
; Ein Spiel hat:
; - Spieltag (natural)
; - Gastgeber-Team (string)
; - Gastgeber-Tore (natural)
; - Gast-Team (string)
; - Gast-Tore (natural)

(define-record-procedures game
  make-game game?
  (game-matchday 
   game-home-team game-home-goals game-guest-team game-guest-goals))
(: make-game (natural string natural string natural -> game))
(: game? (any -> boolean))
(: game-matchday (game -> natural))
(: game-home-team (game -> string))
(: game-home-goals (game -> natural))
(: game-guest-team (game -> string))
(: game-guest-goals (game -> natural))
\end{verbatim}

Es folgen hier beispielhaft die Ergebnisse des ersten Spieltags der Bundesliga-Saison
2009/2010\footnote{Die kompletten Ergebnisse dieser Saison lassen sich unter dem Namen
\texttt{soccer.rkt} von der Webseite des Buchs -- \texttt{deinprogramm.de} --
herunterladen.}:
\begin{verbatim}
(define g1 (make-game 1 "Wolfsburg" 2 "Stuttgart" 0))
(define g2 (make-game 1 "Mainz" 2 "Bayer 04" 2))
(define g3 (make-game 1 "Hertha" 1 "Hannover" 0))
(define g4 (make-game 1 "Bremen" 2 "Frankfurt" 3))
(define g5 (make-game 1 "Nürnberg" 1 "Schalke" 2))
(define g6 (make-game 1 "Dortmund" 1 "1. FC Köln" 0))
(define g7 (make-game 1 "Hoffenheim" 1 "Bayern" 1))
(define g8 (make-game 1 "Bochum" 3 "Gladbach" 3))
(define g9 (make-game 1 "Freiburg" 1 "Hamburg" 1))

(define day1
  (list g1 g2 g3 g4 g5 g6 g7 g8 g9))
\end{verbatim}

Eine recht einfache Frage ist die Bestimmung der Punktzahl, welche die
Gastgebermannschaft in einem bestimmten Spiel erzielt hat. Eine Funktion, die
das leistet, hat Beschreibung und Signatur wie
folgt:\index{home-points@\texttt{home-points}}

\begin{verbatim}
; Punktzahl in Spiel
(define points
  (signature (enum 0 1 3)))

; Punktzahl für Gastgeber-Team berechnen
(: home-points (game -> points))
\end{verbatim}
Die Punktzahl des Gastgeberteams errechnet sich auf einfache Weise durch
Vergleich der erzielten Tore:

FIXME: let

\begin{verbatim}
(define home-points
    (lambda (g)
      (let ((g1 (game-home-goals g))
            (g2 (game-guest-goals g)))
        (cond
          ((> g1 g2) 3)
          ((< g1 g2) 0)
          ((= g1 g2) 1)))))
\end{verbatim}
Aber auch das Gästeteam soll die ihm zustehenden Punkte bekommen. Das führt zu
folgender Funktion:
\begin{verbatim}
; Punktzahl für Gast-Team berechnen
(: guest-points (game -> points))

(define guest-points
    (lambda (g)
      (let ((g1 (game-guest-goals g))
            (g2 (game-home-goals g)))
        (cond
          ((> g1 g2) 3)
          ((< g1 g2) 0)
          ((= g1 g2) 1)))))
\end{verbatim}
Wie nicht anders zu erwarten, sind diese beiden Funktionen fast zu hundert
Prozent identisch, der einzige Unterschied ist die Definition der lokalen
Variablen \texttt{g1} und \texttt{g2}. Eine solche Duplizierung von Code ist
immer schlecht, vor allem vor dem Gesichtspunkt der Wartbarkeit von
Programmen. Wenn etwa der Deutsche Fußballbund die Regeln für die Vergabe von
Punkten ändern sollte, müssten hier beide Funktionen in gleicher Weise
angepasst werden.  Die Lösung für das Problem zeigt sich dadurch, dass der
gemeinsame Code aus den beiden Funktionen "<ausfaktorisiert"> wird. 

Musterbildung\index{Musterbildung} ist eine der wichtigsten Abstraktionstechniken, und deshalb gibt
es ein eigenes Mantra:

\mantraabstraktion*

Anwendung dieser Abstraktion könnte zu einer Funktion \texttt{compute-points}
führen, die dann wie folgt für die Definition von \texttt{home-points} und
\texttt{guest-points} verwendet werden könnte:

\begin{verbatim}
(define home-points (compute-points game-home-goals game-guest-goals))
(define guest-points (compute-points game-guest-goals game-home-goals))
\end{verbatim}
%
\textbf{Wichtig:} Diese beiden Definitionen müssen \emph{nach} der
Definition von \texttt{compute-points} stehen, da davor
\texttt{compute-points} noch nicht definiert ist.

Die Signatur von \texttt{compute-points} müsste dann wie folgt sein:
\begin{verbatim}
(: compute-points ((game -> natural) (game -> natural) -> (game -> points)))
\end{verbatim}
Das verdient eine kurze Betrachtung: Hier liegt eine Funktion vor, die zwei
Funktionen als Argument akzeptiert und eine weitere Funktion als Ergebnis
liefert. Solche Funktionen heißen \textit{Funktionen höherer Ordnung\index{Funktion!höherer
    Ordnung}} oder
\textit{Higher-Order-Funktionen\index{Higher-Order-Funktion}}. 

Die Definition von \texttt{compute-points} ergibt sich recht leicht aus den
beiden schon vorgestellten Funktionen:
\begin{verbatim}
(define compute-points
  (lambda (goals-1 goals-2)
    (lambda (g)
      (let ((g1 (goals-1 g))
            (g2 (goals-2 g)))
        (cond
          ((> g1 g2) 3)
          ((< g1 g2) 0)
          ((= g1 g2) 1))))))
\end{verbatim}

Eine weitere interessante Aufgabe ist es, aus einer Liste von Spielen die
unentschieden ausgegangenen Spiele herauszusuchen. Dazu ist zunächst eine
Funktion notwendig, die feststellt, ob ein bestimmtes Spiel unentschieden war:
\begin{verbatim}
; Ist Spiel unentschieden?
(: game-draw? (game -> boolean))

(define game-draw?
  (lambda (g)
    (= 1 (home-points g))))
\end{verbatim}
Die jetzt gesuchte Funktion muss Kurzbeschreibung und Signatur wie folgt haben:
\begin{verbatim}
; Unentschiedene Spiele heraussuchen
(: games-draw ((list-of game) -> (list-of game)))
\end{verbatim}
%
Die Definition folgt der Konstruktionsanleitung für Funktionen auf Listen.
Hier ist die Schablone:
%
\begin{alltt}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) ...)
      ((cons? lis)
       ... (first lis) ...
       ... (games-draw (rest lis)) ...))))
\end{alltt}
%
Der erste Fall ist klar: wo keine Spiele sind, sind auch keine
unentschiedenen.  Der zweite Fall betrachtet das erste Element \texttt{(first
  lis)}.  Dabei ist entscheidend, ob es sich dabei um ein unentschiedenes Spiel
handelt oder nicht:
%
\begin{alltt}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       ... (game-draw? (first lis)) ...
       ... (games-draw (rest lis)) ...))))
\end{alltt}
%
Die Fallunterscheidung bestimmt, ob ein Spiel in die Ergebnisliste kommt oder
nicht:
%
\begin{alltt}
(define games-draw
  (lambda (lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (let ((f (first lis))
             (r (games-draw (rest lis))))
       (if (game-draw? f)
           (cons f r)
           r)))))))
\end{alltt}
%
Fertig!

Eine ganz ähnliche Funktion sortiert aus einer Liste von Spielen diejenigen
aus, an denen eine bestimmte Mannschaft teilgenommen hat:
\index{games-playing@\texttt{games-playing}}
%
\begin{alltt}
; Spielt Team bei Spiel?
(: plays-game? (string game -> boolean))

(define plays-game?
  (lambda (t g)
    (or (string=? t (game-home-team g))
        (string=? t (game-guest-team g)))))

; Alle Spiele mit einem Team herausfiltern
(: games-playing (string (list-of game) -> (list-of game)))

(define games-playing
  (lambda (t lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (let ((f (first lis))
             (r (games-playing t (rest lis))))
         (if (plays-game? t f)
             (cons f r)
             r))))))
\end{alltt}
%
Die Funktionen \texttt{games-draw} und \texttt{games-playing} unterscheiden
sich, abgesehen vom Namen und der Tatsache, dass \texttt{games-playing} noch
den Namen eines Teams als zusätzlichen Parameter hat, nur an
einer Stelle: \texttt{games-draw} verwendet
\texttt{game-draw?} an der Stelle, wo \texttt{games"=playing} 
\texttt{plays-game?} verwendet.  Eine einzelne Funktion könnte die
Aufgaben sowohl von \texttt{games-draw} als auch von \texttt{games-playing}
lösen, indem sie an der Stelle, an der \texttt{game-draw?}
bzw.\ \texttt{plays-game?} steht, verallgemeinert.  Das geht mit
Abstraktion: für das konkrete Prädikat wird ein
Parameter eingeführt.  Das Ergebnis, das sich ansonsten
direkt aus den Definitionen von \texttt{games-draw} und
\texttt{games-playing} ergibt, sieht so aus (erst einmal ohne
Signatur, die nachgeliefert wird):\index{filter-games@\texttt{filter-games}}
%
\begin{alltt}
(define filter-games
  (lambda (p? lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (if (p? (first lis))
           (cons (first lis)
                      (filter-games p? (rest lis)))
           (filter-games p? (rest lis)))))))
\end{alltt}
%
Das funktioniert tatsächlich:
%
\begin{alltt}
(define plays-nürnberg?
   (lambda (g)
      (plays-game? "Nürnberg" g)))

(filter-games plays-nürnberg? day1)
\evalsto{} #<list #<record:game 1 "Nürnberg" 1 "Schalke" 2>>
\end{alltt}
%
Das Abstrahieren über Funktionen funktioniert also genauso wie die
Abstraktion über andere Werte.  Die Signatur für die Funktion muß
natürlich berücksichtigen, dass \texttt{p?} eine Funktion ist.  Die Funktion
\texttt{plays-nürnberg?}, die für \texttt{p?}  verwendet wird, hat die
Signatur
%
\begin{alltt}
(: plays-nürnberg? (game -> boolean))
\end{alltt}
%
und deshalb hat \texttt{filter-games} folgende Signatur:
%
\begin{alltt}
(: filter-games ((game -> boolean) (list-of game) -> (list-of game)))
\end{alltt}
%
Tatsächlich steht aber in \texttt{filter-games} außer dem Namen dieser Funktion
jetzt nichts mehr, das
überhaupt Bezug darauf nimmt, dass es sich bei den Listenelementen um
\texttt{game}-Records handelt.  % Tatsächlich funktioniert die Funktion
% auch auf Listen von Zahlen:
% %
% \begin{alltt}
% (filter-games even? (list 1 2 3 4))
% \evalsto{} #<list 2 4>
% (filter-games odd? (list 1 2 3 4))
% \evalsto{} #<list 1 3>
% \end{alltt}
% So nicht, das gibt eine Signaturverletzung, denn \texttt{even?} hat nicht die
% Signatur \texttt{(game -> boolean)}!
% %
Damit kann das Wort \texttt{games} ganz aus der Funktiondefinition
verschwinden, und es entsteht eine vielseitig verwendbare Funktion
namens \texttt{list-filter}:\index{filter@\texttt{list-filter}}
%
\begin{alltt}
; aus einer Liste eine Liste der Elemente bilden,
; die eine bestimmte Eigenschaft haben
(: list-filter ((%a -> boolean) (list-of %a) -> (list-of %a)))
(define list-filter
  (lambda (p? lis)
    (cond
      ((empty? lis) empty)
      ((cons? lis)
       (if (p? (first lis))
           (cons (first lis)
                      (list-filter p? (rest lis)))
           (filter p? (rest lis)))))))
\end{alltt}


Die Entstehung von \texttt{list-filter} aus \texttt{games-draw} und
\texttt{games-playing} ist ein Paradebeispiel für die Abstraktion mit
Hilfe von Mustern.  Die Anwendung dieser Technik bringt eine Reihe von
Vorteilen:
%
\begin{itemize}
\item Das Programm wird kürzer.
\item Das Programm wird leichter zu lesen.
\item Wenn die Funktion korrekt ist, sind auch alle ihre Anwendungen
  korrekt.
\end{itemize}
%
Damit diese Vorteile zur Geltung kommen, müssen die "<alten">
Abstraktionsvorlagen gelöscht und durch Anwendungen der Abstraktion
ersetzt werden:
%
\begin{alltt}
; aus einer Spieleliste eine Liste der unentschiedenen Spiele bilden
(: games-draw ((list-of game) -> (list-of game)))
(define games-draw
  (lambda (lis)
    (list-filter game-draw? lis)))

; aus einer Spieleliste eine Liste der Spiele einer Mannschaft t bilden
(: games-playing (string (list-of game) -> (list-of game)))
(define games-playing
  (lambda (t lis)
    (list-filter (lambda (g) (plays-game? t g)) lis)))
\end{alltt}
%
In der Definition von \texttt{games-playing} bekam die Funktion
\texttt{list-filter} statt des Namens eines Prädikats direkt eine
Funktiondefinition.  Hier handelt es sich also technisch um eine \emph{anonyme
  Funktion}; dies wird in Abschnitt~\ref{sec:anonymous-procedures} noch weiter ausgeführt.

\section{Listen zusammenfalten}

Aus Abschnitt~\ref{sec:lists} ist die Funktion \texttt{list-sum}
bekannt, welche die Summe einer Liste von Zahlen bildet:
%
\begin{alltt}
; Liste aufsummieren
(: list-sum ((list-of number) -> number))
(define list-sum
  (lambda (lis)
    (cond
      ((empty? lis) 0)
      ((cons? lis) 
       (+ (first lis)
          (list-sum (rest lis)))))))
\end{alltt}
%
Eine eng verwandte Funktion würde die Elemente einer Liste nicht
aufsummieren, sondern aufmultiplizieren.   Signatur und Schablone sind
identisch zu \texttt{list-sum}:\index{list-product@\texttt{list-product}}
%
\begin{alltt}
; Liste aufmultiplizieren
(: list-product ((list-of number) -> number))
(define list-product
  (lambda (lis)
    (cond
      ((empty? lis) ...)
      ((cons? lis) 
       ... (first lis) ...
       ... (list-product (rest lis)) ...))))
\end{alltt}
%
Die erste Ellipse muß das Produkt der leeren Liste sein, also das
neutrale Element $1$ der Multiplikation.\footnote{0 funktioniert
  hier nicht~-- es würde dafür sorgen,
  daß \emph{jede} Liste 0 als Produkt hat.} 
Aus dem ersten Element und dem Produkt der
Restliste wird das Produkt der Gesamtliste durch
Multiplikation gebildet.\index{list-product@\texttt{list-product}}
%
\begin{alltt}
(define list-product
  (lambda (lis)
    (cond
      ((empty? lis) 1)
      ((cons? lis) 
       (* (first lis)
          (list-product (rest lis)))))))
\end{alltt}
%
Die Definitionen von \texttt{list-sum} und \texttt{list-product}
unterscheiden sich, bis auf den Namen, nur an zwei Stellen: beim ersten
Zweig, wo das jeweilige neutrale Element steht, und bei der Funktion,
die benutzt wird, um das erste Element mit dem Ergebnis des rekursiven
Aufrufs zu kombinieren.  Die abstrahierte Funktion heißt
\texttt{list-fold} und sieht folgendermaßen aus (die Signatur muß noch
einen Moment warten):\index{list-fold@\texttt{list-fold}}
%
\begin{alltt}
; die Elemente einer Liste kombinieren
(define list-fold
  (lambda (unit combine lis)
    (cond
      ((empty? lis) unit)
      ((cons? lis) 
       (combine (first lis)
                (list-fold unit combine (rest lis)))))))
\end{alltt}
%
Listen lassen sich damit folgendermaßen summieren:
%
\begin{alltt}
(list-fold 0 + (list 1 2 3 4))
\evalsto{} 10
\end{alltt}
%
und so aufmultiplizieren:
%
\begin{alltt}
(list-fold 1 * (list 1 2 3 4))
\evalsto{} 24
\end{alltt}
%
Die Signatur für \texttt{list-fold} ist nicht auf den ersten Blick
ersichtlich.  Hier ein erster Anlauf:

FIXME: Wie kommt man darauf?

%
\begin{alltt}
(: list-fold (%a (%a %a -> %a) (list-of %a) -> %a))
\end{alltt}
%
Wie sich weiter unten herausstellen wird, kann
diese Signatur aber
noch verallgemeinert werden.  Erst kommen allerdings noch einige
Erläuterungen zur Funktionsweise.

FIXME: zuviele Funktionen

\texttt{List-fold} funktioniert wie folgt: Die Funktion hat als
Parameter eine Funktion mit zwei Parametern, einen Wert und eine
Liste von Werten.  Es gilt folgende Gleichung:
%
\begin{displaymath}
  \texttt{(list-fold}~u~o~\verb|#<list |a_1~\ldots~a_n\verb|>|\texttt{)}
  = \texttt{($o$ $a_1$ ($o$ $a_2$ ($\ldots$ ($o$ $a_n$ $u$)$ \ldots$)))}
\end{displaymath}
%
Die Funktionsweise von \texttt{list-fold} läßt sich daran
veranschaulichen, daß sich die ursprüngliche Liste auch als
%
\begin{displaymath}
\texttt{(cons $a_1$ (cons $a_2$ ($\ldots$ (cons $a_n$ empty)$ \ldots$)))}
\end{displaymath}
%
schreiben läßt.  Das heißt, an die Stelle von \texttt{cons} tritt
$o$ und an die Stelle von \texttt{empty} tritt $u$.

Eine andere, praktische Darstellung von 
\texttt{list-fold} ist, die Gleichung mit dem Operator
\emph{zwischen} den Operanden zu schreiben (und nicht davor), in
Infix-Schreibweise also:
%
\begin{displaymath}
  \texttt{(list-fold}~u~\odot~\verb|#<list |a_1~\ldots~a_n\verb|>|\texttt{)}
  = a_1 \odot (a_2 \odot (\ldots (a_n \odot u)\ldots ))
\end{displaymath}
%
Nach dieser Sichtweise wird $\odot$ zwischen die Elemente der Liste
eingefügt.

In jedem Fall wird die Liste "<eingefaltet">~-- daher der Name.

Die Definition von \texttt{concatenate} aus
Abschnitt~\ref{sec:more-lists} paßt ebenfalls auf das abstrahierte
Muster von \texttt{list-fold}:
%
\begin{alltt}
(list-fold (list 4 5 6) cons (list 1 2 3))
\evalsto{} #<list 1 2 3 4 5 6>
\end{alltt}
%
Diese Applikation paßt aber nicht mehr auf den obigen Signaturversuch von
\texttt{list-fold}, da \texttt{make"=pair} nicht die Signatur
%
\begin{alltt}
%a %a -> %a
\end{alltt}
%
sondern
%
\begin{alltt}
%a (list-of %a) -> (list-of %a)
\end{alltt}
%
und deshalb
%
\begin{alltt}
%a %b -> %b
\end{alltt}
besitzt.  \texttt{List-fold} hat also folgende Signatur:
%
\begin{alltt}
(: list-fold (%b (%a %b -> %b) (list-of %a) -> %b)))
\end{alltt}
%

\section{Anonyme Funktionen}\label{sec:anonymous-procedures}

\texttt{List-fold} kann auch benutzt werden, um die Länge einer Liste
auszurechnen.  Ganz so einfach wie bei den vorigen Beispielen ist das
nicht, da \texttt{list-length} aus
Abschnitt~\ref{sec:more-lists} nicht direkt dem Muster entspricht:
%
\begin{alltt}
(define list-length
  (lambda (lis)
    (cond
      ((empty? lis) 0)
      ((cons? lis) 
       (+ 1 
          (list-length (rest lis)))))))
\end{alltt}
%
Für das \texttt{combine}-Argument von \texttt{list-fold}
würde hier eine Funktion benötigt, die ihr erstes
Argument \texttt{(first lis)} ignoriert (es spielt ja für die Listenlänge
keine Rolle) und auf das zweite Argument eins addiert.  Diese
Hilfsfunktion sieht so aus:\index{add-1-for-length@\texttt{add-1-for-length}}
%
FIXME: warum nicht \texttt{\%a}?  Warum heißt das \texttt{ignore}?

\begin{alltt}
(: add-1-for-length (any natural -> natural))
(define add-1-for-length
  (lambda (ignore n)
    (+ n 1)))
\end{alltt}
%
Damit funktioniert es:
%
\begin{alltt}
(list-fold 0 add-1-for-length (list 1 2 3 4 5))
\evalsto{} 5
\end{alltt}
%
Für solche Mini-Funktionen lohnt es sich oft kaum, eine eigene
Definition anzugeben und einen sinnstiftenden Namen zu finden.  Das
ist auch nicht notwendig: die rechte Seite der Definition, also der
Lambda-Ausdruck, kann auch direkt eingesetzt werden:
%
\begin{alltt}
(list-fold 0 (lambda (ignore n) (+ n 1)) (list 1 2 3 4 5))
\evalsto{} 5
\end{alltt}
%
Meist tauchen Lambda-Ausdrücke zwar als Teil von Funktiondefinition
auf, aber es ist natürlich möglich, Funktionen außerhalb einer
Definition zu verwenden, ohne ihnen einen Namen zu geben.  Dafür gab
es schon in Kapitel~\ref{cha:whats-programming} Beispiele. Mit Hilfe
solcher "<anonymer Funktionen\index{anonyme
  Funktion}\index{Funktion!anonym}"> läßt sich auch \texttt{list-filter}
durch \texttt{list-fold} definieren:
%
\begin{alltt}
(define list-filter
  (lambda (p? lis)
    (list-fold empty
               (lambda (first result)
                 (if (p? first)
                     (cons first result)
                     result))
               lis)))
\end{alltt}
%
Ein weiteres Beispiel~-- die Funktion
\texttt{every?}\index{every?@\texttt{every?}} findet heraus, ob ein
übergebenes Prädikat auf alle Elemente einer Liste zutrifft:
\label{page:every}
%
\begin{alltt}
; prüfen, ob Prädikat auf alle Elemente einer Liste zutrifft
(: every? ((%a -> boolean) (list-of %a) -> boolean))
(define every?
  (lambda (p? lis)
    (list-fold #t
               (lambda (first result)
                 (and result
                      (p? first)))
               lis)))
\end{alltt}
%
Anders als \texttt{list-length} lassen sich diese Definitionen
nicht mit separaten Hilfsfunktionen schreiben.  Für
\texttt{list-filter} würde ein Versuch zwar so aussehen:
%
\begin{alltt}
(define list-filter-helper
  (lambda (first result)
    (if (p? first)
        (cons first result)
        result)))
\end{alltt}
%
In \drscheme{} erscheint bei dieser Definition eine Fehlermeldung 
"<\texttt{unbound variable}"> und \texttt{p?} wird rosa markiert.  Das
liegt daran, daß \texttt{p?} weiter außen im \texttt{lambda} von
\texttt{filter} gebunden ist.  Dieses \texttt{p?} ist aber nach den
Regeln der lexikalischen Bindung\index{lexikalische Bindung} (siehe
Abschnitt~\ref{sec:lexical-binding}) nur im Rumpf des äußeren
\texttt{lambda} in der Definition von \texttt{filter} sichtbar.  Darum
muß der Lambda-Ausdruck der Hilfsfunktion ebenfalls in diesem
Rumpf stehen.

FIXME: Hier auch noch \texttt{map} einführen? Das Unterrichtsbeispiel tat
es\ldots

\section{Funktionfabriken}

Ein nützlicheres Beispiel für eine Higher-Order-Funktion in der
Mathematik ist die
Komposition\index{Komposition}\index{*@$\circ$}
$\circ$.  Seien $f: B\rightarrow C$ und $g: A\rightarrow B$
Funktionen.  Dann ist $f\circ g$ folgendermaßen definiert:
%
\begin{displaymath}
  (f \circ g)(x) \deq{} f(g(x))
\end{displaymath}
%
$\circ$ läßt sich direkt als Funktion
programmieren:\index{compose@\texttt{compose}}
\label{page:compose}
%
\begin{alltt}
; zwei Funktionen komponieren
(: compose ((%b -> %c) (%a -> %b) -> (%a -> %c)))
(define compose
  (lambda (f g)
    (lambda (x)
      (f (g x)))))
\end{alltt}
%
Die beiden Argumente für \texttt{f} und \texttt{g} müssen Funktionen
mit einem Parameter sein:
%
\begin{alltt}
(define add-5
  (lambda (x)
    (+ x 5)))
(define add-23
  (lambda (x)
    (+ 23 x)))
(define add-28 (compose add-5 add-23))
(add-28 3)
\evalsto{} 31
((compose (lambda (x) (* x 2)) add-1) 5)
\evalsto{} 12
\end{alltt}
%
\texttt{Compose} ist eine
\textit{Funktionfabrik\index{Funktionfabrik}}~-- sie liefert selbst
eine Funktion zurück, die abhängig von \texttt{f} und \texttt{g}
konstruiert wird.

\texttt{Compose} läßt sich benutzen, um eine weitere praktische
Higher-Order-Funktion namens
\texttt{repeat} zu definieren:\index{repeat@\texttt{repeat}}
\label{page:repeat}
%
\begin{alltt}
; Funktion wiederholt anwenden
(: repeat (natural (%a -> %a) -> (%a -> %a)))
(define repeat
  (lambda (n proc)
    (if (= n 0)
        (lambda (x) x)
        (compose proc (repeat (- n 1) proc)))))
\end{alltt}
%
\texttt{Repeat} ist das Pendant zur Potenzierung\index{Potenzierung} von
Funktionen in der Mathematik, siehe Definition~\ref{def:power_fun}:
%
\begin{alltt}
((repeat 5 (lambda (n) (* n 2))) 1)
\evalsto{} 32
\end{alltt}

\section{Der Schönfinkel-Isomorphismus}
\label{sec:currying}
\index{Schönfinkel-Isomorphismus}
Hier ist eine Funktionfabrik, die Funktionen erzeugt, die auf eine
Zahl eine Konstante addieren:\index{make-add@\texttt{make-add}}
%
\begin{alltt}
; Funktion erzeugen, die eine Konstante addiert
(: make-add (number -> (number -> number)))
(define make-add
  (lambda (a)
    (lambda (b)
      (+ a b))))
\end{alltt}
%
Angewendet werden kann sie folgendermaßen:
%
\begin{alltt}
(define add-1 (make-add 1))
(add-1 15)
\evalsto{} 16
(define add-7 (make-add 7))
(add-7 15)
\evalsto{} 22
\end{alltt}
%
Das geht auch ohne Zwischendefinitionen:
%
\begin{alltt}
((make-add 7) 15)
\evalsto{} 22
((make-add 13) 42)
\evalsto{} 55
\end{alltt}
%
\texttt{Make-add} ist eine andere Version von \texttt{+}, nämlich
eine, die zwei Argumente nicht "<auf einmal"> akzeptiert, sondern
"<nacheinander">.  Summen von zwei Zahlen, normalerweise geschrieben
als \texttt{(+ $a$ $b$)} lassen sich auch als \texttt{((make-add $a$)
  $b$)} schreiben.  Diese Transformation von einer Funktion mit zwei
Parametern in eine Funktion mit nur einem Parameter, die eine Funktion
mit einem weiteren Parameter zurückgibt, die dann schließlich den "<Wert">
liefert, läßt sich auch auf andere Funktionen anwenden:\index{make-mult@\texttt{make-mult}}\index{make-prepend@\texttt{make-prepend}}
%
\begin{alltt}
; Funktion erzeugen, die mit einer Konstante multipliziert
(: make-mult (number -> (number -> number)))
(define make-mult
  (lambda (a)
    (lambda (b)
      (* a b))))

; Funktion erzeugen, die an eine Liste ein Element vorn anhängt
(: make-prepend (a -> ((list-of a) -> (list-of a))))
(define make-prepend
  (lambda (a)
    (lambda (b)
      (cons a b))))
\end{alltt}
%
Erneut folgt eine ganze Familie von Funktionen einem gemeinsamen
Muster, und erneut läßt sich dieses Muster als Funktion höherer
Ordnung formulieren.  Die Funktion \texttt{curry\index{curry@\texttt{curry}}} akzeptiert
eine Funktion mit zwei Parametern und liefert eine entsprechend
transformierte Funktion zurück:
%
\begin{alltt}
; Funktion mit zwei Parametern staffeln
(: curry ((%a %b -> %c) -> (%a -> (%b -> %c))))
(define curry
  (lambda (proc)
    (lambda (a)
      (lambda (b)
        (proc a b)))))
\end{alltt}
%
Nun lassen sich die \texttt{make-$x$}-Funktionen von oben mit Hilfe
von \texttt{curry} definieren:
%
\begin{alltt}
(define make-add (curry +))
(define make-mult (curry *))
(define make-prepend (curry cons))
\end{alltt}
%
Die \texttt{curry}-Transformation wurde unabhängig voneinander von den
Mathematikern \textsc{Moses Schönfinkel} und \textsc{Haskell Curry} entdeckt.  Im
englischsprachigen Raum heißt das Verb dazu darum  \textit{currify}, im deutschsprachigen Raum
\textit{schönfinkeln\index{schönfinkeln}}
oder \textit{curryfizieren\index{curryfizieren}}.
% Warum heißt dann die Funktion dann curry und nicht currify?

Die Schönfinkel-Transformation läßt sich auch umdrehen:\index{curry@\texttt{curry}}
%
\begin{alltt}
; Funktion zu einer Funktion mit zwei Parametern entstaffeln
(: uncurry ((%a -> (%b -> %c)) -> (%a %b -> %c)))
(define uncurry 
  (lambda (proc)
    (lambda (a b)
      ((proc a) b))))
\end{alltt}
%
Damit ist die Transformation ein \textit{Isomorphismus\index{Isomorphismus}}; es gilt
folgende Gleichung für Funktionen $p$ mit zwei Parametern:\label{sec:curry-isomorphismus}
%
\begin{center}
  \texttt{(uncurry (curry \(p\))) \(\equiv\) \(p\)}
\end{center}

\section*{Aufgaben}

\begin{aufgabe}
  Schreiben Sie eine Funktion \texttt{any?} analog zu 
  \texttt{every?}, die dann \verb|#t| zurückgibt, wenn mindestens ein 
  Element der Liste das Prädikat erfüllt, sonst \verb|#f|.  Schreiben Sie 
  zunächst eine Fassung nach dem Muster von \texttt{every?}.  Schreiben 
  Sie eine zweite Fassung, die einfach \texttt{every?} aufruft und selbst keine
  Rekursion benutzt.
\end{aufgabe}

\begin{aufgabe}
  Eine klassische Higher-Order-Funktion ist \texttt{list-map}, eine Funktion, die 
  eine Funktion und eine Liste akzeptiert.  \texttt{List-map}
  wendet diese Funktion auf alle Elemente der Liste an und produziert
  eine Liste der Rückgabewerte.

  \texttt{List-map} läßt sich beispielsweise folgendermaßen anwenden:
  % 
  \begin{alltt}
    (list-map even? (list 1 2 3 4 5))
    \evalsto{} #<list #f #t #f #t #f>
  \end{alltt}
  % 
  Programmieren Sie \texttt{list-map}, indem sie die Signatur schreiben,
  das Gerüst der Funktion erstellen, Testfälle entwerfen und dann das
  Gerüst vervollständigen!

  \textbf{Hinweis:} \texttt{List-map} ist unter dem Namen \texttt{map} eingebaut.
\end{aufgabe}

\begin{aufgabe}
  Schreiben Sie folgende Funktionen unter der  
  Verwendung von \texttt{filter}!
  \begin{itemize}
    \item Schreiben sie eine Funktion \texttt{evens}, die die ungeraden Zahlen aus 
      einer Liste entfernt,
  \item eine Funktion \texttt{count-zeroes}, die in einer Liste von
    Zahlen die Nullen zählt,
  \item und eine Funktion \texttt{multiples}, die eine Zahl $n$ und
    eine Liste von Zahlen akzeptiert, und eine Liste alle Vielfachen
    der Zahl $n$ liefert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmieren Sie eine Funktion
  \texttt{filter-map}, die als Argumente eine Funktion \texttt{p} mit
  einem Argument sowie eine Liste \texttt{l} akzeptiert.
  \texttt{Filter-map} soll als Ergebnis die Liste der Rückgabewerte
  von \texttt{p} für diejenigen Elemente von \texttt{l} zurückgeben,
  für die \texttt{p} nicht \texttt{\#f} zurückgibt. Beispiel:

\begin{alltt}
(filter-map (lambda (x)
               (if (even? x)
                  (+ x 1)
                  #f))
            (list 1 2 5 17 24 13))
\evalsto{} #<list 3 25>
\end{alltt}
\end{aufgabe}

\begin{aufgabe}
  Verwenden Sie die Funktion \texttt{list-fold} um folgende 
  Funktionen zu schreiben:
  \begin{enumerate}
  \item Schreiben Sie eine Funktion \texttt{list-map}, die eine Funktion auf jedes
    Element einer Liste anwendet.
  \item Schreiben Sie eine Funktion \texttt{list-or}, die ein Prädikat auf alle
    Elemente einer Liste anwendet und die Resultate mit \texttt{or}
    verknüpft.
  \item Schreiben Sie eine Funktion \texttt{count-predicate}, die ein Prädikat auf
    alle Elemente einer Liste anwendet und zählt, wie häufig \verb|#t|
    zurückgegeben wird.
  \item Schreiben Sie eine Funktion \texttt{contains?}, die feststellt, ob ein
    Element in einer Liste enthalten ist.
  \item Schreiben Sie eine Funktion \texttt{remove-duplicates}, die alle doppelten
    Elemente aus einer Liste filtert.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Fußballreporter zitieren gern obskure Fakten über
  vergangene Spiele, wenn Sie zum Spielverlauf wenig zu sagen haben.

  Hier ein Beispiel:
  % 
  \begin{quote}
    "<In der Saison 2009/2010 gab es ja immerhin vier Spieltage, an
    denen die größte Tordifferenz kleiner als 3 war.">
  \end{quote}
  %
\begin{enumerate}
\item Stellen Sie dem Fußballreporter Hilfsfunktionen zur Verfügung,
  die ihm erlauben, eine Antwort auf solch eine Frage zu
  finden:
  %
  \begin{quote}
    \emph{An wie vielen Spieltagen der Saison 2009/2010 war die größte
    Tordifferenz kleiner als 3?}
  \end{quote}
  %
  Schreiben Sie mit Hilfe dieser Funktionen einen Ausdruck, der
  testet, ob die am Anfang dieser Aufgabe zitierte Aussage über die
  Tordifferenzen in der Saison 2009/2010 stimmt!

  \begin{enumerate}
  \item Schreiben Sie eine Funktion, die aus einer Liste die Dubletten
    entfernt.  Diese Funktion akzeptiert eine Liste sowie eine
    Funktion, die zwei Elemente der Liste akzeptiert und
    zurückliefert, ob diese gleich sind.  (Also zum Beispiel
    \texttt{=} bei Listen von Zahlen.)  Sie liefert dann eine Liste,
    in der jedes Element "<nur einmal vorkommt">, also kein anderes,
    das dazu gleich ist.
  \item Schreiben Sie eine Funktion, die aus der Liste aller Spiele
    eine Liste aller Spielplannummern extrahiert.
  \item Schreiben Sie eine Funktion, die aus der Liste aller Spiele
    eine Liste von Listen aller Spiele macht~-- so dass in jeder
    Teilliste alle Spiele eines Spieltags zusammengefasst sind.
  \item Schreiben Sie eine Funktion, welche die Tordifferenz eines
    Spiels zurückliefert.
  \item Schreiben Sie eine Funktion, welche das maximale Element einer
    Liste berechnet.  Die Funktion sollte neben der Liste eine
    Funktion akzeptieren, die berechnet, ob ein Element "<kleiner oder
    gleich"> einem anderen ist.
  \item Schreiben Sie schließlich einen Ausdruck, der die Anzahl der
    Spieltage der Saison 2009/2010 liefert, bei denen die größte
    Tordifferenz kleiner als 3 war.
  \end{enumerate}

  \item Schreiben Sie Ausdrücke, die folgende Fragen beantworten~--
  entwickeln Sie dazu, falls nötig, weitere Hilfsfunktionen:
  \begin{itemize}
    \item An welchem Spieltag gab es die meisten Heimsiege?
    \item An welchem Spieltag fielen die meisten Tore?
    \item Gab es mehr Siege für die Heimmanschaften an ungeraden Spieltagen als an
      geraden?
    \end{itemize}
    
  \item Finden Sie eine besonders
    kreativ-obskure Frage und schreiben Sie den Ausdruck, der sie
    beantwortet.
\end{enumerate} 

\end{aufgabe}

\begin{aufgabe}
  \texttt{List-fold} sammelt die Elemente von hinten nach vorn bzw.
  von rechts nach links auf, entsprechend der "<natürlichen">
  Rekursionsstruktur über Listen.  Das gleiche Spiel läßt sich auch in
  der anderen Richtung durchführen.  Heraus kommt eine Funktion
  \texttt{list-fold-left}, die folgende Gleichung (in
  Infix-Schreibweise) erfüllt:
  % 
  \begin{displaymath}
    \texttt{(list-fold-left}~u~\odot~(a_1~\ldots~a_n)\texttt{)}
    = (\ldots((u\odot a_1)\odot a_2)\ldots\odot a_n)
  \end{displaymath}
  % 
  Programmieren Sie \texttt{list-fold-left}!
\end{aufgabe}


\begin{aufgabe}
  Schreiben Sie ein Programm, das Berechnungen
  mit unendlichen Werten durchführen kann:
  
  \begin{enumerate}
  \item Definieren Sie den gemischten Typ \texttt{number*}, der den
    Datentyp \texttt{number} um $\infty$ (\texttt{infty}) und $- \infty$
    (\texttt{-infty}) erweitert.
  \item Definieren Sie auf der Menge \texttt{number*} die
    Rechenoperationen $+$, $-$, $*$, und $/$.  Geben Sie den Funktionen
    die Namen \texttt{plus*}, \texttt{minus*}, \texttt{mult*} und
    \texttt{div*}.
  \item Definieren Sie $\leq$, also eine Funktion mit dem
    Namen \texttt{<=*}, die die Ordnung auf \texttt{number*} darstellt.
  \item Definieren Sie die Funktionen \texttt{list-max*} und
    \texttt{list-min*}, die das Maximum bzw. das Minimum einer Liste 
    aus \texttt{numbers*} berechnet!  Verwenden Sie hierzu die Funktion \texttt{list-fold}.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{verbatim}
(define x 2)          ;  --> zwei
(define y -1)         ;  --> minuseins
(define z -3)         ;  --> minusdrei

(define f 
  (lambda (x z)
    (+ (* x x) z y)))

(f 4 -2)
\end{verbatim}
  %
  Benenne die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um, und zwar \verb|x| in \verb|zwei|, \verb|y| in
  \verb|minuseins| und \verb|z| in \verb|minusdrei|. Achte bei
  der Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \verb"f" um.

  Nachdem Du die Umbenennung durchgeführt hast, welches Ergebnis liefert
  der Ausdruck \verb"(f 4 -2)"? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.
\end{aufgabe}

\begin{aufgabe}

  Betrachte das folgende Programm:

\begin{verbatim}
(define x 2)                    ; --> zwei
(define y 4)                    ; --> vier

(define z                       ; --> f
  (lambda (x y z)
    (+ x (z y))))

(z y x (lambda (z) (+ x z)))
\end{verbatim}
%
  Benenne die Variablen \verb"x", \verb"y" und \verb"z", die in
  den ersten drei Zeilen des Programms definiert werden, im kompletten
  Programm um. Der neue Name der Variable steht als Kommentar im
  Programm hinter dem Pfeil (\verb"-->").  Achte bei der
  Umbenennung auf die lexikalische Bindung.  Benenne keine
  Parameter der Funktion \verb"z" um.

  Berechne, nachdem Du die Umbenennung durchgeführt haben, von
  Hand mit dem Substitutionsmodell \verb"(z y x"
  \verb"(lambda (z) (+ x z))))" und halte Sie die Zwischenschritte
  fest.

\end{aufgabe}

\begin{aufgabe}
  Betrachte folgendes Programm:

\begin{verbatim}
(define x 1)
(define y 3)
(define z 5)

(define f
  (lambda (x)   
     ((lambda (y)
        ((lambda (z)
           (+ z (* x y)))
         (+ x z)))
      (+ x y))))

(f y)
\end{verbatim}

  Benenne hier alle lokalen Variablen, die innerhalb der Funktion
  \verb"f" gebunden werden, um. Verändere nicht den Namen der
  Variablen \verb"x", \verb"y" und \verb"z" aus den ersten drei Zeilen
  des Programms.

  Nachdem Du die Umbenennung durchgeführt haben, welches Ergebnis liefert
  der Ausdruck \verb"(f y)"? Berechne das Ergebnis von Hand mit Hilfe
  des Substitutionsmodells und halte die Zwischenschritte fest.

  \noindent \emph{Hinweis:} In diesen Aufgaben findest keine
  Kommentare und Signaturen zu den Funktionen. Hier kannst Du an einem
  Beispiel sehen, dass es sehr wichtig ist, diese Informationen
  anderen Programmierern immer zur Verfügung zu stellen. Denn es kann
  auch bei kleinen Programmen schwer sein, die Funktionsweise der
  einzelnen Funktionen ohne Kommentare zu verstehen.
\end{aufgabe}

\begin{aufgabe}
  Funktionen können nicht nur als Argumente an
  andere Funktionen übergeben, sondern auch als Ergebnisse
  zurückgeliefert werden. Dies soll in dieser Aufgabe genutzt werden,
  um ein einfaches Telefonbuch zu implementieren: Ein Telefonbuch ist
  als Funktion repräsentiert, die den Namen einer Person akzeptiert
  und die Telefonnummer der Person zurückliefert. Falls die Person
  nicht im Telefonbuch verzeichnet ist, soll \verb|#f| zurückgeliefert
  werden.

  \begin{enumerate}
  \item Definieren Sie zunächst eine Signatur
    \verb"phonebook-result" für das Ergebnis des Nachschlagens in einem
    Telefonbuch. Das Ergebnis ist entweder die Telefonnummer oder
    \verb|#f|. Die Telefonnummern sind Zeichenketten.
    Die Signatur des Telefonbuchs ist  \verb"string -> phonebook-result".
  \item Definieren Sie einen Wert \verb"empty-phonebook", der das leere
    Telefonbuch repräsentiert.
  \item Definieren Sie eine Funktion namens
    \verb"add-to-phonebook", welche ein Telefonbuch, einen Namen
    und eine Telefonnummer erwartet und das um den neuen Eintrag
    erweiterte
    Telefonbuch zurückliefert.
  \item Schreiben Sie eine Funktion namens \verb"lookup-in-phonebook",
    welche ein Telefonbuch und einen Namen einer Person erwartet und die
    Nummer der Person im Telefonbuch nachschlägt und zurückliefert.
    Beispiele:
    \begin{itemize}
    \item \verb|(lookup-in-phonebook empty-phonebook "Hans")| liefert
      \verb|#f|.
    \item \verb|(lookup-in-phonebook| \\
      \verb|    (add-to-phonebook empty-phonebook "Hans" "754829")|\\
      \verb|    "Hans")| \\
      liefert \verb|"754829"|.
    \item \verb|(lookup-in-phonebook|\\
      \verb|    (add-to-phonebook empty-phonebook "Hans" "754829")|\\
      \verb|    "Lea")|\\
      liefert \verb|#f|.
    \end{itemize}
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Ein Polynom ist eine Funktion von $\mathbb{R}$ nach $\mathbb{R}$ und
  hat folgende Form:
  \begin{displaymath}
    p(x) = a_0 +
    a_1 \cdot x + a_2 \cdot x^2 + \ldots + a_n \cdot x^n    
  \end{displaymath}
  %
  Ein Polynom wird also eindeutig durch die Koeffizienten $a_0$ bis
  $a_n$ bestimmt.

  \begin{enumerate}
   \item Schreiben Sie die Datendefinition für Polynome.
   \item Programmieren Sie eine Funktion \texttt{polynomial+}, die
     zwei Polynome addiert.  Schreiben Sie ggf.\ zutreffende Eigenschaften auf
     und überprüfen Sie diese!
     
   \item Programmieren Sie eine Funktion \texttt{polynomial*}, die zwei Polynome 
     multipliziert. 
     Beispielsweise werden die Polynome $a_0+a_1 x$ und $b_0+b_1 x$ nach folgendem Schema multipliziert:
     \begin{eqnarray*}
     & &a_0 \cdot (b_0+b_1x) \\
     &+&a_1 x \cdot (b_0+b_1 x) \\ 
     &=&a_0b_0+a_0b_1 x + a_1b_0x + a_1b_1x^2
     \end{eqnarray*}	
     Schreiben Sie ggf.\ zutreffende Eigenschaften auf und überprüfen Sie diese!
   \item Schreiben Sie eine Funktion \texttt{polynomial-function}, die
     ein Polynom akzeptiert und eine Funktion liefert, die ein Polynom
     an einer bestimmten Stelle auswertet, also gerade der Funktion
     $p$ aus der Definition entspricht. 
   \item Die Ableitung eines Polynoms $p$ wie oben ist bekanntlich durch
     \begin{displaymath}
       p'(x) = a_1 + 2\cdot a_2 \cdot x + 3\cdot a_3\cdot x^2 + \ldots
       + n \cdot a_n \cdot x^{n-1}
     \end{displaymath}
     gegeben. Schreiben Sie die Funktion
     \texttt{polynomial-derivative}, die von einem gegebenen Polynom das abgeleitete Polynom
     berechnet.
   \item Das Newton-Verfahren dient zur nährungsweisen
     Berechnung von Nullstellen. Für ein gegebenen Startwert nähert sich die
     Iteration 
     \begin{displaymath}
       x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
     \end{displaymath}
     immer näher an eine Nullstelle an.
     Programmieren Sie das Newton-Verfahren!

     Hinweis: Die Lösung soll gut genug sein, wenn der Funktionswert nahe
     bei 0 liegt, also kleiner als eine Toleranz ist. 
     Da das
     Newton-Verfahren nicht immer eine Lösung liefert, programmieren
     Sie Ihre Funktion so, dass Sie nach einer gewissen Anzahl von Schritten
     automatisch abbricht und \verb|#f| zurück gibt.
 \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Listen lassen sich nach verschiedenen Kriterien
  sortieren: zum Beispiel aufsteigend, absteigend, oder abhängig von
  einem Feld der Elemente.  So kann eine Liste von Fußballspielen nach
  der Gesamtanzahl der Tore, der Anzahl der Tore des Heimteams oder
  der Anzahl der Tore des Gästeteams oder der Anzahl der Tore des
  gewinnenden Teams sortiert werden.  Die genaue Anordnung wird durch
  eine Operation festgelegt, die bestimmt, ob ein Elemente vor einem anderen
  stehen soll.

\begin{enumerate}
\item Schreiben Sie eine Funktion, die eine Liste nach einem beliebigen
  Kriterium sortiert.  Die Funktion sollte folgende Signatur haben:

\begin{verbatim}
(: list-sort ((%a %a -> boolean) (list-of %a) -> (list-of %a)))
\end{verbatim}

  Das erste Argument ist eine Funktion, die eine \textit{Halbordnung}
  realisiert, also zwei Elemente vergleicht, und \verb|#t|
  zurückliefert, falls sie schon in der richtigen Reihenfolge sind und
  \verb|#f|, falls nicht.  Zum Beispiel können \verb|<=| oder \verb|>=|
  für das Sortieren von Listen von Zahlen verwendet werden.
\item Benutzen Sie diese Funktion, um eine Liste von
  Fußballspielen nach den folgenden Kriterien zu sortieren:
  \begin{itemize}
  \item Gesamtanzahl der Tore,
  \item Anzahl der Tore des Heimteams,
  \item Anzahl der Tore des Gästeteams oder
  \item Anzahl der Tore des
    gewinnenden Teams
  \end{itemize}
\end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Folgen mit potentiell unendlicher Länge lassen sich als
  zusammengesetzte Daten mit zwei Komponenten repräsentieren: Dabei
  ist die erste Komponente das erste Element der Folge und die zweite
  eine Funktion ohne Parameter, die, wenn sie angewendet wird, eine Folge mit
  den restlichen Elementen ohne das erste liefert.
  Solche unendlichen Folgen heißen \textit{Streams}.
  Schreiben Sie Daten- und Record-Definition für Streams!

  Hier ist eine Funktion, die einen Stream aus natürlichen Zahlen,
  angefangen bei einer Zahl $n$, liefert:
  % 
  \begin{alltt}
; Stream mit Zahlen ab n erzeugen
(: from (natural -> stream))
(define from
  (lambda (n)
    (make-stream n
                 (lambda () (from (+ n 1))))))
  \end{alltt}
  % 
  (Dabei ist angenommen, daß der Konstruktor der Record-Definition
  \texttt{make-stream} heißt.)
  Zur Betrachtung von Streams ist folgende Funktion nützlich, welche
  die ersten $n$ Elemente eines Streams als Liste extrahiert:
  % 
  \begin{alltt}
; erste Elemente eines Streams in eine Liste extrahieren
(: stream-take (natural stream -> (list-of %a)))
(define stream-take
  (lambda (n stream)
    (if (= n 0)
        empty
        (cons (stream-first stream)
                   (stream-take (- n 1)
                                ((stream-rest-proc stream)))))))
   \end{alltt}
   % 
   (Dabei ist angenommen, daß die Selektoren für Streams
   \texttt{stream-first} und \texttt{stream"=rest"=proc} heißen.)
   \texttt{Stream-take} läßt sich z.B.\ auf das Ergebnis von
   \texttt{from} anwenden:
   % 
   \begin{alltt}
(stream-take 17 (from 4))
\evalsto{} #<list 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20>
   \end{alltt}
   % 
   Programmieren Sie einige intellektuelle Herausforderungen mit Streams!
   \begin{enumerate}
   \item Programmieren Sie eine Funktion \texttt{stream-drop}, die eine
     natürliche Zahl $n$ und einen Stream akzeptiert, und einen neuen
     Stream liefert, der aus dem alten durch Weglassen der ersten $n$
     Elemente entsteht:
     \begin{alltt}
(stream-take 17 (stream-drop 3 (from 4)))
\evalsto{} #<list 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23>
     \end{alltt}
   \item Programmieren Sie eine Funktion \texttt{stream-filter} analog zu
     \texttt{filter}:
     % 
     \begin{alltt}
(stream-take 10 (stream-filter odd? (from 1)))
\evalsto{} #<list 1 3 5 7 9 11 13 15 17 19>
     \end{alltt}
   \item Programmieren Sie eine Funktion \texttt{drop-multiples}, die 
     eine Zahl $n$ und einen Stream von Zahlen $s$ akzeptiert.
     \texttt{Drop-multiples} soll einen Stream liefern, in dem
     gegenüber $s$  alle Vielfachen von $n$ entfernt wurden:
     % 
     \begin{alltt}
(stream-take 10 (drop-multiples 3 (from 1)))
\evalsto{} #<list 1 2 4 5 7 8 10 11 13 14>
     \end{alltt}
   \item Schreiben Sie eine Funktion \texttt{sieve}, die aus einem Stream
     von Zahlen all diejenigen Zahlen entfernt, die Vielfache von
     Vorgängern im Stream sind:
     \begin{alltt}
(stream-take 10 (sieve (from 2)))
\evalsto{} #<list 2 3 5 7 11 13 17 19 23 29>
     \end{alltt}
     Um was für Zahlen handelt es sich in dem Beispielaufruf und
     warum?
   \item Schreiben Sie eine Funktion \texttt{powers}, die für eine Zahl
     $n$ einen Stream ihrer Potenzen liefert:
     % 
     \begin{alltt}
(stream-take 10 (powers 2))
\evalsto{} #<list 2 4 8 16 32 64 128 256 512 1024>
     \end{alltt}
   \item Schreiben Sie eine Funktion \texttt{stream-map} analog zu
     \texttt{list-map}:
     \begin{alltt}
(stream-take 10 (stream-map (lambda (x) (+ x 1)) (from 1)))
\evalsto{} #<list 2 3 4 5 6 7 8 9 10 11>
     \end{alltt}
   \item Schreiben Sie eine Funktion \texttt{merge}, die zwei
     aufsteigende Streams von Zahlen zu einem aufsteigenden Stream
     der Elemente beider Streams vereinigt:
     \begin{alltt}
(stream-take 10 (merge (powers 2) (powers 3)))
\evalsto{} #<list 2 3 4 8 9 16 27 32 64 81>
     \end{alltt}
   \item Schreiben Sie eine Definition für einen Stream aufsteigend
     sortierter Potenzen von Primzahlen:
     \begin{alltt}
(stream-take 10 prime-powers)
\evalsto{} #<list 2 3 4 5 7 8 9 11 13 16>
     \end{alltt}
     Definieren Sie dazu zunächst einen Stream aus Streams von Potenzen
     % 
     \begin{alltt}
(define prime-powers-stream (stream-map powers (sieve (from 2))))
     \end{alltt}
     % 
     Definieren Sie eine Funktion \texttt{merge-streams}, welche
     diesen Stream akzeptiert und die Elemente der Streams
     aus \texttt{prime-powers-stream} mit Hilfe von \texttt{merge}
     aufsteigend sortiert.
   \end{enumerate}
 \end{aufgabe}

 \begin{aufgabe}
  Betrachten Sie folgende mysteriöse Funktion:
\begin{verbatim}
(: // ((%a -> (%b -> %b)) (list-of %a) -> (%b -> %b)))

(define //
  (lambda (proc lis)
    (cond
      ((empty? lis)
       (lambda (y)
         y))
      ((cons? lis)
       (lambda (y)
         ((proc (first lis))
          ((// proc (rest lis))
           y)))))))
\end{verbatim}
  % 
  \textbf{Hinweise:} Beachten Sie die Signaturen! In mehreren
  Teilaufgaben gibt es Gelegenheiten, \texttt{curry} bzw.\
  \texttt{uncurry} zu benutzen.

  \begin{itemize}
  \item Vergleichen Sie die Funktion mit \texttt{list-fold} und
    beschreiben Sie, wie \texttt{//} und \texttt{list-fold} zueinander
    in Beziehung stehen.  Schreiben Sie, falls möglich, eine
    Definition von \texttt{//}, die \texttt{list-fold} benutzt und
    umgekehrt.
  \item Schreiben Sie mit Hilfe von \texttt{//} eine Funktion
    \texttt{list-sum}, welche die Elemente einer Liste addiert.
  \item Schreiben Sie eine Funktion \texttt{insert}, die eine reelle
    Zahl $n$ akzeptiert und eine Funktion zurückliefert, die eine
    aufsteigend sortierte Liste von reellen Zahlen akzeptiert und
    eine Liste zurückliefert, in der $n$ an die entsprechende
    Stelle der Liste einsortiert wurde.
  \item Schreiben Sie mit Hilfe von \texttt{//} eine Funktion, die
    eine Liste von reellen Zahlen aufsteigend sortiert.
  \end{itemize}
\end{aufgabe}

\begin{aufgabe}
  Programmieren Sie eine Version von
  \texttt{list-fold-left}, nämlich die Funktion
  \texttt{list-fold-left-bonus}, die \texttt{list-fold} benutzt aber
  selbst keine Rekursion enthält und auch keine rekursiven
  Hilfsfunktionen aufruft.
\end{aufgabe}


\begin{aufgabe}
  Betrachten Sie folgendes mysteriöse Programm:
  % 
  \begin{alltt}
(define y
  (lambda (f)
    ((lambda (x)
       (f (lambda (z) ((x x) z))))
     (lambda (x)
       (f (lambda (z) ((x x) z)))))))

(define m
  (y
   (lambda (f)
     (lambda (x)
       (if (= x 1)
           1
           (* x (f (- x 1))))))))
   \end{alltt}
  %
   Was macht \texttt{m}?  \texttt{Y} wird auch
   \textit{Fixpunktkombinator} genannt.  Erklären Sie einem Anfänger, der
   gerade drei Informatik-Stunden hinter sich hat, diesen Begriff~--
   außerdem was
   \texttt{y} bewirkt und warum.
 \end{aufgabe}

\begin{aufgabe}
  Beweisen Sie, dass für Funktionen $p_1$ mit einem Parameter, die
  einparametrige Funktionen zurückgeben, und Funktionen $p_2$ mit zwei
  Parametern gilt:
  %
  \begin{center}
    \texttt{(curry (uncurry $p_1$))} $\equiv$ $p_1$\\
    \texttt{(uncurry (curry $p_2$))} $\equiv$ $p_2$
  \end{center}
 \end{aufgabe}

\begin{aufgabe}
  Eine Funktion $f$ ist idempotent, wenn gilt:

  \begin{center}
    \texttt{(compose $f$ $f$) $\equiv$ $f$}
  \end{center}

  Zeigen Sie, dass folgende Funktion idempotent ist:

  \begin{alltt}
    (define abs
      (lambda (x)
         (if (negative? x)
             (- x)
             x)))  \end{alltt}

  Welche anderen idempotente Funktionen kennen Sie?
\end{aufgabe}

\begin{aufgabe}
  Zwei Funktionen $f$ und $g$ sind invers
  zueinander, wenn gilt:

  \begin{center}
    \texttt{(compose $f$ $g$) $\equiv$ id} und \texttt{(compose $g$ $f$) $\equiv$ id}
  \end{center}

  Zeigen Sie, dass \texttt{curry} und \texttt{uncurry} invers zueinander sind.
\end{aufgabe}

\begin{aufgabe}
  Betrachten Sie folgende Funktion:

  \begin{alltt}
(define mystery
  (lambda (l)
    (list-fold empty append
               (map (lambda (x)
                      (cons x empty))
                    l))))
  \end{alltt}

  \begin{enumerate}
  \item Was macht \texttt{mystery}?

  \item Schreiben Sie eine Signatur für \texttt{mystery}.

  \item Beweisen Sie, dass \texttt{mystery} tatsächlich das macht, was
    Sie vermuten.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}
  Beweisen Sie: $\forall n \in \mathbb{N}$ gilt
  \texttt{(repeat $n$ id) $=$ id}, wobei \texttt{id} die
  Identitätsfunktion ist.
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
